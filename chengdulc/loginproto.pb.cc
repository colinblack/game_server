// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loginproto.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "loginproto.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace proto {
namespace game {

namespace {

const ::google::protobuf::Descriptor* ReqLogin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqLogin_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqLogout_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqLogout_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqEmotion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqEmotion_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckLoginSuccessUc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckLoginSuccessUc_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckLoginSuccessBc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckLoginSuccessBc_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckLoginError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckLoginError_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckLogoutBc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckLogoutBc_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckUpTableSuccess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckUpTableSuccess_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckUpTableErrorUc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckUpTableErrorUc_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckAheadDownTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckAheadDownTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckDownTableSuccess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckDownTableSuccess_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckPrereadyBC_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckPrereadyBC_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckEmotionBC_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckEmotionBC_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ErrCode_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_loginproto_2eproto() {
  protobuf_AddDesc_loginproto_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "loginproto.proto");
  GOOGLE_CHECK(file != NULL);
  ReqLogin_descriptor_ = file->message_type(0);
  static const int ReqLogin_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogin, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogin, skey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogin, roomid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogin, req_count_),
  };
  ReqLogin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqLogin_descriptor_,
      ReqLogin::default_instance_,
      ReqLogin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqLogin));
  ReqLogout_descriptor_ = file->message_type(1);
  static const int ReqLogout_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogout, uid_),
  };
  ReqLogout_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqLogout_descriptor_,
      ReqLogout::default_instance_,
      ReqLogout_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogout, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqLogout, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqLogout));
  ReqEmotion_descriptor_ = file->message_type(2);
  static const int ReqEmotion_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqEmotion, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqEmotion, target_seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqEmotion, type_),
  };
  ReqEmotion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqEmotion_descriptor_,
      ReqEmotion::default_instance_,
      ReqEmotion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqEmotion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqEmotion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqEmotion));
  AckLoginSuccessUc_descriptor_ = file->message_type(3);
  static const int AckLoginSuccessUc_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, avatar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, ready_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, rmb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, see_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, sex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, uid_),
  };
  AckLoginSuccessUc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckLoginSuccessUc_descriptor_,
      AckLoginSuccessUc::default_instance_,
      AckLoginSuccessUc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessUc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckLoginSuccessUc));
  AckLoginSuccessBc_descriptor_ = file->message_type(4);
  static const int AckLoginSuccessBc_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, avatar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, sex_),
  };
  AckLoginSuccessBc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckLoginSuccessBc_descriptor_,
      AckLoginSuccessBc::default_instance_,
      AckLoginSuccessBc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginSuccessBc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckLoginSuccessBc));
  AckLoginError_descriptor_ = file->message_type(5);
  static const int AckLoginError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginError, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginError, code_),
  };
  AckLoginError_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckLoginError_descriptor_,
      AckLoginError::default_instance_,
      AckLoginError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginError, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLoginError, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckLoginError));
  AckLogoutBc_descriptor_ = file->message_type(6);
  static const int AckLogoutBc_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLogoutBc, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLogoutBc, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLogoutBc, type_),
  };
  AckLogoutBc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckLogoutBc_descriptor_,
      AckLogoutBc::default_instance_,
      AckLogoutBc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLogoutBc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckLogoutBc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckLogoutBc));
  AckUpTableSuccess_descriptor_ = file->message_type(7);
  static const int AckUpTableSuccess_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, ready_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, sex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, avatar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, exp_),
  };
  AckUpTableSuccess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckUpTableSuccess_descriptor_,
      AckUpTableSuccess::default_instance_,
      AckUpTableSuccess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableSuccess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckUpTableSuccess));
  AckUpTableErrorUc_descriptor_ = file->message_type(8);
  static const int AckUpTableErrorUc_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableErrorUc, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableErrorUc, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableErrorUc, code_),
  };
  AckUpTableErrorUc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckUpTableErrorUc_descriptor_,
      AckUpTableErrorUc::default_instance_,
      AckUpTableErrorUc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableErrorUc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpTableErrorUc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckUpTableErrorUc));
  AckAheadDownTable_descriptor_ = file->message_type(9);
  static const int AckAheadDownTable_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAheadDownTable, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAheadDownTable, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAheadDownTable, down_tag_),
  };
  AckAheadDownTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckAheadDownTable_descriptor_,
      AckAheadDownTable::default_instance_,
      AckAheadDownTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAheadDownTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAheadDownTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckAheadDownTable));
  AckDownTableSuccess_descriptor_ = file->message_type(10);
  static const int AckDownTableSuccess_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckDownTableSuccess, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckDownTableSuccess, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckDownTableSuccess, money_),
  };
  AckDownTableSuccess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckDownTableSuccess_descriptor_,
      AckDownTableSuccess::default_instance_,
      AckDownTableSuccess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckDownTableSuccess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckDownTableSuccess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckDownTableSuccess));
  AckPrereadyBC_descriptor_ = file->message_type(11);
  static const int AckPrereadyBC_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckPrereadyBC, roomid_),
  };
  AckPrereadyBC_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckPrereadyBC_descriptor_,
      AckPrereadyBC::default_instance_,
      AckPrereadyBC_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckPrereadyBC, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckPrereadyBC, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckPrereadyBC));
  AckEmotionBC_descriptor_ = file->message_type(12);
  static const int AckEmotionBC_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, target_seatid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, target_seat_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, type_),
  };
  AckEmotionBC_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckEmotionBC_descriptor_,
      AckEmotionBC::default_instance_,
      AckEmotionBC_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckEmotionBC, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckEmotionBC));
  ErrCode_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_loginproto_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqLogin_descriptor_, &ReqLogin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqLogout_descriptor_, &ReqLogout::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqEmotion_descriptor_, &ReqEmotion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckLoginSuccessUc_descriptor_, &AckLoginSuccessUc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckLoginSuccessBc_descriptor_, &AckLoginSuccessBc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckLoginError_descriptor_, &AckLoginError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckLogoutBc_descriptor_, &AckLogoutBc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckUpTableSuccess_descriptor_, &AckUpTableSuccess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckUpTableErrorUc_descriptor_, &AckUpTableErrorUc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckAheadDownTable_descriptor_, &AckAheadDownTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckDownTableSuccess_descriptor_, &AckDownTableSuccess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckPrereadyBC_descriptor_, &AckPrereadyBC::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckEmotionBC_descriptor_, &AckEmotionBC::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_loginproto_2eproto() {
  delete ReqLogin::default_instance_;
  delete ReqLogin_reflection_;
  delete ReqLogout::default_instance_;
  delete ReqLogout_reflection_;
  delete ReqEmotion::default_instance_;
  delete ReqEmotion_reflection_;
  delete AckLoginSuccessUc::default_instance_;
  delete AckLoginSuccessUc_reflection_;
  delete AckLoginSuccessBc::default_instance_;
  delete AckLoginSuccessBc_reflection_;
  delete AckLoginError::default_instance_;
  delete AckLoginError_reflection_;
  delete AckLogoutBc::default_instance_;
  delete AckLogoutBc_reflection_;
  delete AckUpTableSuccess::default_instance_;
  delete AckUpTableSuccess_reflection_;
  delete AckUpTableErrorUc::default_instance_;
  delete AckUpTableErrorUc_reflection_;
  delete AckAheadDownTable::default_instance_;
  delete AckAheadDownTable_reflection_;
  delete AckDownTableSuccess::default_instance_;
  delete AckDownTableSuccess_reflection_;
  delete AckPrereadyBC::default_instance_;
  delete AckPrereadyBC_reflection_;
  delete AckEmotionBC::default_instance_;
  delete AckEmotionBC_reflection_;
}

void protobuf_AddDesc_loginproto_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020loginproto.proto\022\nproto.game\"H\n\010ReqLog"
    "in\022\013\n\003uid\030\001 \002(\005\022\014\n\004skey\030\002 \001(\014\022\016\n\006roomid\030"
    "\003 \001(\014\022\021\n\treq_count\030\004 \001(\005\"\030\n\tReqLogout\022\013\n"
    "\003uid\030\001 \002(\005\"A\n\nReqEmotion\022\016\n\006seatid\030\001 \002(\005"
    "\022\025\n\rtarget_seatid\030\002 \001(\005\022\014\n\004type\030\003 \001(\005\"\240\001"
    "\n\021AckLoginSuccessUc\022\016\n\006seatid\030\001 \002(\005\022\016\n\006a"
    "vatar\030\002 \001(\014\022\013\n\003exp\030\003 \001(\005\022\r\n\005money\030\004 \001(\005\022"
    "\014\n\004name\030\005 \001(\014\022\r\n\005ready\030\006 \001(\005\022\013\n\003rmb\030\007 \001("
    "\005\022\013\n\003see\030\010 \001(\005\022\013\n\003sex\030\t \001(\005\022\013\n\003uid\030\n \001(\005"
    "\"j\n\021AckLoginSuccessBc\022\016\n\006seatid\030\001 \002(\005\022\013\n"
    "\003uid\030\002 \001(\005\022\r\n\005money\030\003 \001(\005\022\014\n\004name\030\004 \001(\014\022"
    "\016\n\006avatar\030\005 \001(\014\022\013\n\003sex\030\006 \001(\005\"*\n\rAckLogin"
    "Error\022\013\n\003uid\030\001 \002(\005\022\014\n\004code\030\002 \001(\005\"8\n\013AckL"
    "ogoutBc\022\016\n\006seatid\030\001 \002(\005\022\013\n\003uid\030\002 \001(\005\022\014\n\004"
    "type\030\003 \001(\005\"\206\001\n\021AckUpTableSuccess\022\013\n\003uid\030"
    "\001 \002(\005\022\016\n\006seatid\030\002 \001(\005\022\r\n\005ready\030\003 \001(\005\022\014\n\004"
    "name\030\004 \001(\014\022\013\n\003sex\030\005 \001(\005\022\016\n\006avatar\030\006 \001(\014\022"
    "\r\n\005money\030\007 \001(\005\022\013\n\003exp\030\010 \001(\005\"=\n\021AckUpTabl"
    "eErrorUc\022\013\n\003uid\030\001 \002(\005\022\r\n\005money\030\002 \001(\005\022\014\n\004"
    "code\030\003 \001(\005\"B\n\021AckAheadDownTable\022\013\n\003uid\030\001"
    " \002(\005\022\016\n\006seatid\030\002 \001(\005\022\020\n\010down_tag\030\003 \001(\005\"A"
    "\n\023AckDownTableSuccess\022\013\n\003uid\030\001 \002(\005\022\016\n\006se"
    "atid\030\002 \001(\005\022\r\n\005money\030\003 \001(\005\"\037\n\rAckPreready"
    "BC\022\016\n\006roomid\030\001 \002(\014\"k\n\014AckEmotionBC\022\016\n\006se"
    "atid\030\001 \002(\005\022\r\n\005money\030\002 \001(\005\022\025\n\rtarget_seat"
    "id\030\003 \001(\005\022\027\n\017target_seat_num\030\004 \001(\005\022\014\n\004typ"
    "e\030\005 \001(\005*\264\001\n\007ErrCode\022\037\n\033DIS_ROOM_MORETHAN"
    "_TWICE_ERR\020e\022\034\n\030USER_ALREADY_IN_SEAT_ERR"
    "\020f\022\035\n\031USER_NO_MONEY_UPTABLE_ERR\020h\022\027\n\023NO_"
    "UPTABLE_SEAT_ERR\020i\022\034\n\027USER_NO_MONEY_LOGI"
    "N_ERR\020\374\003\022\024\n\017ROOM_STATUS_ERR\020\340\004", 1230);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "loginproto.proto", &protobuf_RegisterTypes);
  ReqLogin::default_instance_ = new ReqLogin();
  ReqLogout::default_instance_ = new ReqLogout();
  ReqEmotion::default_instance_ = new ReqEmotion();
  AckLoginSuccessUc::default_instance_ = new AckLoginSuccessUc();
  AckLoginSuccessBc::default_instance_ = new AckLoginSuccessBc();
  AckLoginError::default_instance_ = new AckLoginError();
  AckLogoutBc::default_instance_ = new AckLogoutBc();
  AckUpTableSuccess::default_instance_ = new AckUpTableSuccess();
  AckUpTableErrorUc::default_instance_ = new AckUpTableErrorUc();
  AckAheadDownTable::default_instance_ = new AckAheadDownTable();
  AckDownTableSuccess::default_instance_ = new AckDownTableSuccess();
  AckPrereadyBC::default_instance_ = new AckPrereadyBC();
  AckEmotionBC::default_instance_ = new AckEmotionBC();
  ReqLogin::default_instance_->InitAsDefaultInstance();
  ReqLogout::default_instance_->InitAsDefaultInstance();
  ReqEmotion::default_instance_->InitAsDefaultInstance();
  AckLoginSuccessUc::default_instance_->InitAsDefaultInstance();
  AckLoginSuccessBc::default_instance_->InitAsDefaultInstance();
  AckLoginError::default_instance_->InitAsDefaultInstance();
  AckLogoutBc::default_instance_->InitAsDefaultInstance();
  AckUpTableSuccess::default_instance_->InitAsDefaultInstance();
  AckUpTableErrorUc::default_instance_->InitAsDefaultInstance();
  AckAheadDownTable::default_instance_->InitAsDefaultInstance();
  AckDownTableSuccess::default_instance_->InitAsDefaultInstance();
  AckPrereadyBC::default_instance_->InitAsDefaultInstance();
  AckEmotionBC::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_loginproto_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_loginproto_2eproto {
  StaticDescriptorInitializer_loginproto_2eproto() {
    protobuf_AddDesc_loginproto_2eproto();
  }
} static_descriptor_initializer_loginproto_2eproto_;
const ::google::protobuf::EnumDescriptor* ErrCode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ErrCode_descriptor_;
}
bool ErrCode_IsValid(int value) {
  switch(value) {
    case 101:
    case 102:
    case 104:
    case 105:
    case 508:
    case 608:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ReqLogin::kUidFieldNumber;
const int ReqLogin::kSkeyFieldNumber;
const int ReqLogin::kRoomidFieldNumber;
const int ReqLogin::kReqCountFieldNumber;
#endif  // !_MSC_VER

ReqLogin::ReqLogin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqLogin::InitAsDefaultInstance() {
}

ReqLogin::ReqLogin(const ReqLogin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqLogin::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  req_count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqLogin::~ReqLogin() {
  SharedDtor();
}

void ReqLogin::SharedDtor() {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    delete skey_;
  }
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (this != default_instance_) {
  }
}

void ReqLogin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqLogin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqLogin_descriptor_;
}

const ReqLogin& ReqLogin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

ReqLogin* ReqLogin::default_instance_ = NULL;

ReqLogin* ReqLogin::New() const {
  return new ReqLogin;
}

void ReqLogin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    if (has_skey()) {
      if (skey_ != &::google::protobuf::internal::kEmptyString) {
        skey_->clear();
      }
    }
    if (has_roomid()) {
      if (roomid_ != &::google::protobuf::internal::kEmptyString) {
        roomid_->clear();
      }
    }
    req_count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqLogin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_skey;
        break;
      }

      // optional bytes skey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_skey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_skey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_roomid;
        break;
      }

      // optional bytes roomid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roomid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_roomid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_req_count;
        break;
      }

      // optional int32 req_count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_req_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &req_count_)));
          set_has_req_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqLogin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional bytes skey = 2;
  if (has_skey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->skey(), output);
  }

  // optional bytes roomid = 3;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->roomid(), output);
  }

  // optional int32 req_count = 4;
  if (has_req_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->req_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqLogin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional bytes skey = 2;
  if (has_skey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->skey(), target);
  }

  // optional bytes roomid = 3;
  if (has_roomid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->roomid(), target);
  }

  // optional int32 req_count = 4;
  if (has_req_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->req_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqLogin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional bytes skey = 2;
    if (has_skey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->skey());
    }

    // optional bytes roomid = 3;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->roomid());
    }

    // optional int32 req_count = 4;
    if (has_req_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->req_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqLogin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqLogin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqLogin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqLogin::MergeFrom(const ReqLogin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_skey()) {
      set_skey(from.skey());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_req_count()) {
      set_req_count(from.req_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqLogin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqLogin::CopyFrom(const ReqLogin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLogin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqLogin::Swap(ReqLogin* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(skey_, other->skey_);
    std::swap(roomid_, other->roomid_);
    std::swap(req_count_, other->req_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqLogin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqLogin_descriptor_;
  metadata.reflection = ReqLogin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqLogout::kUidFieldNumber;
#endif  // !_MSC_VER

ReqLogout::ReqLogout()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqLogout::InitAsDefaultInstance() {
}

ReqLogout::ReqLogout(const ReqLogout& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqLogout::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqLogout::~ReqLogout() {
  SharedDtor();
}

void ReqLogout::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReqLogout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqLogout::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqLogout_descriptor_;
}

const ReqLogout& ReqLogout::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

ReqLogout* ReqLogout::default_instance_ = NULL;

ReqLogout* ReqLogout::New() const {
  return new ReqLogout;
}

void ReqLogout::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqLogout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqLogout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqLogout::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqLogout::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqLogout::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqLogout* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqLogout*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqLogout::MergeFrom(const ReqLogout& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqLogout::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqLogout::CopyFrom(const ReqLogout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLogout::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqLogout::Swap(ReqLogout* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqLogout::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqLogout_descriptor_;
  metadata.reflection = ReqLogout_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqEmotion::kSeatidFieldNumber;
const int ReqEmotion::kTargetSeatidFieldNumber;
const int ReqEmotion::kTypeFieldNumber;
#endif  // !_MSC_VER

ReqEmotion::ReqEmotion()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqEmotion::InitAsDefaultInstance() {
}

ReqEmotion::ReqEmotion(const ReqEmotion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqEmotion::SharedCtor() {
  _cached_size_ = 0;
  seatid_ = 0;
  target_seatid_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqEmotion::~ReqEmotion() {
  SharedDtor();
}

void ReqEmotion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReqEmotion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqEmotion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqEmotion_descriptor_;
}

const ReqEmotion& ReqEmotion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

ReqEmotion* ReqEmotion::default_instance_ = NULL;

ReqEmotion* ReqEmotion::New() const {
  return new ReqEmotion;
}

void ReqEmotion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seatid_ = 0;
    target_seatid_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqEmotion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seatid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_target_seatid;
        break;
      }

      // optional int32 target_seatid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_seatid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_seatid_)));
          set_has_target_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqEmotion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seatid(), output);
  }

  // optional int32 target_seatid = 2;
  if (has_target_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->target_seatid(), output);
  }

  // optional int32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqEmotion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seatid(), target);
  }

  // optional int32 target_seatid = 2;
  if (has_target_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->target_seatid(), target);
  }

  // optional int32 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqEmotion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seatid = 1;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 target_seatid = 2;
    if (has_target_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_seatid());
    }

    // optional int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqEmotion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqEmotion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqEmotion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqEmotion::MergeFrom(const ReqEmotion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_target_seatid()) {
      set_target_seatid(from.target_seatid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqEmotion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqEmotion::CopyFrom(const ReqEmotion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqEmotion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqEmotion::Swap(ReqEmotion* other) {
  if (other != this) {
    std::swap(seatid_, other->seatid_);
    std::swap(target_seatid_, other->target_seatid_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqEmotion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqEmotion_descriptor_;
  metadata.reflection = ReqEmotion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckLoginSuccessUc::kSeatidFieldNumber;
const int AckLoginSuccessUc::kAvatarFieldNumber;
const int AckLoginSuccessUc::kExpFieldNumber;
const int AckLoginSuccessUc::kMoneyFieldNumber;
const int AckLoginSuccessUc::kNameFieldNumber;
const int AckLoginSuccessUc::kReadyFieldNumber;
const int AckLoginSuccessUc::kRmbFieldNumber;
const int AckLoginSuccessUc::kSeeFieldNumber;
const int AckLoginSuccessUc::kSexFieldNumber;
const int AckLoginSuccessUc::kUidFieldNumber;
#endif  // !_MSC_VER

AckLoginSuccessUc::AckLoginSuccessUc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckLoginSuccessUc::InitAsDefaultInstance() {
}

AckLoginSuccessUc::AckLoginSuccessUc(const AckLoginSuccessUc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckLoginSuccessUc::SharedCtor() {
  _cached_size_ = 0;
  seatid_ = 0;
  avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  exp_ = 0;
  money_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ready_ = 0;
  rmb_ = 0;
  see_ = 0;
  sex_ = 0;
  uid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckLoginSuccessUc::~AckLoginSuccessUc() {
  SharedDtor();
}

void AckLoginSuccessUc::SharedDtor() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AckLoginSuccessUc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckLoginSuccessUc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckLoginSuccessUc_descriptor_;
}

const AckLoginSuccessUc& AckLoginSuccessUc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckLoginSuccessUc* AckLoginSuccessUc::default_instance_ = NULL;

AckLoginSuccessUc* AckLoginSuccessUc::New() const {
  return new AckLoginSuccessUc;
}

void AckLoginSuccessUc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seatid_ = 0;
    if (has_avatar()) {
      if (avatar_ != &::google::protobuf::internal::kEmptyString) {
        avatar_->clear();
      }
    }
    exp_ = 0;
    money_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    ready_ = 0;
    rmb_ = 0;
    see_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    sex_ = 0;
    uid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckLoginSuccessUc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seatid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_avatar;
        break;
      }

      // optional bytes avatar = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_avatar()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_exp;
        break;
      }

      // optional int32 exp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_money;
        break;
      }

      // optional int32 money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }

      // optional bytes name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ready;
        break;
      }

      // optional int32 ready = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ready:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ready_)));
          set_has_ready();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_rmb;
        break;
      }

      // optional int32 rmb = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rmb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rmb_)));
          set_has_rmb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_see;
        break;
      }

      // optional int32 see = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_see:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &see_)));
          set_has_see();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_sex;
        break;
      }

      // optional int32 sex = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_uid;
        break;
      }

      // optional int32 uid = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckLoginSuccessUc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seatid(), output);
  }

  // optional bytes avatar = 2;
  if (has_avatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->avatar(), output);
  }

  // optional int32 exp = 3;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->exp(), output);
  }

  // optional int32 money = 4;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->money(), output);
  }

  // optional bytes name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->name(), output);
  }

  // optional int32 ready = 6;
  if (has_ready()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->ready(), output);
  }

  // optional int32 rmb = 7;
  if (has_rmb()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->rmb(), output);
  }

  // optional int32 see = 8;
  if (has_see()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->see(), output);
  }

  // optional int32 sex = 9;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->sex(), output);
  }

  // optional int32 uid = 10;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->uid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckLoginSuccessUc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seatid(), target);
  }

  // optional bytes avatar = 2;
  if (has_avatar()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->avatar(), target);
  }

  // optional int32 exp = 3;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->exp(), target);
  }

  // optional int32 money = 4;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->money(), target);
  }

  // optional bytes name = 5;
  if (has_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->name(), target);
  }

  // optional int32 ready = 6;
  if (has_ready()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->ready(), target);
  }

  // optional int32 rmb = 7;
  if (has_rmb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->rmb(), target);
  }

  // optional int32 see = 8;
  if (has_see()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->see(), target);
  }

  // optional int32 sex = 9;
  if (has_sex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->sex(), target);
  }

  // optional int32 uid = 10;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->uid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckLoginSuccessUc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seatid = 1;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional bytes avatar = 2;
    if (has_avatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->avatar());
    }

    // optional int32 exp = 3;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 money = 4;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional bytes name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // optional int32 ready = 6;
    if (has_ready()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ready());
    }

    // optional int32 rmb = 7;
    if (has_rmb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rmb());
    }

    // optional int32 see = 8;
    if (has_see()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->see());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 sex = 9;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sex());
    }

    // optional int32 uid = 10;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckLoginSuccessUc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckLoginSuccessUc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckLoginSuccessUc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckLoginSuccessUc::MergeFrom(const AckLoginSuccessUc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_avatar()) {
      set_avatar(from.avatar());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_ready()) {
      set_ready(from.ready());
    }
    if (from.has_rmb()) {
      set_rmb(from.rmb());
    }
    if (from.has_see()) {
      set_see(from.see());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckLoginSuccessUc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckLoginSuccessUc::CopyFrom(const AckLoginSuccessUc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckLoginSuccessUc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckLoginSuccessUc::Swap(AckLoginSuccessUc* other) {
  if (other != this) {
    std::swap(seatid_, other->seatid_);
    std::swap(avatar_, other->avatar_);
    std::swap(exp_, other->exp_);
    std::swap(money_, other->money_);
    std::swap(name_, other->name_);
    std::swap(ready_, other->ready_);
    std::swap(rmb_, other->rmb_);
    std::swap(see_, other->see_);
    std::swap(sex_, other->sex_);
    std::swap(uid_, other->uid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckLoginSuccessUc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckLoginSuccessUc_descriptor_;
  metadata.reflection = AckLoginSuccessUc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckLoginSuccessBc::kSeatidFieldNumber;
const int AckLoginSuccessBc::kUidFieldNumber;
const int AckLoginSuccessBc::kMoneyFieldNumber;
const int AckLoginSuccessBc::kNameFieldNumber;
const int AckLoginSuccessBc::kAvatarFieldNumber;
const int AckLoginSuccessBc::kSexFieldNumber;
#endif  // !_MSC_VER

AckLoginSuccessBc::AckLoginSuccessBc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckLoginSuccessBc::InitAsDefaultInstance() {
}

AckLoginSuccessBc::AckLoginSuccessBc(const AckLoginSuccessBc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckLoginSuccessBc::SharedCtor() {
  _cached_size_ = 0;
  seatid_ = 0;
  uid_ = 0;
  money_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sex_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckLoginSuccessBc::~AckLoginSuccessBc() {
  SharedDtor();
}

void AckLoginSuccessBc::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (this != default_instance_) {
  }
}

void AckLoginSuccessBc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckLoginSuccessBc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckLoginSuccessBc_descriptor_;
}

const AckLoginSuccessBc& AckLoginSuccessBc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckLoginSuccessBc* AckLoginSuccessBc::default_instance_ = NULL;

AckLoginSuccessBc* AckLoginSuccessBc::New() const {
  return new AckLoginSuccessBc;
}

void AckLoginSuccessBc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seatid_ = 0;
    uid_ = 0;
    money_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_avatar()) {
      if (avatar_ != &::google::protobuf::internal::kEmptyString) {
        avatar_->clear();
      }
    }
    sex_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckLoginSuccessBc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seatid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uid;
        break;
      }

      // optional int32 uid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional int32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional bytes name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_avatar;
        break;
      }

      // optional bytes avatar = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_avatar()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_sex;
        break;
      }

      // optional int32 sex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckLoginSuccessBc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seatid(), output);
  }

  // optional int32 uid = 2;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->uid(), output);
  }

  // optional int32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->money(), output);
  }

  // optional bytes name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->name(), output);
  }

  // optional bytes avatar = 5;
  if (has_avatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->avatar(), output);
  }

  // optional int32 sex = 6;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->sex(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckLoginSuccessBc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seatid(), target);
  }

  // optional int32 uid = 2;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->uid(), target);
  }

  // optional int32 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->money(), target);
  }

  // optional bytes name = 4;
  if (has_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->name(), target);
  }

  // optional bytes avatar = 5;
  if (has_avatar()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->avatar(), target);
  }

  // optional int32 sex = 6;
  if (has_sex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->sex(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckLoginSuccessBc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seatid = 1;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 uid = 2;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional bytes name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // optional bytes avatar = 5;
    if (has_avatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->avatar());
    }

    // optional int32 sex = 6;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sex());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckLoginSuccessBc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckLoginSuccessBc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckLoginSuccessBc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckLoginSuccessBc::MergeFrom(const AckLoginSuccessBc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_avatar()) {
      set_avatar(from.avatar());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckLoginSuccessBc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckLoginSuccessBc::CopyFrom(const AckLoginSuccessBc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckLoginSuccessBc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckLoginSuccessBc::Swap(AckLoginSuccessBc* other) {
  if (other != this) {
    std::swap(seatid_, other->seatid_);
    std::swap(uid_, other->uid_);
    std::swap(money_, other->money_);
    std::swap(name_, other->name_);
    std::swap(avatar_, other->avatar_);
    std::swap(sex_, other->sex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckLoginSuccessBc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckLoginSuccessBc_descriptor_;
  metadata.reflection = AckLoginSuccessBc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckLoginError::kUidFieldNumber;
const int AckLoginError::kCodeFieldNumber;
#endif  // !_MSC_VER

AckLoginError::AckLoginError()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckLoginError::InitAsDefaultInstance() {
}

AckLoginError::AckLoginError(const AckLoginError& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckLoginError::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckLoginError::~AckLoginError() {
  SharedDtor();
}

void AckLoginError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckLoginError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckLoginError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckLoginError_descriptor_;
}

const AckLoginError& AckLoginError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckLoginError* AckLoginError::default_instance_ = NULL;

AckLoginError* AckLoginError::New() const {
  return new AckLoginError;
}

void AckLoginError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckLoginError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // optional int32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckLoginError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional int32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->code(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckLoginError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional int32 code = 2;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->code(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckLoginError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckLoginError::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckLoginError* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckLoginError*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckLoginError::MergeFrom(const AckLoginError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckLoginError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckLoginError::CopyFrom(const AckLoginError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckLoginError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckLoginError::Swap(AckLoginError* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckLoginError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckLoginError_descriptor_;
  metadata.reflection = AckLoginError_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckLogoutBc::kSeatidFieldNumber;
const int AckLogoutBc::kUidFieldNumber;
const int AckLogoutBc::kTypeFieldNumber;
#endif  // !_MSC_VER

AckLogoutBc::AckLogoutBc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckLogoutBc::InitAsDefaultInstance() {
}

AckLogoutBc::AckLogoutBc(const AckLogoutBc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckLogoutBc::SharedCtor() {
  _cached_size_ = 0;
  seatid_ = 0;
  uid_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckLogoutBc::~AckLogoutBc() {
  SharedDtor();
}

void AckLogoutBc::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckLogoutBc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckLogoutBc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckLogoutBc_descriptor_;
}

const AckLogoutBc& AckLogoutBc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckLogoutBc* AckLogoutBc::default_instance_ = NULL;

AckLogoutBc* AckLogoutBc::New() const {
  return new AckLogoutBc;
}

void AckLogoutBc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seatid_ = 0;
    uid_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckLogoutBc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seatid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uid;
        break;
      }

      // optional int32 uid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckLogoutBc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seatid(), output);
  }

  // optional int32 uid = 2;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->uid(), output);
  }

  // optional int32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckLogoutBc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seatid(), target);
  }

  // optional int32 uid = 2;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->uid(), target);
  }

  // optional int32 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckLogoutBc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seatid = 1;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 uid = 2;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckLogoutBc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckLogoutBc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckLogoutBc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckLogoutBc::MergeFrom(const AckLogoutBc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckLogoutBc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckLogoutBc::CopyFrom(const AckLogoutBc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckLogoutBc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckLogoutBc::Swap(AckLogoutBc* other) {
  if (other != this) {
    std::swap(seatid_, other->seatid_);
    std::swap(uid_, other->uid_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckLogoutBc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckLogoutBc_descriptor_;
  metadata.reflection = AckLogoutBc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckUpTableSuccess::kUidFieldNumber;
const int AckUpTableSuccess::kSeatidFieldNumber;
const int AckUpTableSuccess::kReadyFieldNumber;
const int AckUpTableSuccess::kNameFieldNumber;
const int AckUpTableSuccess::kSexFieldNumber;
const int AckUpTableSuccess::kAvatarFieldNumber;
const int AckUpTableSuccess::kMoneyFieldNumber;
const int AckUpTableSuccess::kExpFieldNumber;
#endif  // !_MSC_VER

AckUpTableSuccess::AckUpTableSuccess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckUpTableSuccess::InitAsDefaultInstance() {
}

AckUpTableSuccess::AckUpTableSuccess(const AckUpTableSuccess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckUpTableSuccess::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  seatid_ = 0;
  ready_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sex_ = 0;
  avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  money_ = 0;
  exp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckUpTableSuccess::~AckUpTableSuccess() {
  SharedDtor();
}

void AckUpTableSuccess::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (this != default_instance_) {
  }
}

void AckUpTableSuccess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckUpTableSuccess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckUpTableSuccess_descriptor_;
}

const AckUpTableSuccess& AckUpTableSuccess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckUpTableSuccess* AckUpTableSuccess::default_instance_ = NULL;

AckUpTableSuccess* AckUpTableSuccess::New() const {
  return new AckUpTableSuccess;
}

void AckUpTableSuccess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    seatid_ = 0;
    ready_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    sex_ = 0;
    if (has_avatar()) {
      if (avatar_ != &::google::protobuf::internal::kEmptyString) {
        avatar_->clear();
      }
    }
    money_ = 0;
    exp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckUpTableSuccess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seatid;
        break;
      }

      // optional int32 seatid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seatid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ready;
        break;
      }

      // optional int32 ready = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ready:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ready_)));
          set_has_ready();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional bytes name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_sex;
        break;
      }

      // optional int32 sex = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_avatar;
        break;
      }

      // optional bytes avatar = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_avatar()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_money;
        break;
      }

      // optional int32 money = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_exp;
        break;
      }

      // optional int32 exp = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckUpTableSuccess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional int32 seatid = 2;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seatid(), output);
  }

  // optional int32 ready = 3;
  if (has_ready()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ready(), output);
  }

  // optional bytes name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->name(), output);
  }

  // optional int32 sex = 5;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->sex(), output);
  }

  // optional bytes avatar = 6;
  if (has_avatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->avatar(), output);
  }

  // optional int32 money = 7;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->money(), output);
  }

  // optional int32 exp = 8;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->exp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckUpTableSuccess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional int32 seatid = 2;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seatid(), target);
  }

  // optional int32 ready = 3;
  if (has_ready()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->ready(), target);
  }

  // optional bytes name = 4;
  if (has_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->name(), target);
  }

  // optional int32 sex = 5;
  if (has_sex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->sex(), target);
  }

  // optional bytes avatar = 6;
  if (has_avatar()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->avatar(), target);
  }

  // optional int32 money = 7;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->money(), target);
  }

  // optional int32 exp = 8;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->exp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckUpTableSuccess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 seatid = 2;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 ready = 3;
    if (has_ready()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ready());
    }

    // optional bytes name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // optional int32 sex = 5;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sex());
    }

    // optional bytes avatar = 6;
    if (has_avatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->avatar());
    }

    // optional int32 money = 7;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 exp = 8;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckUpTableSuccess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckUpTableSuccess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckUpTableSuccess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckUpTableSuccess::MergeFrom(const AckUpTableSuccess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_ready()) {
      set_ready(from.ready());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_avatar()) {
      set_avatar(from.avatar());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckUpTableSuccess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckUpTableSuccess::CopyFrom(const AckUpTableSuccess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckUpTableSuccess::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckUpTableSuccess::Swap(AckUpTableSuccess* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(seatid_, other->seatid_);
    std::swap(ready_, other->ready_);
    std::swap(name_, other->name_);
    std::swap(sex_, other->sex_);
    std::swap(avatar_, other->avatar_);
    std::swap(money_, other->money_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckUpTableSuccess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckUpTableSuccess_descriptor_;
  metadata.reflection = AckUpTableSuccess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckUpTableErrorUc::kUidFieldNumber;
const int AckUpTableErrorUc::kMoneyFieldNumber;
const int AckUpTableErrorUc::kCodeFieldNumber;
#endif  // !_MSC_VER

AckUpTableErrorUc::AckUpTableErrorUc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckUpTableErrorUc::InitAsDefaultInstance() {
}

AckUpTableErrorUc::AckUpTableErrorUc(const AckUpTableErrorUc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckUpTableErrorUc::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  money_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckUpTableErrorUc::~AckUpTableErrorUc() {
  SharedDtor();
}

void AckUpTableErrorUc::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckUpTableErrorUc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckUpTableErrorUc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckUpTableErrorUc_descriptor_;
}

const AckUpTableErrorUc& AckUpTableErrorUc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckUpTableErrorUc* AckUpTableErrorUc::default_instance_ = NULL;

AckUpTableErrorUc* AckUpTableErrorUc::New() const {
  return new AckUpTableErrorUc;
}

void AckUpTableErrorUc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    money_ = 0;
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckUpTableErrorUc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_money;
        break;
      }

      // optional int32 money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_code;
        break;
      }

      // optional int32 code = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckUpTableErrorUc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional int32 money = 2;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->money(), output);
  }

  // optional int32 code = 3;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->code(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckUpTableErrorUc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional int32 money = 2;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->money(), target);
  }

  // optional int32 code = 3;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->code(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckUpTableErrorUc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 money = 2;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 code = 3;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckUpTableErrorUc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckUpTableErrorUc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckUpTableErrorUc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckUpTableErrorUc::MergeFrom(const AckUpTableErrorUc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckUpTableErrorUc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckUpTableErrorUc::CopyFrom(const AckUpTableErrorUc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckUpTableErrorUc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckUpTableErrorUc::Swap(AckUpTableErrorUc* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(money_, other->money_);
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckUpTableErrorUc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckUpTableErrorUc_descriptor_;
  metadata.reflection = AckUpTableErrorUc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckAheadDownTable::kUidFieldNumber;
const int AckAheadDownTable::kSeatidFieldNumber;
const int AckAheadDownTable::kDownTagFieldNumber;
#endif  // !_MSC_VER

AckAheadDownTable::AckAheadDownTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckAheadDownTable::InitAsDefaultInstance() {
}

AckAheadDownTable::AckAheadDownTable(const AckAheadDownTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckAheadDownTable::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  seatid_ = 0;
  down_tag_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckAheadDownTable::~AckAheadDownTable() {
  SharedDtor();
}

void AckAheadDownTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckAheadDownTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckAheadDownTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckAheadDownTable_descriptor_;
}

const AckAheadDownTable& AckAheadDownTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckAheadDownTable* AckAheadDownTable::default_instance_ = NULL;

AckAheadDownTable* AckAheadDownTable::New() const {
  return new AckAheadDownTable;
}

void AckAheadDownTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    seatid_ = 0;
    down_tag_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckAheadDownTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seatid;
        break;
      }

      // optional int32 seatid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seatid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_down_tag;
        break;
      }

      // optional int32 down_tag = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_down_tag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &down_tag_)));
          set_has_down_tag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckAheadDownTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional int32 seatid = 2;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seatid(), output);
  }

  // optional int32 down_tag = 3;
  if (has_down_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->down_tag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckAheadDownTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional int32 seatid = 2;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seatid(), target);
  }

  // optional int32 down_tag = 3;
  if (has_down_tag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->down_tag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckAheadDownTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 seatid = 2;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 down_tag = 3;
    if (has_down_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->down_tag());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckAheadDownTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckAheadDownTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckAheadDownTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckAheadDownTable::MergeFrom(const AckAheadDownTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_down_tag()) {
      set_down_tag(from.down_tag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckAheadDownTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckAheadDownTable::CopyFrom(const AckAheadDownTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckAheadDownTable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckAheadDownTable::Swap(AckAheadDownTable* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(seatid_, other->seatid_);
    std::swap(down_tag_, other->down_tag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckAheadDownTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckAheadDownTable_descriptor_;
  metadata.reflection = AckAheadDownTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckDownTableSuccess::kUidFieldNumber;
const int AckDownTableSuccess::kSeatidFieldNumber;
const int AckDownTableSuccess::kMoneyFieldNumber;
#endif  // !_MSC_VER

AckDownTableSuccess::AckDownTableSuccess()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckDownTableSuccess::InitAsDefaultInstance() {
}

AckDownTableSuccess::AckDownTableSuccess(const AckDownTableSuccess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckDownTableSuccess::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  seatid_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckDownTableSuccess::~AckDownTableSuccess() {
  SharedDtor();
}

void AckDownTableSuccess::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckDownTableSuccess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckDownTableSuccess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckDownTableSuccess_descriptor_;
}

const AckDownTableSuccess& AckDownTableSuccess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckDownTableSuccess* AckDownTableSuccess::default_instance_ = NULL;

AckDownTableSuccess* AckDownTableSuccess::New() const {
  return new AckDownTableSuccess;
}

void AckDownTableSuccess::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    seatid_ = 0;
    money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckDownTableSuccess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seatid;
        break;
      }

      // optional int32 seatid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seatid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional int32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckDownTableSuccess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // optional int32 seatid = 2;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seatid(), output);
  }

  // optional int32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->money(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckDownTableSuccess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // optional int32 seatid = 2;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seatid(), target);
  }

  // optional int32 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->money(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckDownTableSuccess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // optional int32 seatid = 2;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckDownTableSuccess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckDownTableSuccess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckDownTableSuccess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckDownTableSuccess::MergeFrom(const AckDownTableSuccess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckDownTableSuccess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckDownTableSuccess::CopyFrom(const AckDownTableSuccess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckDownTableSuccess::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckDownTableSuccess::Swap(AckDownTableSuccess* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(seatid_, other->seatid_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckDownTableSuccess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckDownTableSuccess_descriptor_;
  metadata.reflection = AckDownTableSuccess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckPrereadyBC::kRoomidFieldNumber;
#endif  // !_MSC_VER

AckPrereadyBC::AckPrereadyBC()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckPrereadyBC::InitAsDefaultInstance() {
}

AckPrereadyBC::AckPrereadyBC(const AckPrereadyBC& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckPrereadyBC::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckPrereadyBC::~AckPrereadyBC() {
  SharedDtor();
}

void AckPrereadyBC::SharedDtor() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (this != default_instance_) {
  }
}

void AckPrereadyBC::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckPrereadyBC::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckPrereadyBC_descriptor_;
}

const AckPrereadyBC& AckPrereadyBC::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckPrereadyBC* AckPrereadyBC::default_instance_ = NULL;

AckPrereadyBC* AckPrereadyBC::New() const {
  return new AckPrereadyBC;
}

void AckPrereadyBC::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_roomid()) {
      if (roomid_ != &::google::protobuf::internal::kEmptyString) {
        roomid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckPrereadyBC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes roomid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_roomid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckPrereadyBC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes roomid = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->roomid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckPrereadyBC::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes roomid = 1;
  if (has_roomid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->roomid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckPrereadyBC::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes roomid = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->roomid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckPrereadyBC::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckPrereadyBC* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckPrereadyBC*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckPrereadyBC::MergeFrom(const AckPrereadyBC& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckPrereadyBC::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckPrereadyBC::CopyFrom(const AckPrereadyBC& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckPrereadyBC::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckPrereadyBC::Swap(AckPrereadyBC* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckPrereadyBC::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckPrereadyBC_descriptor_;
  metadata.reflection = AckPrereadyBC_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckEmotionBC::kSeatidFieldNumber;
const int AckEmotionBC::kMoneyFieldNumber;
const int AckEmotionBC::kTargetSeatidFieldNumber;
const int AckEmotionBC::kTargetSeatNumFieldNumber;
const int AckEmotionBC::kTypeFieldNumber;
#endif  // !_MSC_VER

AckEmotionBC::AckEmotionBC()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckEmotionBC::InitAsDefaultInstance() {
}

AckEmotionBC::AckEmotionBC(const AckEmotionBC& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckEmotionBC::SharedCtor() {
  _cached_size_ = 0;
  seatid_ = 0;
  money_ = 0;
  target_seatid_ = 0;
  target_seat_num_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckEmotionBC::~AckEmotionBC() {
  SharedDtor();
}

void AckEmotionBC::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckEmotionBC::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckEmotionBC::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckEmotionBC_descriptor_;
}

const AckEmotionBC& AckEmotionBC::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_loginproto_2eproto();
  return *default_instance_;
}

AckEmotionBC* AckEmotionBC::default_instance_ = NULL;

AckEmotionBC* AckEmotionBC::New() const {
  return new AckEmotionBC;
}

void AckEmotionBC::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seatid_ = 0;
    money_ = 0;
    target_seatid_ = 0;
    target_seat_num_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckEmotionBC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seatid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seatid_)));
          set_has_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_money;
        break;
      }

      // optional int32 money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_seatid;
        break;
      }

      // optional int32 target_seatid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_seatid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_seatid_)));
          set_has_target_seatid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_target_seat_num;
        break;
      }

      // optional int32 target_seat_num = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_seat_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_seat_num_)));
          set_has_target_seat_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional int32 type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckEmotionBC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seatid(), output);
  }

  // optional int32 money = 2;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->money(), output);
  }

  // optional int32 target_seatid = 3;
  if (has_target_seatid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->target_seatid(), output);
  }

  // optional int32 target_seat_num = 4;
  if (has_target_seat_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->target_seat_num(), output);
  }

  // optional int32 type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckEmotionBC::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 seatid = 1;
  if (has_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seatid(), target);
  }

  // optional int32 money = 2;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->money(), target);
  }

  // optional int32 target_seatid = 3;
  if (has_target_seatid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->target_seatid(), target);
  }

  // optional int32 target_seat_num = 4;
  if (has_target_seat_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->target_seat_num(), target);
  }

  // optional int32 type = 5;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckEmotionBC::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seatid = 1;
    if (has_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seatid());
    }

    // optional int32 money = 2;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 target_seatid = 3;
    if (has_target_seatid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_seatid());
    }

    // optional int32 target_seat_num = 4;
    if (has_target_seat_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_seat_num());
    }

    // optional int32 type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckEmotionBC::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckEmotionBC* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckEmotionBC*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckEmotionBC::MergeFrom(const AckEmotionBC& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seatid()) {
      set_seatid(from.seatid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_target_seatid()) {
      set_target_seatid(from.target_seatid());
    }
    if (from.has_target_seat_num()) {
      set_target_seat_num(from.target_seat_num());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckEmotionBC::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckEmotionBC::CopyFrom(const AckEmotionBC& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckEmotionBC::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckEmotionBC::Swap(AckEmotionBC* other) {
  if (other != this) {
    std::swap(seatid_, other->seatid_);
    std::swap(money_, other->money_);
    std::swap(target_seatid_, other->target_seatid_);
    std::swap(target_seat_num_, other->target_seat_num_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckEmotionBC::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckEmotionBC_descriptor_;
  metadata.reflection = AckEmotionBC_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace game
}  // namespace proto

// @@protoc_insertion_point(global_scope)
