// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loginproto.proto

#ifndef PROTOBUF_loginproto_2eproto__INCLUDED
#define PROTOBUF_loginproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {
namespace game {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_loginproto_2eproto();
void protobuf_AssignDesc_loginproto_2eproto();
void protobuf_ShutdownFile_loginproto_2eproto();

class ReqLogin;
class ReqLogout;
class ReqEmotion;
class AckLoginSuccessUc;
class AckLoginSuccessBc;
class AckLoginError;
class AckLogoutBc;
class AckUpTableSuccess;
class AckUpTableErrorUc;
class AckAheadDownTable;
class AckDownTableSuccess;
class AckPrereadyBC;
class AckEmotionBC;

enum ErrCode {
  DIS_ROOM_MORETHAN_TWICE_ERR = 101,
  USER_ALREADY_IN_SEAT_ERR = 102,
  USER_NO_MONEY_UPTABLE_ERR = 104,
  NO_UPTABLE_SEAT_ERR = 105,
  USER_NO_MONEY_LOGIN_ERR = 508,
  ROOM_STATUS_ERR = 608
};
bool ErrCode_IsValid(int value);
const ErrCode ErrCode_MIN = DIS_ROOM_MORETHAN_TWICE_ERR;
const ErrCode ErrCode_MAX = ROOM_STATUS_ERR;
const int ErrCode_ARRAYSIZE = ErrCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrCode_descriptor();
inline const ::std::string& ErrCode_Name(ErrCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrCode_descriptor(), value);
}
inline bool ErrCode_Parse(
    const ::std::string& name, ErrCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrCode>(
    ErrCode_descriptor(), name, value);
}
// ===================================================================

class ReqLogin : public ::google::protobuf::Message {
 public:
  ReqLogin();
  virtual ~ReqLogin();

  ReqLogin(const ReqLogin& from);

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();

  void Swap(ReqLogin* other);

  // implements Message ----------------------------------------------

  ReqLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional bytes skey = 2;
  inline bool has_skey() const;
  inline void clear_skey();
  static const int kSkeyFieldNumber = 2;
  inline const ::std::string& skey() const;
  inline void set_skey(const ::std::string& value);
  inline void set_skey(const char* value);
  inline void set_skey(const void* value, size_t size);
  inline ::std::string* mutable_skey();
  inline ::std::string* release_skey();
  inline void set_allocated_skey(::std::string* skey);

  // optional bytes roomid = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 3;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const void* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional int32 req_count = 4;
  inline bool has_req_count() const;
  inline void clear_req_count();
  static const int kReqCountFieldNumber = 4;
  inline ::google::protobuf::int32 req_count() const;
  inline void set_req_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqLogin)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_skey();
  inline void clear_has_skey();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_req_count();
  inline void clear_has_req_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* skey_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 req_count_;
  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqLogin* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogout : public ::google::protobuf::Message {
 public:
  ReqLogout();
  virtual ~ReqLogout();

  ReqLogout(const ReqLogout& from);

  inline ReqLogout& operator=(const ReqLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogout& default_instance();

  void Swap(ReqLogout* other);

  // implements Message ----------------------------------------------

  ReqLogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogout& from);
  void MergeFrom(const ReqLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqLogout)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqLogout* default_instance_;
};
// -------------------------------------------------------------------

class ReqEmotion : public ::google::protobuf::Message {
 public:
  ReqEmotion();
  virtual ~ReqEmotion();

  ReqEmotion(const ReqEmotion& from);

  inline ReqEmotion& operator=(const ReqEmotion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEmotion& default_instance();

  void Swap(ReqEmotion* other);

  // implements Message ----------------------------------------------

  ReqEmotion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEmotion& from);
  void MergeFrom(const ReqEmotion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 target_seatid = 2;
  inline bool has_target_seatid() const;
  inline void clear_target_seatid();
  static const int kTargetSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 target_seatid() const;
  inline void set_target_seatid(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.ReqEmotion)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_target_seatid();
  inline void clear_has_target_seatid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 target_seatid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqEmotion* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginSuccessUc : public ::google::protobuf::Message {
 public:
  AckLoginSuccessUc();
  virtual ~AckLoginSuccessUc();

  AckLoginSuccessUc(const AckLoginSuccessUc& from);

  inline AckLoginSuccessUc& operator=(const AckLoginSuccessUc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginSuccessUc& default_instance();

  void Swap(AckLoginSuccessUc* other);

  // implements Message ----------------------------------------------

  AckLoginSuccessUc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginSuccessUc& from);
  void MergeFrom(const AckLoginSuccessUc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional bytes avatar = 2;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 2;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional bytes name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 ready = 6;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 6;
  inline ::google::protobuf::int32 ready() const;
  inline void set_ready(::google::protobuf::int32 value);

  // optional int32 rmb = 7;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 7;
  inline ::google::protobuf::int32 rmb() const;
  inline void set_rmb(::google::protobuf::int32 value);

  // optional int32 see = 8;
  inline bool has_see() const;
  inline void clear_see();
  static const int kSeeFieldNumber = 8;
  inline ::google::protobuf::int32 see() const;
  inline void set_see(::google::protobuf::int32 value);

  // optional int32 sex = 9;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 9;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 uid = 10;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 10;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckLoginSuccessUc)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_see();
  inline void clear_has_see();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* avatar_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 exp_;
  ::std::string* name_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 ready_;
  ::google::protobuf::int32 rmb_;
  ::google::protobuf::int32 see_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLoginSuccessUc* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginSuccessBc : public ::google::protobuf::Message {
 public:
  AckLoginSuccessBc();
  virtual ~AckLoginSuccessBc();

  AckLoginSuccessBc(const AckLoginSuccessBc& from);

  inline AckLoginSuccessBc& operator=(const AckLoginSuccessBc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginSuccessBc& default_instance();

  void Swap(AckLoginSuccessBc* other);

  // implements Message ----------------------------------------------

  AckLoginSuccessBc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginSuccessBc& from);
  void MergeFrom(const AckLoginSuccessBc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional bytes name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes avatar = 5;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 5;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional int32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckLoginSuccessBc)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 uid_;
  ::std::string* name_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 sex_;
  ::std::string* avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLoginSuccessBc* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginError : public ::google::protobuf::Message {
 public:
  AckLoginError();
  virtual ~AckLoginError();

  AckLoginError(const AckLoginError& from);

  inline AckLoginError& operator=(const AckLoginError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginError& default_instance();

  void Swap(AckLoginError* other);

  // implements Message ----------------------------------------------

  AckLoginError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginError& from);
  void MergeFrom(const AckLoginError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckLoginError)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLoginError* default_instance_;
};
// -------------------------------------------------------------------

class AckLogoutBc : public ::google::protobuf::Message {
 public:
  AckLogoutBc();
  virtual ~AckLogoutBc();

  AckLogoutBc(const AckLogoutBc& from);

  inline AckLogoutBc& operator=(const AckLogoutBc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLogoutBc& default_instance();

  void Swap(AckLogoutBc* other);

  // implements Message ----------------------------------------------

  AckLogoutBc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLogoutBc& from);
  void MergeFrom(const AckLogoutBc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckLogoutBc)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLogoutBc* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableSuccess : public ::google::protobuf::Message {
 public:
  AckUpTableSuccess();
  virtual ~AckUpTableSuccess();

  AckUpTableSuccess(const AckUpTableSuccess& from);

  inline AckUpTableSuccess& operator=(const AckUpTableSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableSuccess& default_instance();

  void Swap(AckUpTableSuccess* other);

  // implements Message ----------------------------------------------

  AckUpTableSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableSuccess& from);
  void MergeFrom(const AckUpTableSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 ready = 3;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 3;
  inline ::google::protobuf::int32 ready() const;
  inline void set_ready(::google::protobuf::int32 value);

  // optional bytes name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional bytes avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional int32 money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 exp = 8;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 8;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckUpTableSuccess)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::std::string* name_;
  ::google::protobuf::int32 ready_;
  ::google::protobuf::int32 sex_;
  ::std::string* avatar_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableSuccess* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableErrorUc : public ::google::protobuf::Message {
 public:
  AckUpTableErrorUc();
  virtual ~AckUpTableErrorUc();

  AckUpTableErrorUc(const AckUpTableErrorUc& from);

  inline AckUpTableErrorUc& operator=(const AckUpTableErrorUc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableErrorUc& default_instance();

  void Swap(AckUpTableErrorUc* other);

  // implements Message ----------------------------------------------

  AckUpTableErrorUc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableErrorUc& from);
  void MergeFrom(const AckUpTableErrorUc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckUpTableErrorUc)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableErrorUc* default_instance_;
};
// -------------------------------------------------------------------

class AckAheadDownTable : public ::google::protobuf::Message {
 public:
  AckAheadDownTable();
  virtual ~AckAheadDownTable();

  AckAheadDownTable(const AckAheadDownTable& from);

  inline AckAheadDownTable& operator=(const AckAheadDownTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckAheadDownTable& default_instance();

  void Swap(AckAheadDownTable* other);

  // implements Message ----------------------------------------------

  AckAheadDownTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckAheadDownTable& from);
  void MergeFrom(const AckAheadDownTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 down_tag = 3;
  inline bool has_down_tag() const;
  inline void clear_down_tag();
  static const int kDownTagFieldNumber = 3;
  inline ::google::protobuf::int32 down_tag() const;
  inline void set_down_tag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckAheadDownTable)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_down_tag();
  inline void clear_has_down_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 down_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckAheadDownTable* default_instance_;
};
// -------------------------------------------------------------------

class AckDownTableSuccess : public ::google::protobuf::Message {
 public:
  AckDownTableSuccess();
  virtual ~AckDownTableSuccess();

  AckDownTableSuccess(const AckDownTableSuccess& from);

  inline AckDownTableSuccess& operator=(const AckDownTableSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckDownTableSuccess& default_instance();

  void Swap(AckDownTableSuccess* other);

  // implements Message ----------------------------------------------

  AckDownTableSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckDownTableSuccess& from);
  void MergeFrom(const AckDownTableSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckDownTableSuccess)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckDownTableSuccess* default_instance_;
};
// -------------------------------------------------------------------

class AckPrereadyBC : public ::google::protobuf::Message {
 public:
  AckPrereadyBC();
  virtual ~AckPrereadyBC();

  AckPrereadyBC(const AckPrereadyBC& from);

  inline AckPrereadyBC& operator=(const AckPrereadyBC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPrereadyBC& default_instance();

  void Swap(AckPrereadyBC* other);

  // implements Message ----------------------------------------------

  AckPrereadyBC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPrereadyBC& from);
  void MergeFrom(const AckPrereadyBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes roomid = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const void* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:proto.game.AckPrereadyBC)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckPrereadyBC* default_instance_;
};
// -------------------------------------------------------------------

class AckEmotionBC : public ::google::protobuf::Message {
 public:
  AckEmotionBC();
  virtual ~AckEmotionBC();

  AckEmotionBC(const AckEmotionBC& from);

  inline AckEmotionBC& operator=(const AckEmotionBC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckEmotionBC& default_instance();

  void Swap(AckEmotionBC* other);

  // implements Message ----------------------------------------------

  AckEmotionBC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckEmotionBC& from);
  void MergeFrom(const AckEmotionBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 target_seatid = 3;
  inline bool has_target_seatid() const;
  inline void clear_target_seatid();
  static const int kTargetSeatidFieldNumber = 3;
  inline ::google::protobuf::int32 target_seatid() const;
  inline void set_target_seatid(::google::protobuf::int32 value);

  // optional int32 target_seat_num = 4;
  inline bool has_target_seat_num() const;
  inline void clear_target_seat_num();
  static const int kTargetSeatNumFieldNumber = 4;
  inline ::google::protobuf::int32 target_seat_num() const;
  inline void set_target_seat_num(::google::protobuf::int32 value);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.game.AckEmotionBC)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_target_seatid();
  inline void clear_has_target_seatid();
  inline void set_has_target_seat_num();
  inline void clear_has_target_seat_num();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 target_seatid_;
  ::google::protobuf::int32 target_seat_num_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckEmotionBC* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqLogin

// required int32 uid = 1;
inline bool ReqLogin::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogin::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogin::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogin::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ReqLogin::uid() const {
  return uid_;
}
inline void ReqLogin::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional bytes skey = 2;
inline bool ReqLogin::has_skey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogin::set_has_skey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogin::clear_has_skey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogin::clear_skey() {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    skey_->clear();
  }
  clear_has_skey();
}
inline const ::std::string& ReqLogin::skey() const {
  return *skey_;
}
inline void ReqLogin::set_skey(const ::std::string& value) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(value);
}
inline void ReqLogin::set_skey(const char* value) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(value);
}
inline void ReqLogin::set_skey(const void* value, size_t size) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_skey() {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  return skey_;
}
inline ::std::string* ReqLogin::release_skey() {
  clear_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skey_;
    skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_skey(::std::string* skey) {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    delete skey_;
  }
  if (skey) {
    set_has_skey();
    skey_ = skey;
  } else {
    clear_has_skey();
    skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes roomid = 3;
inline bool ReqLogin::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLogin::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLogin::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLogin::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ReqLogin::roomid() const {
  return *roomid_;
}
inline void ReqLogin::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqLogin::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqLogin::set_roomid(const void* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ReqLogin::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 req_count = 4;
inline bool ReqLogin::has_req_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLogin::set_has_req_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLogin::clear_has_req_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLogin::clear_req_count() {
  req_count_ = 0;
  clear_has_req_count();
}
inline ::google::protobuf::int32 ReqLogin::req_count() const {
  return req_count_;
}
inline void ReqLogin::set_req_count(::google::protobuf::int32 value) {
  set_has_req_count();
  req_count_ = value;
}

// -------------------------------------------------------------------

// ReqLogout

// required int32 uid = 1;
inline bool ReqLogout::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogout::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogout::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogout::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ReqLogout::uid() const {
  return uid_;
}
inline void ReqLogout::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// ReqEmotion

// required int32 seatid = 1;
inline bool ReqEmotion::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEmotion::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEmotion::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEmotion::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 ReqEmotion::seatid() const {
  return seatid_;
}
inline void ReqEmotion::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 target_seatid = 2;
inline bool ReqEmotion::has_target_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqEmotion::set_has_target_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqEmotion::clear_has_target_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqEmotion::clear_target_seatid() {
  target_seatid_ = 0;
  clear_has_target_seatid();
}
inline ::google::protobuf::int32 ReqEmotion::target_seatid() const {
  return target_seatid_;
}
inline void ReqEmotion::set_target_seatid(::google::protobuf::int32 value) {
  set_has_target_seatid();
  target_seatid_ = value;
}

// optional int32 type = 3;
inline bool ReqEmotion::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqEmotion::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqEmotion::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqEmotion::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ReqEmotion::type() const {
  return type_;
}
inline void ReqEmotion::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckLoginSuccessUc

// required int32 seatid = 1;
inline bool AckLoginSuccessUc::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginSuccessUc::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginSuccessUc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginSuccessUc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::seatid() const {
  return seatid_;
}
inline void AckLoginSuccessUc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional bytes avatar = 2;
inline bool AckLoginSuccessUc::has_avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginSuccessUc::set_has_avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginSuccessUc::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginSuccessUc::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& AckLoginSuccessUc::avatar() const {
  return *avatar_;
}
inline void AckLoginSuccessUc::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessUc::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessUc::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessUc::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* AckLoginSuccessUc::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessUc::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exp = 3;
inline bool AckLoginSuccessUc::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLoginSuccessUc::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLoginSuccessUc::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLoginSuccessUc::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::exp() const {
  return exp_;
}
inline void AckLoginSuccessUc::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 money = 4;
inline bool AckLoginSuccessUc::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckLoginSuccessUc::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckLoginSuccessUc::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckLoginSuccessUc::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::money() const {
  return money_;
}
inline void AckLoginSuccessUc::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional bytes name = 5;
inline bool AckLoginSuccessUc::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckLoginSuccessUc::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckLoginSuccessUc::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckLoginSuccessUc::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckLoginSuccessUc::name() const {
  return *name_;
}
inline void AckLoginSuccessUc::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessUc::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessUc::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessUc::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckLoginSuccessUc::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessUc::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ready = 6;
inline bool AckLoginSuccessUc::has_ready() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckLoginSuccessUc::set_has_ready() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckLoginSuccessUc::clear_has_ready() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckLoginSuccessUc::clear_ready() {
  ready_ = 0;
  clear_has_ready();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::ready() const {
  return ready_;
}
inline void AckLoginSuccessUc::set_ready(::google::protobuf::int32 value) {
  set_has_ready();
  ready_ = value;
}

// optional int32 rmb = 7;
inline bool AckLoginSuccessUc::has_rmb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckLoginSuccessUc::set_has_rmb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckLoginSuccessUc::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckLoginSuccessUc::clear_rmb() {
  rmb_ = 0;
  clear_has_rmb();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::rmb() const {
  return rmb_;
}
inline void AckLoginSuccessUc::set_rmb(::google::protobuf::int32 value) {
  set_has_rmb();
  rmb_ = value;
}

// optional int32 see = 8;
inline bool AckLoginSuccessUc::has_see() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckLoginSuccessUc::set_has_see() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckLoginSuccessUc::clear_has_see() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckLoginSuccessUc::clear_see() {
  see_ = 0;
  clear_has_see();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::see() const {
  return see_;
}
inline void AckLoginSuccessUc::set_see(::google::protobuf::int32 value) {
  set_has_see();
  see_ = value;
}

// optional int32 sex = 9;
inline bool AckLoginSuccessUc::has_sex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckLoginSuccessUc::set_has_sex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckLoginSuccessUc::clear_has_sex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckLoginSuccessUc::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::sex() const {
  return sex_;
}
inline void AckLoginSuccessUc::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 uid = 10;
inline bool AckLoginSuccessUc::has_uid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckLoginSuccessUc::set_has_uid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckLoginSuccessUc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckLoginSuccessUc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::uid() const {
  return uid_;
}
inline void AckLoginSuccessUc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// AckLoginSuccessBc

// required int32 seatid = 1;
inline bool AckLoginSuccessBc::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginSuccessBc::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginSuccessBc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginSuccessBc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::seatid() const {
  return seatid_;
}
inline void AckLoginSuccessBc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 uid = 2;
inline bool AckLoginSuccessBc::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginSuccessBc::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginSuccessBc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginSuccessBc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::uid() const {
  return uid_;
}
inline void AckLoginSuccessBc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 money = 3;
inline bool AckLoginSuccessBc::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLoginSuccessBc::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLoginSuccessBc::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLoginSuccessBc::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::money() const {
  return money_;
}
inline void AckLoginSuccessBc::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional bytes name = 4;
inline bool AckLoginSuccessBc::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckLoginSuccessBc::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckLoginSuccessBc::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckLoginSuccessBc::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckLoginSuccessBc::name() const {
  return *name_;
}
inline void AckLoginSuccessBc::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessBc::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessBc::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessBc::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckLoginSuccessBc::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessBc::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes avatar = 5;
inline bool AckLoginSuccessBc::has_avatar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckLoginSuccessBc::set_has_avatar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckLoginSuccessBc::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckLoginSuccessBc::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& AckLoginSuccessBc::avatar() const {
  return *avatar_;
}
inline void AckLoginSuccessBc::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessBc::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessBc::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessBc::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* AckLoginSuccessBc::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessBc::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 6;
inline bool AckLoginSuccessBc::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckLoginSuccessBc::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckLoginSuccessBc::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckLoginSuccessBc::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::sex() const {
  return sex_;
}
inline void AckLoginSuccessBc::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// AckLoginError

// required int32 uid = 1;
inline bool AckLoginError::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginError::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginError::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginError::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLoginError::uid() const {
  return uid_;
}
inline void AckLoginError::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 code = 2;
inline bool AckLoginError::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginError::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginError::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginError::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 AckLoginError::code() const {
  return code_;
}
inline void AckLoginError::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// AckLogoutBc

// required int32 seatid = 1;
inline bool AckLogoutBc::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLogoutBc::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLogoutBc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLogoutBc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckLogoutBc::seatid() const {
  return seatid_;
}
inline void AckLogoutBc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 uid = 2;
inline bool AckLogoutBc::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLogoutBc::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLogoutBc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLogoutBc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLogoutBc::uid() const {
  return uid_;
}
inline void AckLogoutBc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 type = 3;
inline bool AckLogoutBc::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLogoutBc::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLogoutBc::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLogoutBc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AckLogoutBc::type() const {
  return type_;
}
inline void AckLogoutBc::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckUpTableSuccess

// required int32 uid = 1;
inline bool AckUpTableSuccess::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpTableSuccess::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpTableSuccess::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpTableSuccess::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckUpTableSuccess::uid() const {
  return uid_;
}
inline void AckUpTableSuccess::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool AckUpTableSuccess::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpTableSuccess::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpTableSuccess::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpTableSuccess::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckUpTableSuccess::seatid() const {
  return seatid_;
}
inline void AckUpTableSuccess::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 ready = 3;
inline bool AckUpTableSuccess::has_ready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUpTableSuccess::set_has_ready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUpTableSuccess::clear_has_ready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUpTableSuccess::clear_ready() {
  ready_ = 0;
  clear_has_ready();
}
inline ::google::protobuf::int32 AckUpTableSuccess::ready() const {
  return ready_;
}
inline void AckUpTableSuccess::set_ready(::google::protobuf::int32 value) {
  set_has_ready();
  ready_ = value;
}

// optional bytes name = 4;
inline bool AckUpTableSuccess::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckUpTableSuccess::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckUpTableSuccess::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckUpTableSuccess::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckUpTableSuccess::name() const {
  return *name_;
}
inline void AckUpTableSuccess::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckUpTableSuccess::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckUpTableSuccess::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUpTableSuccess::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckUpTableSuccess::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUpTableSuccess::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 5;
inline bool AckUpTableSuccess::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckUpTableSuccess::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckUpTableSuccess::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckUpTableSuccess::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckUpTableSuccess::sex() const {
  return sex_;
}
inline void AckUpTableSuccess::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional bytes avatar = 6;
inline bool AckUpTableSuccess::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckUpTableSuccess::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckUpTableSuccess::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckUpTableSuccess::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& AckUpTableSuccess::avatar() const {
  return *avatar_;
}
inline void AckUpTableSuccess::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckUpTableSuccess::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckUpTableSuccess::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUpTableSuccess::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* AckUpTableSuccess::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUpTableSuccess::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 money = 7;
inline bool AckUpTableSuccess::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckUpTableSuccess::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckUpTableSuccess::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckUpTableSuccess::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckUpTableSuccess::money() const {
  return money_;
}
inline void AckUpTableSuccess::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 exp = 8;
inline bool AckUpTableSuccess::has_exp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckUpTableSuccess::set_has_exp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckUpTableSuccess::clear_has_exp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckUpTableSuccess::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 AckUpTableSuccess::exp() const {
  return exp_;
}
inline void AckUpTableSuccess::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// AckUpTableErrorUc

// required int32 uid = 1;
inline bool AckUpTableErrorUc::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpTableErrorUc::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpTableErrorUc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpTableErrorUc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckUpTableErrorUc::uid() const {
  return uid_;
}
inline void AckUpTableErrorUc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 money = 2;
inline bool AckUpTableErrorUc::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpTableErrorUc::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpTableErrorUc::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpTableErrorUc::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckUpTableErrorUc::money() const {
  return money_;
}
inline void AckUpTableErrorUc::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 code = 3;
inline bool AckUpTableErrorUc::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUpTableErrorUc::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUpTableErrorUc::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUpTableErrorUc::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 AckUpTableErrorUc::code() const {
  return code_;
}
inline void AckUpTableErrorUc::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// AckAheadDownTable

// required int32 uid = 1;
inline bool AckAheadDownTable::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckAheadDownTable::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckAheadDownTable::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckAheadDownTable::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckAheadDownTable::uid() const {
  return uid_;
}
inline void AckAheadDownTable::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool AckAheadDownTable::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckAheadDownTable::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckAheadDownTable::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckAheadDownTable::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckAheadDownTable::seatid() const {
  return seatid_;
}
inline void AckAheadDownTable::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 down_tag = 3;
inline bool AckAheadDownTable::has_down_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckAheadDownTable::set_has_down_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckAheadDownTable::clear_has_down_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckAheadDownTable::clear_down_tag() {
  down_tag_ = 0;
  clear_has_down_tag();
}
inline ::google::protobuf::int32 AckAheadDownTable::down_tag() const {
  return down_tag_;
}
inline void AckAheadDownTable::set_down_tag(::google::protobuf::int32 value) {
  set_has_down_tag();
  down_tag_ = value;
}

// -------------------------------------------------------------------

// AckDownTableSuccess

// required int32 uid = 1;
inline bool AckDownTableSuccess::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckDownTableSuccess::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckDownTableSuccess::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckDownTableSuccess::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckDownTableSuccess::uid() const {
  return uid_;
}
inline void AckDownTableSuccess::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool AckDownTableSuccess::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckDownTableSuccess::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckDownTableSuccess::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckDownTableSuccess::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckDownTableSuccess::seatid() const {
  return seatid_;
}
inline void AckDownTableSuccess::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 money = 3;
inline bool AckDownTableSuccess::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckDownTableSuccess::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckDownTableSuccess::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckDownTableSuccess::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckDownTableSuccess::money() const {
  return money_;
}
inline void AckDownTableSuccess::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// AckPrereadyBC

// required bytes roomid = 1;
inline bool AckPrereadyBC::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPrereadyBC::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPrereadyBC::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPrereadyBC::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& AckPrereadyBC::roomid() const {
  return *roomid_;
}
inline void AckPrereadyBC::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void AckPrereadyBC::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void AckPrereadyBC::set_roomid(const void* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPrereadyBC::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* AckPrereadyBC::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPrereadyBC::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckEmotionBC

// required int32 seatid = 1;
inline bool AckEmotionBC::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckEmotionBC::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckEmotionBC::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckEmotionBC::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckEmotionBC::seatid() const {
  return seatid_;
}
inline void AckEmotionBC::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 money = 2;
inline bool AckEmotionBC::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckEmotionBC::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckEmotionBC::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckEmotionBC::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckEmotionBC::money() const {
  return money_;
}
inline void AckEmotionBC::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 target_seatid = 3;
inline bool AckEmotionBC::has_target_seatid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckEmotionBC::set_has_target_seatid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckEmotionBC::clear_has_target_seatid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckEmotionBC::clear_target_seatid() {
  target_seatid_ = 0;
  clear_has_target_seatid();
}
inline ::google::protobuf::int32 AckEmotionBC::target_seatid() const {
  return target_seatid_;
}
inline void AckEmotionBC::set_target_seatid(::google::protobuf::int32 value) {
  set_has_target_seatid();
  target_seatid_ = value;
}

// optional int32 target_seat_num = 4;
inline bool AckEmotionBC::has_target_seat_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckEmotionBC::set_has_target_seat_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckEmotionBC::clear_has_target_seat_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckEmotionBC::clear_target_seat_num() {
  target_seat_num_ = 0;
  clear_has_target_seat_num();
}
inline ::google::protobuf::int32 AckEmotionBC::target_seat_num() const {
  return target_seat_num_;
}
inline void AckEmotionBC::set_target_seat_num(::google::protobuf::int32 value) {
  set_has_target_seat_num();
  target_seat_num_ = value;
}

// optional int32 type = 5;
inline bool AckEmotionBC::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckEmotionBC::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckEmotionBC::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckEmotionBC::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AckEmotionBC::type() const {
  return type_;
}
inline void AckEmotionBC::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace game
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::game::ErrCode>() {
  return ::proto::game::ErrCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_loginproto_2eproto__INCLUDED
