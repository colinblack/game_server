// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CfgTreasure.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CfgTreasure.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace CfgTreasure {

namespace {

const ::google::protobuf::Descriptor* Dan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Dan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Dans_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Dans_reflection_ = NULL;
const ::google::protobuf::Descriptor* CostItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CostItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* Treasure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Treasure_reflection_ = NULL;
const ::google::protobuf::Descriptor* Treasures_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Treasures_reflection_ = NULL;
const ::google::protobuf::Descriptor* Hunt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Hunt_reflection_ = NULL;
const ::google::protobuf::Descriptor* Hunts_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Hunts_reflection_ = NULL;
const ::google::protobuf::Descriptor* HuntBase_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HuntBase_reflection_ = NULL;
const ::google::protobuf::Descriptor* HuntBases_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HuntBases_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CfgTreasure_2eproto() {
  protobuf_AddDesc_CfgTreasure_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CfgTreasure.proto");
  GOOGLE_CHECK(file != NULL);
  Dan_descriptor_ = file->message_type(0);
  static const int Dan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dan, item_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dan, num_),
  };
  Dan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Dan_descriptor_,
      Dan::default_instance_,
      Dan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Dan));
  Dans_descriptor_ = file->message_type(1);
  static const int Dans_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dans, dans_),
  };
  Dans_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Dans_descriptor_,
      Dans::default_instance_,
      Dans_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dans, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Dans, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Dans));
  CostItem_descriptor_ = file->message_type(2);
  static const int CostItem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CostItem, id_),
  };
  CostItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CostItem_descriptor_,
      CostItem::default_instance_,
      CostItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CostItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CostItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CostItem));
  Treasure_descriptor_ = file->message_type(3);
  static const int Treasure_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, attr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, bless_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, cost_items_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, cost_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, dans_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, star_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, type_),
  };
  Treasure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Treasure_descriptor_,
      Treasure::default_instance_,
      Treasure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Treasure));
  Treasures_descriptor_ = file->message_type(4);
  static const int Treasures_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasures, treasures_),
  };
  Treasures_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Treasures_descriptor_,
      Treasures::default_instance_,
      Treasures_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasures, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Treasures, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Treasures));
  Hunt_descriptor_ = file->message_type(5);
  static const int Hunt_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, career_level_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, career_level_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, item_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, must_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, xiyou_),
  };
  Hunt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Hunt_descriptor_,
      Hunt::default_instance_,
      Hunt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Hunt));
  Hunts_descriptor_ = file->message_type(6);
  static const int Hunts_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunts, hunts_),
  };
  Hunts_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Hunts_descriptor_,
      Hunts::default_instance_,
      Hunts_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunts, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hunts, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Hunts));
  HuntBase_descriptor_ = file->message_type(7);
  static const int HuntBase_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, gold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, fifty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, cost_item_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, cost_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, day_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, free_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, score_item_),
  };
  HuntBase_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HuntBase_descriptor_,
      HuntBase::default_instance_,
      HuntBase_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBase, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HuntBase));
  HuntBases_descriptor_ = file->message_type(8);
  static const int HuntBases_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBases, bases_),
  };
  HuntBases_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HuntBases_descriptor_,
      HuntBases::default_instance_,
      HuntBases_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBases, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HuntBases, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HuntBases));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CfgTreasure_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Dan_descriptor_, &Dan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Dans_descriptor_, &Dans::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CostItem_descriptor_, &CostItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Treasure_descriptor_, &Treasure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Treasures_descriptor_, &Treasures::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Hunt_descriptor_, &Hunt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Hunts_descriptor_, &Hunts::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HuntBase_descriptor_, &HuntBase::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HuntBases_descriptor_, &HuntBases::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CfgTreasure_2eproto() {
  delete Dan::default_instance_;
  delete Dan_reflection_;
  delete Dans::default_instance_;
  delete Dans_reflection_;
  delete CostItem::default_instance_;
  delete CostItem_reflection_;
  delete Treasure::default_instance_;
  delete Treasure_reflection_;
  delete Treasures::default_instance_;
  delete Treasures_reflection_;
  delete Hunt::default_instance_;
  delete Hunt_reflection_;
  delete Hunts::default_instance_;
  delete Hunts_reflection_;
  delete HuntBase::default_instance_;
  delete HuntBase_reflection_;
  delete HuntBases::default_instance_;
  delete HuntBases_reflection_;
}

void protobuf_AddDesc_CfgTreasure_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::CfgCommon::protobuf_AddDesc_CfgCommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021CfgTreasure.proto\022\013CfgTreasure\032\017CfgCom"
    "mon.proto\" \n\003Dan\022\014\n\004item\030\001 \002(\r\022\013\n\003num\030\002 "
    "\002(\r\"&\n\004Dans\022\036\n\004dans\030\001 \003(\0132\020.CfgTreasure."
    "Dan\"\026\n\010CostItem\022\n\n\002id\030\001 \003(\r\"\322\001\n\010Treasure"
    "\022\"\n\004attr\030\001 \003(\0132\024.CfgCommon.Attribute\022\r\n\005"
    "bless\030\002 \002(\r\022)\n\ncost_items\030\003 \003(\0132\025.CfgTre"
    "asure.CostItem\022\020\n\010cost_num\030\004 \002(\r\022\037\n\004dans"
    "\030\005 \002(\0132\021.CfgTreasure.Dans\022\n\n\002id\030\006 \002(\r\022\r\n"
    "\005level\030\007 \002(\r\022\014\n\004star\030\010 \002(\r\022\014\n\004type\030\t \002(\r"
    "\"5\n\tTreasures\022(\n\ttreasures\030\001 \003(\0132\025.CfgTr"
    "easure.Treasure\"\232\001\n\004Hunt\022\n\n\002id\030\001 \002(\r\022\030\n\020"
    "career_level_min\030\002 \002(\r\022\030\n\020career_level_m"
    "ax\030\003 \002(\r\022\014\n\004item\030\004 \002(\r\022\013\n\003num\030\005 \002(\r\022\014\n\004r"
    "ate\030\006 \002(\r\022\014\n\004type\030\007 \002(\r\022\014\n\004must\030\010 \002(\r\022\r\n"
    "\005xiyou\030\t \002(\r\")\n\005Hunts\022 \n\005hunts\030\001 \003(\0132\021.C"
    "fgTreasure.Hunt\"\215\001\n\010HuntBase\022\014\n\004type\030\001 \002"
    "(\r\022\014\n\004gold\030\002 \002(\r\022\r\n\005fifty\030\003 \002(\r\022\021\n\tcost_"
    "item\030\004 \002(\r\022\020\n\010cost_num\030\005 \002(\r\022\013\n\003day\030\006 \002("
    "\r\022\020\n\010free_num\030\007 \002(\r\022\022\n\nscore_item\030\010 \002(\r\""
    "1\n\tHuntBases\022$\n\005bases\030\001 \003(\0132\025.CfgTreasur"
    "e.HuntBase", 810);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CfgTreasure.proto", &protobuf_RegisterTypes);
  Dan::default_instance_ = new Dan();
  Dans::default_instance_ = new Dans();
  CostItem::default_instance_ = new CostItem();
  Treasure::default_instance_ = new Treasure();
  Treasures::default_instance_ = new Treasures();
  Hunt::default_instance_ = new Hunt();
  Hunts::default_instance_ = new Hunts();
  HuntBase::default_instance_ = new HuntBase();
  HuntBases::default_instance_ = new HuntBases();
  Dan::default_instance_->InitAsDefaultInstance();
  Dans::default_instance_->InitAsDefaultInstance();
  CostItem::default_instance_->InitAsDefaultInstance();
  Treasure::default_instance_->InitAsDefaultInstance();
  Treasures::default_instance_->InitAsDefaultInstance();
  Hunt::default_instance_->InitAsDefaultInstance();
  Hunts::default_instance_->InitAsDefaultInstance();
  HuntBase::default_instance_->InitAsDefaultInstance();
  HuntBases::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CfgTreasure_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CfgTreasure_2eproto {
  StaticDescriptorInitializer_CfgTreasure_2eproto() {
    protobuf_AddDesc_CfgTreasure_2eproto();
  }
} static_descriptor_initializer_CfgTreasure_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Dan::kItemFieldNumber;
const int Dan::kNumFieldNumber;
#endif  // !_MSC_VER

Dan::Dan()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.Dan)
}

void Dan::InitAsDefaultInstance() {
}

Dan::Dan(const Dan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.Dan)
}

void Dan::SharedCtor() {
  _cached_size_ = 0;
  item_ = 0u;
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Dan::~Dan() {
  // @@protoc_insertion_point(destructor:CfgTreasure.Dan)
  SharedDtor();
}

void Dan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Dan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Dan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Dan_descriptor_;
}

const Dan& Dan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

Dan* Dan::default_instance_ = NULL;

Dan* Dan::New() const {
  return new Dan;
}

void Dan::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Dan*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(item_, num_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Dan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.Dan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 item = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_)));
          set_has_item();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // required uint32 num = 2;
      case 2: {
        if (tag == 16) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.Dan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.Dan)
  return false;
#undef DO_
}

void Dan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.Dan)
  // required uint32 item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item(), output);
  }

  // required uint32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->num(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.Dan)
}

::google::protobuf::uint8* Dan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.Dan)
  // required uint32 item = 1;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->item(), target);
  }

  // required uint32 num = 2;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->num(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.Dan)
  return target;
}

int Dan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item());
    }

    // required uint32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Dan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Dan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Dan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Dan::MergeFrom(const Dan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      set_item(from.item());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Dan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Dan::CopyFrom(const Dan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Dan::Swap(Dan* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Dan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Dan_descriptor_;
  metadata.reflection = Dan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Dans::kDansFieldNumber;
#endif  // !_MSC_VER

Dans::Dans()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.Dans)
}

void Dans::InitAsDefaultInstance() {
}

Dans::Dans(const Dans& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.Dans)
}

void Dans::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Dans::~Dans() {
  // @@protoc_insertion_point(destructor:CfgTreasure.Dans)
  SharedDtor();
}

void Dans::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Dans::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Dans::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Dans_descriptor_;
}

const Dans& Dans::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

Dans* Dans::default_instance_ = NULL;

Dans* Dans::New() const {
  return new Dans;
}

void Dans::Clear() {
  dans_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Dans::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.Dans)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgTreasure.Dan dans = 1;
      case 1: {
        if (tag == 10) {
         parse_dans:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_dans()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_dans;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.Dans)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.Dans)
  return false;
#undef DO_
}

void Dans::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.Dans)
  // repeated .CfgTreasure.Dan dans = 1;
  for (int i = 0; i < this->dans_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dans(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.Dans)
}

::google::protobuf::uint8* Dans::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.Dans)
  // repeated .CfgTreasure.Dan dans = 1;
  for (int i = 0; i < this->dans_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dans(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.Dans)
  return target;
}

int Dans::ByteSize() const {
  int total_size = 0;

  // repeated .CfgTreasure.Dan dans = 1;
  total_size += 1 * this->dans_size();
  for (int i = 0; i < this->dans_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->dans(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Dans::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Dans* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Dans*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Dans::MergeFrom(const Dans& from) {
  GOOGLE_CHECK_NE(&from, this);
  dans_.MergeFrom(from.dans_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Dans::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Dans::CopyFrom(const Dans& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dans::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->dans())) return false;
  return true;
}

void Dans::Swap(Dans* other) {
  if (other != this) {
    dans_.Swap(&other->dans_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Dans::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Dans_descriptor_;
  metadata.reflection = Dans_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CostItem::kIdFieldNumber;
#endif  // !_MSC_VER

CostItem::CostItem()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.CostItem)
}

void CostItem::InitAsDefaultInstance() {
}

CostItem::CostItem(const CostItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.CostItem)
}

void CostItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CostItem::~CostItem() {
  // @@protoc_insertion_point(destructor:CfgTreasure.CostItem)
  SharedDtor();
}

void CostItem::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CostItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CostItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CostItem_descriptor_;
}

const CostItem& CostItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

CostItem* CostItem::default_instance_ = NULL;

CostItem* CostItem::New() const {
  return new CostItem;
}

void CostItem::Clear() {
  id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CostItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.CostItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 id = 1;
      case 1: {
        if (tag == 8) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_id())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_id;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.CostItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.CostItem)
  return false;
#undef DO_
}

void CostItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.CostItem)
  // repeated uint32 id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->id(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.CostItem)
}

::google::protobuf::uint8* CostItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.CostItem)
  // repeated uint32 id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->id(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.CostItem)
  return target;
}

int CostItem::ByteSize() const {
  int total_size = 0;

  // repeated uint32 id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->id(i));
    }
    total_size += 1 * this->id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CostItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CostItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CostItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CostItem::MergeFrom(const CostItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_.MergeFrom(from.id_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CostItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CostItem::CopyFrom(const CostItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CostItem::IsInitialized() const {

  return true;
}

void CostItem::Swap(CostItem* other) {
  if (other != this) {
    id_.Swap(&other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CostItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CostItem_descriptor_;
  metadata.reflection = CostItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Treasure::kAttrFieldNumber;
const int Treasure::kBlessFieldNumber;
const int Treasure::kCostItemsFieldNumber;
const int Treasure::kCostNumFieldNumber;
const int Treasure::kDansFieldNumber;
const int Treasure::kIdFieldNumber;
const int Treasure::kLevelFieldNumber;
const int Treasure::kStarFieldNumber;
const int Treasure::kTypeFieldNumber;
#endif  // !_MSC_VER

Treasure::Treasure()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.Treasure)
}

void Treasure::InitAsDefaultInstance() {
  dans_ = const_cast< ::CfgTreasure::Dans*>(&::CfgTreasure::Dans::default_instance());
}

Treasure::Treasure(const Treasure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.Treasure)
}

void Treasure::SharedCtor() {
  _cached_size_ = 0;
  bless_ = 0u;
  cost_num_ = 0u;
  dans_ = NULL;
  id_ = 0u;
  level_ = 0u;
  star_ = 0u;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Treasure::~Treasure() {
  // @@protoc_insertion_point(destructor:CfgTreasure.Treasure)
  SharedDtor();
}

void Treasure::SharedDtor() {
  if (this != default_instance_) {
    delete dans_;
  }
}

void Treasure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Treasure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Treasure_descriptor_;
}

const Treasure& Treasure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

Treasure* Treasure::default_instance_ = NULL;

Treasure* Treasure::New() const {
  return new Treasure;
}

void Treasure::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Treasure*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 250) {
    ZR_(bless_, cost_num_);
    ZR_(id_, star_);
    if (has_dans()) {
      if (dans_ != NULL) dans_->::CfgTreasure::Dans::Clear();
    }
  }
  type_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  attr_.Clear();
  cost_items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Treasure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.Treasure)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgCommon.Attribute attr = 1;
      case 1: {
        if (tag == 10) {
         parse_attr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_attr;
        if (input->ExpectTag(16)) goto parse_bless;
        break;
      }

      // required uint32 bless = 2;
      case 2: {
        if (tag == 16) {
         parse_bless:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bless_)));
          set_has_bless();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_cost_items;
        break;
      }

      // repeated .CfgTreasure.CostItem cost_items = 3;
      case 3: {
        if (tag == 26) {
         parse_cost_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cost_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_cost_items;
        if (input->ExpectTag(32)) goto parse_cost_num;
        break;
      }

      // required uint32 cost_num = 4;
      case 4: {
        if (tag == 32) {
         parse_cost_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_num_)));
          set_has_cost_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_dans;
        break;
      }

      // required .CfgTreasure.Dans dans = 5;
      case 5: {
        if (tag == 42) {
         parse_dans:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dans()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_id;
        break;
      }

      // required uint32 id = 6;
      case 6: {
        if (tag == 48) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_level;
        break;
      }

      // required uint32 level = 7;
      case 7: {
        if (tag == 56) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_star;
        break;
      }

      // required uint32 star = 8;
      case 8: {
        if (tag == 64) {
         parse_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &star_)));
          set_has_star();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_type;
        break;
      }

      // required uint32 type = 9;
      case 9: {
        if (tag == 72) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.Treasure)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.Treasure)
  return false;
#undef DO_
}

void Treasure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.Treasure)
  // repeated .CfgCommon.Attribute attr = 1;
  for (int i = 0; i < this->attr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->attr(i), output);
  }

  // required uint32 bless = 2;
  if (has_bless()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bless(), output);
  }

  // repeated .CfgTreasure.CostItem cost_items = 3;
  for (int i = 0; i < this->cost_items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->cost_items(i), output);
  }

  // required uint32 cost_num = 4;
  if (has_cost_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cost_num(), output);
  }

  // required .CfgTreasure.Dans dans = 5;
  if (has_dans()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->dans(), output);
  }

  // required uint32 id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->id(), output);
  }

  // required uint32 level = 7;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->level(), output);
  }

  // required uint32 star = 8;
  if (has_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->star(), output);
  }

  // required uint32 type = 9;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.Treasure)
}

::google::protobuf::uint8* Treasure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.Treasure)
  // repeated .CfgCommon.Attribute attr = 1;
  for (int i = 0; i < this->attr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->attr(i), target);
  }

  // required uint32 bless = 2;
  if (has_bless()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bless(), target);
  }

  // repeated .CfgTreasure.CostItem cost_items = 3;
  for (int i = 0; i < this->cost_items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->cost_items(i), target);
  }

  // required uint32 cost_num = 4;
  if (has_cost_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->cost_num(), target);
  }

  // required .CfgTreasure.Dans dans = 5;
  if (has_dans()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->dans(), target);
  }

  // required uint32 id = 6;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->id(), target);
  }

  // required uint32 level = 7;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->level(), target);
  }

  // required uint32 star = 8;
  if (has_star()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->star(), target);
  }

  // required uint32 type = 9;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.Treasure)
  return target;
}

int Treasure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 bless = 2;
    if (has_bless()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bless());
    }

    // required uint32 cost_num = 4;
    if (has_cost_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost_num());
    }

    // required .CfgTreasure.Dans dans = 5;
    if (has_dans()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dans());
    }

    // required uint32 id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 level = 7;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // required uint32 star = 8;
    if (has_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->star());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 type = 9;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  // repeated .CfgCommon.Attribute attr = 1;
  total_size += 1 * this->attr_size();
  for (int i = 0; i < this->attr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attr(i));
  }

  // repeated .CfgTreasure.CostItem cost_items = 3;
  total_size += 1 * this->cost_items_size();
  for (int i = 0; i < this->cost_items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cost_items(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Treasure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Treasure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Treasure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Treasure::MergeFrom(const Treasure& from) {
  GOOGLE_CHECK_NE(&from, this);
  attr_.MergeFrom(from.attr_);
  cost_items_.MergeFrom(from.cost_items_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_bless()) {
      set_bless(from.bless());
    }
    if (from.has_cost_num()) {
      set_cost_num(from.cost_num());
    }
    if (from.has_dans()) {
      mutable_dans()->::CfgTreasure::Dans::MergeFrom(from.dans());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_star()) {
      set_star(from.star());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Treasure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Treasure::CopyFrom(const Treasure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Treasure::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001fa) != 0x000001fa) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->attr())) return false;
  if (has_dans()) {
    if (!this->dans().IsInitialized()) return false;
  }
  return true;
}

void Treasure::Swap(Treasure* other) {
  if (other != this) {
    attr_.Swap(&other->attr_);
    std::swap(bless_, other->bless_);
    cost_items_.Swap(&other->cost_items_);
    std::swap(cost_num_, other->cost_num_);
    std::swap(dans_, other->dans_);
    std::swap(id_, other->id_);
    std::swap(level_, other->level_);
    std::swap(star_, other->star_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Treasure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Treasure_descriptor_;
  metadata.reflection = Treasure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Treasures::kTreasuresFieldNumber;
#endif  // !_MSC_VER

Treasures::Treasures()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.Treasures)
}

void Treasures::InitAsDefaultInstance() {
}

Treasures::Treasures(const Treasures& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.Treasures)
}

void Treasures::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Treasures::~Treasures() {
  // @@protoc_insertion_point(destructor:CfgTreasure.Treasures)
  SharedDtor();
}

void Treasures::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Treasures::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Treasures::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Treasures_descriptor_;
}

const Treasures& Treasures::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

Treasures* Treasures::default_instance_ = NULL;

Treasures* Treasures::New() const {
  return new Treasures;
}

void Treasures::Clear() {
  treasures_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Treasures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.Treasures)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgTreasure.Treasure treasures = 1;
      case 1: {
        if (tag == 10) {
         parse_treasures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_treasures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_treasures;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.Treasures)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.Treasures)
  return false;
#undef DO_
}

void Treasures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.Treasures)
  // repeated .CfgTreasure.Treasure treasures = 1;
  for (int i = 0; i < this->treasures_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->treasures(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.Treasures)
}

::google::protobuf::uint8* Treasures::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.Treasures)
  // repeated .CfgTreasure.Treasure treasures = 1;
  for (int i = 0; i < this->treasures_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->treasures(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.Treasures)
  return target;
}

int Treasures::ByteSize() const {
  int total_size = 0;

  // repeated .CfgTreasure.Treasure treasures = 1;
  total_size += 1 * this->treasures_size();
  for (int i = 0; i < this->treasures_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->treasures(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Treasures::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Treasures* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Treasures*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Treasures::MergeFrom(const Treasures& from) {
  GOOGLE_CHECK_NE(&from, this);
  treasures_.MergeFrom(from.treasures_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Treasures::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Treasures::CopyFrom(const Treasures& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Treasures::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->treasures())) return false;
  return true;
}

void Treasures::Swap(Treasures* other) {
  if (other != this) {
    treasures_.Swap(&other->treasures_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Treasures::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Treasures_descriptor_;
  metadata.reflection = Treasures_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Hunt::kIdFieldNumber;
const int Hunt::kCareerLevelMinFieldNumber;
const int Hunt::kCareerLevelMaxFieldNumber;
const int Hunt::kItemFieldNumber;
const int Hunt::kNumFieldNumber;
const int Hunt::kRateFieldNumber;
const int Hunt::kTypeFieldNumber;
const int Hunt::kMustFieldNumber;
const int Hunt::kXiyouFieldNumber;
#endif  // !_MSC_VER

Hunt::Hunt()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.Hunt)
}

void Hunt::InitAsDefaultInstance() {
}

Hunt::Hunt(const Hunt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.Hunt)
}

void Hunt::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  career_level_min_ = 0u;
  career_level_max_ = 0u;
  item_ = 0u;
  num_ = 0u;
  rate_ = 0u;
  type_ = 0u;
  must_ = 0u;
  xiyou_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Hunt::~Hunt() {
  // @@protoc_insertion_point(destructor:CfgTreasure.Hunt)
  SharedDtor();
}

void Hunt::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Hunt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Hunt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Hunt_descriptor_;
}

const Hunt& Hunt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

Hunt* Hunt::default_instance_ = NULL;

Hunt* Hunt::New() const {
  return new Hunt;
}

void Hunt::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Hunt*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, must_);
  }
  xiyou_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Hunt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.Hunt)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_career_level_min;
        break;
      }

      // required uint32 career_level_min = 2;
      case 2: {
        if (tag == 16) {
         parse_career_level_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &career_level_min_)));
          set_has_career_level_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_career_level_max;
        break;
      }

      // required uint32 career_level_max = 3;
      case 3: {
        if (tag == 24) {
         parse_career_level_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &career_level_max_)));
          set_has_career_level_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_item;
        break;
      }

      // required uint32 item = 4;
      case 4: {
        if (tag == 32) {
         parse_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_)));
          set_has_item();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_num;
        break;
      }

      // required uint32 num = 5;
      case 5: {
        if (tag == 40) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_rate;
        break;
      }

      // required uint32 rate = 6;
      case 6: {
        if (tag == 48) {
         parse_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rate_)));
          set_has_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_type;
        break;
      }

      // required uint32 type = 7;
      case 7: {
        if (tag == 56) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_must;
        break;
      }

      // required uint32 must = 8;
      case 8: {
        if (tag == 64) {
         parse_must:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &must_)));
          set_has_must();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_xiyou;
        break;
      }

      // required uint32 xiyou = 9;
      case 9: {
        if (tag == 72) {
         parse_xiyou:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &xiyou_)));
          set_has_xiyou();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.Hunt)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.Hunt)
  return false;
#undef DO_
}

void Hunt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.Hunt)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 career_level_min = 2;
  if (has_career_level_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->career_level_min(), output);
  }

  // required uint32 career_level_max = 3;
  if (has_career_level_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->career_level_max(), output);
  }

  // required uint32 item = 4;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->item(), output);
  }

  // required uint32 num = 5;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->num(), output);
  }

  // required uint32 rate = 6;
  if (has_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->rate(), output);
  }

  // required uint32 type = 7;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->type(), output);
  }

  // required uint32 must = 8;
  if (has_must()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->must(), output);
  }

  // required uint32 xiyou = 9;
  if (has_xiyou()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->xiyou(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.Hunt)
}

::google::protobuf::uint8* Hunt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.Hunt)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 career_level_min = 2;
  if (has_career_level_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->career_level_min(), target);
  }

  // required uint32 career_level_max = 3;
  if (has_career_level_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->career_level_max(), target);
  }

  // required uint32 item = 4;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->item(), target);
  }

  // required uint32 num = 5;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->num(), target);
  }

  // required uint32 rate = 6;
  if (has_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->rate(), target);
  }

  // required uint32 type = 7;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->type(), target);
  }

  // required uint32 must = 8;
  if (has_must()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->must(), target);
  }

  // required uint32 xiyou = 9;
  if (has_xiyou()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->xiyou(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.Hunt)
  return target;
}

int Hunt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 career_level_min = 2;
    if (has_career_level_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->career_level_min());
    }

    // required uint32 career_level_max = 3;
    if (has_career_level_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->career_level_max());
    }

    // required uint32 item = 4;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item());
    }

    // required uint32 num = 5;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

    // required uint32 rate = 6;
    if (has_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rate());
    }

    // required uint32 type = 7;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 must = 8;
    if (has_must()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->must());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 xiyou = 9;
    if (has_xiyou()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->xiyou());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hunt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Hunt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Hunt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Hunt::MergeFrom(const Hunt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_career_level_min()) {
      set_career_level_min(from.career_level_min());
    }
    if (from.has_career_level_max()) {
      set_career_level_max(from.career_level_max());
    }
    if (from.has_item()) {
      set_item(from.item());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_rate()) {
      set_rate(from.rate());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_must()) {
      set_must(from.must());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_xiyou()) {
      set_xiyou(from.xiyou());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Hunt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Hunt::CopyFrom(const Hunt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hunt::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void Hunt::Swap(Hunt* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(career_level_min_, other->career_level_min_);
    std::swap(career_level_max_, other->career_level_max_);
    std::swap(item_, other->item_);
    std::swap(num_, other->num_);
    std::swap(rate_, other->rate_);
    std::swap(type_, other->type_);
    std::swap(must_, other->must_);
    std::swap(xiyou_, other->xiyou_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Hunt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Hunt_descriptor_;
  metadata.reflection = Hunt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Hunts::kHuntsFieldNumber;
#endif  // !_MSC_VER

Hunts::Hunts()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.Hunts)
}

void Hunts::InitAsDefaultInstance() {
}

Hunts::Hunts(const Hunts& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.Hunts)
}

void Hunts::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Hunts::~Hunts() {
  // @@protoc_insertion_point(destructor:CfgTreasure.Hunts)
  SharedDtor();
}

void Hunts::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Hunts::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Hunts::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Hunts_descriptor_;
}

const Hunts& Hunts::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

Hunts* Hunts::default_instance_ = NULL;

Hunts* Hunts::New() const {
  return new Hunts;
}

void Hunts::Clear() {
  hunts_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Hunts::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.Hunts)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgTreasure.Hunt hunts = 1;
      case 1: {
        if (tag == 10) {
         parse_hunts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hunts()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_hunts;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.Hunts)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.Hunts)
  return false;
#undef DO_
}

void Hunts::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.Hunts)
  // repeated .CfgTreasure.Hunt hunts = 1;
  for (int i = 0; i < this->hunts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->hunts(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.Hunts)
}

::google::protobuf::uint8* Hunts::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.Hunts)
  // repeated .CfgTreasure.Hunt hunts = 1;
  for (int i = 0; i < this->hunts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->hunts(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.Hunts)
  return target;
}

int Hunts::ByteSize() const {
  int total_size = 0;

  // repeated .CfgTreasure.Hunt hunts = 1;
  total_size += 1 * this->hunts_size();
  for (int i = 0; i < this->hunts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hunts(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hunts::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Hunts* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Hunts*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Hunts::MergeFrom(const Hunts& from) {
  GOOGLE_CHECK_NE(&from, this);
  hunts_.MergeFrom(from.hunts_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Hunts::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Hunts::CopyFrom(const Hunts& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hunts::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->hunts())) return false;
  return true;
}

void Hunts::Swap(Hunts* other) {
  if (other != this) {
    hunts_.Swap(&other->hunts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Hunts::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Hunts_descriptor_;
  metadata.reflection = Hunts_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HuntBase::kTypeFieldNumber;
const int HuntBase::kGoldFieldNumber;
const int HuntBase::kFiftyFieldNumber;
const int HuntBase::kCostItemFieldNumber;
const int HuntBase::kCostNumFieldNumber;
const int HuntBase::kDayFieldNumber;
const int HuntBase::kFreeNumFieldNumber;
const int HuntBase::kScoreItemFieldNumber;
#endif  // !_MSC_VER

HuntBase::HuntBase()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.HuntBase)
}

void HuntBase::InitAsDefaultInstance() {
}

HuntBase::HuntBase(const HuntBase& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.HuntBase)
}

void HuntBase::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  gold_ = 0u;
  fifty_ = 0u;
  cost_item_ = 0u;
  cost_num_ = 0u;
  day_ = 0u;
  free_num_ = 0u;
  score_item_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HuntBase::~HuntBase() {
  // @@protoc_insertion_point(destructor:CfgTreasure.HuntBase)
  SharedDtor();
}

void HuntBase::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HuntBase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HuntBase::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HuntBase_descriptor_;
}

const HuntBase& HuntBase::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

HuntBase* HuntBase::default_instance_ = NULL;

HuntBase* HuntBase::New() const {
  return new HuntBase;
}

void HuntBase::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HuntBase*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(type_, score_item_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HuntBase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.HuntBase)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_gold;
        break;
      }

      // required uint32 gold = 2;
      case 2: {
        if (tag == 16) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_fifty;
        break;
      }

      // required uint32 fifty = 3;
      case 3: {
        if (tag == 24) {
         parse_fifty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fifty_)));
          set_has_fifty();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cost_item;
        break;
      }

      // required uint32 cost_item = 4;
      case 4: {
        if (tag == 32) {
         parse_cost_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_item_)));
          set_has_cost_item();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_cost_num;
        break;
      }

      // required uint32 cost_num = 5;
      case 5: {
        if (tag == 40) {
         parse_cost_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_num_)));
          set_has_cost_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_day;
        break;
      }

      // required uint32 day = 6;
      case 6: {
        if (tag == 48) {
         parse_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_free_num;
        break;
      }

      // required uint32 free_num = 7;
      case 7: {
        if (tag == 56) {
         parse_free_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &free_num_)));
          set_has_free_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_score_item;
        break;
      }

      // required uint32 score_item = 8;
      case 8: {
        if (tag == 64) {
         parse_score_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_item_)));
          set_has_score_item();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.HuntBase)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.HuntBase)
  return false;
#undef DO_
}

void HuntBase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.HuntBase)
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required uint32 gold = 2;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gold(), output);
  }

  // required uint32 fifty = 3;
  if (has_fifty()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fifty(), output);
  }

  // required uint32 cost_item = 4;
  if (has_cost_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cost_item(), output);
  }

  // required uint32 cost_num = 5;
  if (has_cost_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cost_num(), output);
  }

  // required uint32 day = 6;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->day(), output);
  }

  // required uint32 free_num = 7;
  if (has_free_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->free_num(), output);
  }

  // required uint32 score_item = 8;
  if (has_score_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->score_item(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.HuntBase)
}

::google::protobuf::uint8* HuntBase::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.HuntBase)
  // required uint32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->type(), target);
  }

  // required uint32 gold = 2;
  if (has_gold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->gold(), target);
  }

  // required uint32 fifty = 3;
  if (has_fifty()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->fifty(), target);
  }

  // required uint32 cost_item = 4;
  if (has_cost_item()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->cost_item(), target);
  }

  // required uint32 cost_num = 5;
  if (has_cost_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->cost_num(), target);
  }

  // required uint32 day = 6;
  if (has_day()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->day(), target);
  }

  // required uint32 free_num = 7;
  if (has_free_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->free_num(), target);
  }

  // required uint32 score_item = 8;
  if (has_score_item()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->score_item(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.HuntBase)
  return target;
}

int HuntBase::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 gold = 2;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gold());
    }

    // required uint32 fifty = 3;
    if (has_fifty()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fifty());
    }

    // required uint32 cost_item = 4;
    if (has_cost_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost_item());
    }

    // required uint32 cost_num = 5;
    if (has_cost_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost_num());
    }

    // required uint32 day = 6;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->day());
    }

    // required uint32 free_num = 7;
    if (has_free_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->free_num());
    }

    // required uint32 score_item = 8;
    if (has_score_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score_item());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HuntBase::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HuntBase* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HuntBase*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HuntBase::MergeFrom(const HuntBase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_fifty()) {
      set_fifty(from.fifty());
    }
    if (from.has_cost_item()) {
      set_cost_item(from.cost_item());
    }
    if (from.has_cost_num()) {
      set_cost_num(from.cost_num());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
    if (from.has_free_num()) {
      set_free_num(from.free_num());
    }
    if (from.has_score_item()) {
      set_score_item(from.score_item());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HuntBase::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HuntBase::CopyFrom(const HuntBase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HuntBase::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void HuntBase::Swap(HuntBase* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(gold_, other->gold_);
    std::swap(fifty_, other->fifty_);
    std::swap(cost_item_, other->cost_item_);
    std::swap(cost_num_, other->cost_num_);
    std::swap(day_, other->day_);
    std::swap(free_num_, other->free_num_);
    std::swap(score_item_, other->score_item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HuntBase::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HuntBase_descriptor_;
  metadata.reflection = HuntBase_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HuntBases::kBasesFieldNumber;
#endif  // !_MSC_VER

HuntBases::HuntBases()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgTreasure.HuntBases)
}

void HuntBases::InitAsDefaultInstance() {
}

HuntBases::HuntBases(const HuntBases& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgTreasure.HuntBases)
}

void HuntBases::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HuntBases::~HuntBases() {
  // @@protoc_insertion_point(destructor:CfgTreasure.HuntBases)
  SharedDtor();
}

void HuntBases::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HuntBases::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HuntBases::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HuntBases_descriptor_;
}

const HuntBases& HuntBases::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgTreasure_2eproto();
  return *default_instance_;
}

HuntBases* HuntBases::default_instance_ = NULL;

HuntBases* HuntBases::New() const {
  return new HuntBases;
}

void HuntBases::Clear() {
  bases_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HuntBases::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgTreasure.HuntBases)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgTreasure.HuntBase bases = 1;
      case 1: {
        if (tag == 10) {
         parse_bases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bases()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_bases;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgTreasure.HuntBases)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgTreasure.HuntBases)
  return false;
#undef DO_
}

void HuntBases::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgTreasure.HuntBases)
  // repeated .CfgTreasure.HuntBase bases = 1;
  for (int i = 0; i < this->bases_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->bases(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgTreasure.HuntBases)
}

::google::protobuf::uint8* HuntBases::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgTreasure.HuntBases)
  // repeated .CfgTreasure.HuntBase bases = 1;
  for (int i = 0; i < this->bases_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->bases(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgTreasure.HuntBases)
  return target;
}

int HuntBases::ByteSize() const {
  int total_size = 0;

  // repeated .CfgTreasure.HuntBase bases = 1;
  total_size += 1 * this->bases_size();
  for (int i = 0; i < this->bases_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bases(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HuntBases::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HuntBases* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HuntBases*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HuntBases::MergeFrom(const HuntBases& from) {
  GOOGLE_CHECK_NE(&from, this);
  bases_.MergeFrom(from.bases_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HuntBases::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HuntBases::CopyFrom(const HuntBases& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HuntBases::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->bases())) return false;
  return true;
}

void HuntBases::Swap(HuntBases* other) {
  if (other != this) {
    bases_.Swap(&other->bases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HuntBases::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HuntBases_descriptor_;
  metadata.reflection = HuntBases_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CfgTreasure

// @@protoc_insertion_point(global_scope)
