// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CfgMagic.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CfgMagic.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace CfgMagic {

namespace {

const ::google::protobuf::Descriptor* Magic_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Magic_reflection_ = NULL;
const ::google::protobuf::Descriptor* Magics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Magics_reflection_ = NULL;
const ::google::protobuf::Descriptor* MagicTower_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MagicTower_reflection_ = NULL;
const ::google::protobuf::Descriptor* MagicTowers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MagicTowers_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CfgMagic_2eproto() {
  protobuf_AddDesc_CfgMagic_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CfgMagic.proto");
  GOOGLE_CHECK(file != NULL);
  Magic_descriptor_ = file->message_type(0);
  static const int Magic_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, attrtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, lock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, smelt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, attrcal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, expcal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, smeltcal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, attr_),
  };
  Magic_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Magic_descriptor_,
      Magic::default_instance_,
      Magic_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magic, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Magic));
  Magics_descriptor_ = file->message_type(1);
  static const int Magics_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magics, magics_),
  };
  Magics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Magics_descriptor_,
      Magics::default_instance_,
      Magics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Magics));
  MagicTower_descriptor_ = file->message_type(2);
  static const int MagicTower_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTower, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTower, dailyreward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTower, reward_),
  };
  MagicTower_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MagicTower_descriptor_,
      MagicTower::default_instance_,
      MagicTower_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTower, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTower, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MagicTower));
  MagicTowers_descriptor_ = file->message_type(3);
  static const int MagicTowers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTowers, magic_towers_),
  };
  MagicTowers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MagicTowers_descriptor_,
      MagicTowers::default_instance_,
      MagicTowers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTowers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicTowers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MagicTowers));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CfgMagic_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Magic_descriptor_, &Magic::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Magics_descriptor_, &Magics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MagicTower_descriptor_, &MagicTower::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MagicTowers_descriptor_, &MagicTowers::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CfgMagic_2eproto() {
  delete Magic::default_instance_;
  delete Magic_reflection_;
  delete Magics::default_instance_;
  delete Magics_reflection_;
  delete MagicTower::default_instance_;
  delete MagicTower_reflection_;
  delete MagicTowers::default_instance_;
  delete MagicTowers_reflection_;
}

void protobuf_AddDesc_CfgMagic_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::CfgCommon::protobuf_AddDesc_CfgCommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016CfgMagic.proto\022\010CfgMagic\032\017CfgCommon.pr"
    "oto\"\322\001\n\005Magic\022\020\n\010attrType\030\001 \002(\r\022\r\n\005color"
    "\030\002 \002(\r\022\013\n\003exp\030\003 \002(\r\022\r\n\005level\030\004 \002(\r\022\014\n\004lo"
    "ck\030\005 \002(\r\022\014\n\004type\030\006 \002(\r\022\n\n\002id\030\007 \002(\r\022\r\n\005sm"
    "elt\030\010 \002(\004\022\017\n\007attrCal\030\t \003(\r\022\016\n\006expCal\030\n \003"
    "(\r\022\020\n\010smeltCal\030\013 \003(\004\022\"\n\004attr\030\014 \003(\0132\024.Cfg"
    "Common.Attribute\")\n\006Magics\022\037\n\006magics\030\001 \003"
    "(\0132\017.CfgMagic.Magic\"P\n\nMagicTower\022\n\n\002id\030"
    "\001 \002(\r\022\023\n\013dailyReward\030\002 \002(\r\022!\n\006reward\030\003 \003"
    "(\0132\021.CfgCommon.Reward\"9\n\013MagicTowers\022*\n\014"
    "magic_towers\030\001 \003(\0132\024.CfgMagic.MagicTower", 440);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CfgMagic.proto", &protobuf_RegisterTypes);
  Magic::default_instance_ = new Magic();
  Magics::default_instance_ = new Magics();
  MagicTower::default_instance_ = new MagicTower();
  MagicTowers::default_instance_ = new MagicTowers();
  Magic::default_instance_->InitAsDefaultInstance();
  Magics::default_instance_->InitAsDefaultInstance();
  MagicTower::default_instance_->InitAsDefaultInstance();
  MagicTowers::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CfgMagic_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CfgMagic_2eproto {
  StaticDescriptorInitializer_CfgMagic_2eproto() {
    protobuf_AddDesc_CfgMagic_2eproto();
  }
} static_descriptor_initializer_CfgMagic_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Magic::kAttrTypeFieldNumber;
const int Magic::kColorFieldNumber;
const int Magic::kExpFieldNumber;
const int Magic::kLevelFieldNumber;
const int Magic::kLockFieldNumber;
const int Magic::kTypeFieldNumber;
const int Magic::kIdFieldNumber;
const int Magic::kSmeltFieldNumber;
const int Magic::kAttrCalFieldNumber;
const int Magic::kExpCalFieldNumber;
const int Magic::kSmeltCalFieldNumber;
const int Magic::kAttrFieldNumber;
#endif  // !_MSC_VER

Magic::Magic()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgMagic.Magic)
}

void Magic::InitAsDefaultInstance() {
}

Magic::Magic(const Magic& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgMagic.Magic)
}

void Magic::SharedCtor() {
  _cached_size_ = 0;
  attrtype_ = 0u;
  color_ = 0u;
  exp_ = 0u;
  level_ = 0u;
  lock_ = 0u;
  type_ = 0u;
  id_ = 0u;
  smelt_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Magic::~Magic() {
  // @@protoc_insertion_point(destructor:CfgMagic.Magic)
  SharedDtor();
}

void Magic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Magic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Magic::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Magic_descriptor_;
}

const Magic& Magic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgMagic_2eproto();
  return *default_instance_;
}

Magic* Magic::default_instance_ = NULL;

Magic* Magic::New() const {
  return new Magic;
}

void Magic::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Magic*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(attrtype_, smelt_);
    id_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  attrcal_.Clear();
  expcal_.Clear();
  smeltcal_.Clear();
  attr_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Magic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgMagic.Magic)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 attrType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attrtype_)));
          set_has_attrtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_color;
        break;
      }

      // required uint32 color = 2;
      case 2: {
        if (tag == 16) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_exp;
        break;
      }

      // required uint32 exp = 3;
      case 3: {
        if (tag == 24) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_level;
        break;
      }

      // required uint32 level = 4;
      case 4: {
        if (tag == 32) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_lock;
        break;
      }

      // required uint32 lock = 5;
      case 5: {
        if (tag == 40) {
         parse_lock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_)));
          set_has_lock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // required uint32 type = 6;
      case 6: {
        if (tag == 48) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_id;
        break;
      }

      // required uint32 id = 7;
      case 7: {
        if (tag == 56) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_smelt;
        break;
      }

      // required uint64 smelt = 8;
      case 8: {
        if (tag == 64) {
         parse_smelt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &smelt_)));
          set_has_smelt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_attrCal;
        break;
      }

      // repeated uint32 attrCal = 9;
      case 9: {
        if (tag == 72) {
         parse_attrCal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 72, input, this->mutable_attrcal())));
        } else if (tag == 74) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_attrcal())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_attrCal;
        if (input->ExpectTag(80)) goto parse_expCal;
        break;
      }

      // repeated uint32 expCal = 10;
      case 10: {
        if (tag == 80) {
         parse_expCal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 80, input, this->mutable_expcal())));
        } else if (tag == 82) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_expcal())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_expCal;
        if (input->ExpectTag(88)) goto parse_smeltCal;
        break;
      }

      // repeated uint64 smeltCal = 11;
      case 11: {
        if (tag == 88) {
         parse_smeltCal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 88, input, this->mutable_smeltcal())));
        } else if (tag == 90) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_smeltcal())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_smeltCal;
        if (input->ExpectTag(98)) goto parse_attr;
        break;
      }

      // repeated .CfgCommon.Attribute attr = 12;
      case 12: {
        if (tag == 98) {
         parse_attr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_attr;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgMagic.Magic)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgMagic.Magic)
  return false;
#undef DO_
}

void Magic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgMagic.Magic)
  // required uint32 attrType = 1;
  if (has_attrtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->attrtype(), output);
  }

  // required uint32 color = 2;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->color(), output);
  }

  // required uint32 exp = 3;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->exp(), output);
  }

  // required uint32 level = 4;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->level(), output);
  }

  // required uint32 lock = 5;
  if (has_lock()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lock(), output);
  }

  // required uint32 type = 6;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->type(), output);
  }

  // required uint32 id = 7;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->id(), output);
  }

  // required uint64 smelt = 8;
  if (has_smelt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->smelt(), output);
  }

  // repeated uint32 attrCal = 9;
  for (int i = 0; i < this->attrcal_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      9, this->attrcal(i), output);
  }

  // repeated uint32 expCal = 10;
  for (int i = 0; i < this->expcal_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      10, this->expcal(i), output);
  }

  // repeated uint64 smeltCal = 11;
  for (int i = 0; i < this->smeltcal_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      11, this->smeltcal(i), output);
  }

  // repeated .CfgCommon.Attribute attr = 12;
  for (int i = 0; i < this->attr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->attr(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgMagic.Magic)
}

::google::protobuf::uint8* Magic::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgMagic.Magic)
  // required uint32 attrType = 1;
  if (has_attrtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->attrtype(), target);
  }

  // required uint32 color = 2;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->color(), target);
  }

  // required uint32 exp = 3;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->exp(), target);
  }

  // required uint32 level = 4;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->level(), target);
  }

  // required uint32 lock = 5;
  if (has_lock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->lock(), target);
  }

  // required uint32 type = 6;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->type(), target);
  }

  // required uint32 id = 7;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->id(), target);
  }

  // required uint64 smelt = 8;
  if (has_smelt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->smelt(), target);
  }

  // repeated uint32 attrCal = 9;
  for (int i = 0; i < this->attrcal_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(9, this->attrcal(i), target);
  }

  // repeated uint32 expCal = 10;
  for (int i = 0; i < this->expcal_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(10, this->expcal(i), target);
  }

  // repeated uint64 smeltCal = 11;
  for (int i = 0; i < this->smeltcal_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(11, this->smeltcal(i), target);
  }

  // repeated .CfgCommon.Attribute attr = 12;
  for (int i = 0; i < this->attr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->attr(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgMagic.Magic)
  return target;
}

int Magic::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 attrType = 1;
    if (has_attrtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attrtype());
    }

    // required uint32 color = 2;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->color());
    }

    // required uint32 exp = 3;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

    // required uint32 level = 4;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // required uint32 lock = 5;
    if (has_lock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock());
    }

    // required uint32 type = 6;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 id = 7;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint64 smelt = 8;
    if (has_smelt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->smelt());
    }

  }
  // repeated uint32 attrCal = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->attrcal_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->attrcal(i));
    }
    total_size += 1 * this->attrcal_size() + data_size;
  }

  // repeated uint32 expCal = 10;
  {
    int data_size = 0;
    for (int i = 0; i < this->expcal_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->expcal(i));
    }
    total_size += 1 * this->expcal_size() + data_size;
  }

  // repeated uint64 smeltCal = 11;
  {
    int data_size = 0;
    for (int i = 0; i < this->smeltcal_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->smeltcal(i));
    }
    total_size += 1 * this->smeltcal_size() + data_size;
  }

  // repeated .CfgCommon.Attribute attr = 12;
  total_size += 1 * this->attr_size();
  for (int i = 0; i < this->attr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attr(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Magic::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Magic* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Magic*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Magic::MergeFrom(const Magic& from) {
  GOOGLE_CHECK_NE(&from, this);
  attrcal_.MergeFrom(from.attrcal_);
  expcal_.MergeFrom(from.expcal_);
  smeltcal_.MergeFrom(from.smeltcal_);
  attr_.MergeFrom(from.attr_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attrtype()) {
      set_attrtype(from.attrtype());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_lock()) {
      set_lock(from.lock());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_smelt()) {
      set_smelt(from.smelt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Magic::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Magic::CopyFrom(const Magic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Magic::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->attr())) return false;
  return true;
}

void Magic::Swap(Magic* other) {
  if (other != this) {
    std::swap(attrtype_, other->attrtype_);
    std::swap(color_, other->color_);
    std::swap(exp_, other->exp_);
    std::swap(level_, other->level_);
    std::swap(lock_, other->lock_);
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(smelt_, other->smelt_);
    attrcal_.Swap(&other->attrcal_);
    expcal_.Swap(&other->expcal_);
    smeltcal_.Swap(&other->smeltcal_);
    attr_.Swap(&other->attr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Magic::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Magic_descriptor_;
  metadata.reflection = Magic_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Magics::kMagicsFieldNumber;
#endif  // !_MSC_VER

Magics::Magics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgMagic.Magics)
}

void Magics::InitAsDefaultInstance() {
}

Magics::Magics(const Magics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgMagic.Magics)
}

void Magics::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Magics::~Magics() {
  // @@protoc_insertion_point(destructor:CfgMagic.Magics)
  SharedDtor();
}

void Magics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Magics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Magics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Magics_descriptor_;
}

const Magics& Magics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgMagic_2eproto();
  return *default_instance_;
}

Magics* Magics::default_instance_ = NULL;

Magics* Magics::New() const {
  return new Magics;
}

void Magics::Clear() {
  magics_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Magics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgMagic.Magics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgMagic.Magic magics = 1;
      case 1: {
        if (tag == 10) {
         parse_magics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_magics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_magics;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgMagic.Magics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgMagic.Magics)
  return false;
#undef DO_
}

void Magics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgMagic.Magics)
  // repeated .CfgMagic.Magic magics = 1;
  for (int i = 0; i < this->magics_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->magics(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgMagic.Magics)
}

::google::protobuf::uint8* Magics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgMagic.Magics)
  // repeated .CfgMagic.Magic magics = 1;
  for (int i = 0; i < this->magics_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->magics(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgMagic.Magics)
  return target;
}

int Magics::ByteSize() const {
  int total_size = 0;

  // repeated .CfgMagic.Magic magics = 1;
  total_size += 1 * this->magics_size();
  for (int i = 0; i < this->magics_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->magics(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Magics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Magics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Magics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Magics::MergeFrom(const Magics& from) {
  GOOGLE_CHECK_NE(&from, this);
  magics_.MergeFrom(from.magics_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Magics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Magics::CopyFrom(const Magics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Magics::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->magics())) return false;
  return true;
}

void Magics::Swap(Magics* other) {
  if (other != this) {
    magics_.Swap(&other->magics_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Magics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Magics_descriptor_;
  metadata.reflection = Magics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MagicTower::kIdFieldNumber;
const int MagicTower::kDailyRewardFieldNumber;
const int MagicTower::kRewardFieldNumber;
#endif  // !_MSC_VER

MagicTower::MagicTower()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgMagic.MagicTower)
}

void MagicTower::InitAsDefaultInstance() {
}

MagicTower::MagicTower(const MagicTower& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgMagic.MagicTower)
}

void MagicTower::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  dailyreward_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MagicTower::~MagicTower() {
  // @@protoc_insertion_point(destructor:CfgMagic.MagicTower)
  SharedDtor();
}

void MagicTower::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MagicTower::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MagicTower::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MagicTower_descriptor_;
}

const MagicTower& MagicTower::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgMagic_2eproto();
  return *default_instance_;
}

MagicTower* MagicTower::default_instance_ = NULL;

MagicTower* MagicTower::New() const {
  return new MagicTower;
}

void MagicTower::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MagicTower*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, dailyreward_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  reward_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MagicTower::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgMagic.MagicTower)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_dailyReward;
        break;
      }

      // required uint32 dailyReward = 2;
      case 2: {
        if (tag == 16) {
         parse_dailyReward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dailyreward_)));
          set_has_dailyreward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_reward;
        break;
      }

      // repeated .CfgCommon.Reward reward = 3;
      case 3: {
        if (tag == 26) {
         parse_reward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reward()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_reward;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgMagic.MagicTower)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgMagic.MagicTower)
  return false;
#undef DO_
}

void MagicTower::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgMagic.MagicTower)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 dailyReward = 2;
  if (has_dailyreward()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->dailyreward(), output);
  }

  // repeated .CfgCommon.Reward reward = 3;
  for (int i = 0; i < this->reward_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->reward(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgMagic.MagicTower)
}

::google::protobuf::uint8* MagicTower::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgMagic.MagicTower)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 dailyReward = 2;
  if (has_dailyreward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->dailyreward(), target);
  }

  // repeated .CfgCommon.Reward reward = 3;
  for (int i = 0; i < this->reward_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->reward(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgMagic.MagicTower)
  return target;
}

int MagicTower::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 dailyReward = 2;
    if (has_dailyreward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dailyreward());
    }

  }
  // repeated .CfgCommon.Reward reward = 3;
  total_size += 1 * this->reward_size();
  for (int i = 0; i < this->reward_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reward(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MagicTower::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MagicTower* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MagicTower*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MagicTower::MergeFrom(const MagicTower& from) {
  GOOGLE_CHECK_NE(&from, this);
  reward_.MergeFrom(from.reward_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_dailyreward()) {
      set_dailyreward(from.dailyreward());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MagicTower::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MagicTower::CopyFrom(const MagicTower& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MagicTower::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->reward())) return false;
  return true;
}

void MagicTower::Swap(MagicTower* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(dailyreward_, other->dailyreward_);
    reward_.Swap(&other->reward_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MagicTower::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MagicTower_descriptor_;
  metadata.reflection = MagicTower_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MagicTowers::kMagicTowersFieldNumber;
#endif  // !_MSC_VER

MagicTowers::MagicTowers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CfgMagic.MagicTowers)
}

void MagicTowers::InitAsDefaultInstance() {
}

MagicTowers::MagicTowers(const MagicTowers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CfgMagic.MagicTowers)
}

void MagicTowers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MagicTowers::~MagicTowers() {
  // @@protoc_insertion_point(destructor:CfgMagic.MagicTowers)
  SharedDtor();
}

void MagicTowers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MagicTowers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MagicTowers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MagicTowers_descriptor_;
}

const MagicTowers& MagicTowers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CfgMagic_2eproto();
  return *default_instance_;
}

MagicTowers* MagicTowers::default_instance_ = NULL;

MagicTowers* MagicTowers::New() const {
  return new MagicTowers;
}

void MagicTowers::Clear() {
  magic_towers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MagicTowers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CfgMagic.MagicTowers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CfgMagic.MagicTower magic_towers = 1;
      case 1: {
        if (tag == 10) {
         parse_magic_towers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_magic_towers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_magic_towers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CfgMagic.MagicTowers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CfgMagic.MagicTowers)
  return false;
#undef DO_
}

void MagicTowers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CfgMagic.MagicTowers)
  // repeated .CfgMagic.MagicTower magic_towers = 1;
  for (int i = 0; i < this->magic_towers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->magic_towers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CfgMagic.MagicTowers)
}

::google::protobuf::uint8* MagicTowers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CfgMagic.MagicTowers)
  // repeated .CfgMagic.MagicTower magic_towers = 1;
  for (int i = 0; i < this->magic_towers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->magic_towers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CfgMagic.MagicTowers)
  return target;
}

int MagicTowers::ByteSize() const {
  int total_size = 0;

  // repeated .CfgMagic.MagicTower magic_towers = 1;
  total_size += 1 * this->magic_towers_size();
  for (int i = 0; i < this->magic_towers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->magic_towers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MagicTowers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MagicTowers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MagicTowers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MagicTowers::MergeFrom(const MagicTowers& from) {
  GOOGLE_CHECK_NE(&from, this);
  magic_towers_.MergeFrom(from.magic_towers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MagicTowers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MagicTowers::CopyFrom(const MagicTowers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MagicTowers::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->magic_towers())) return false;
  return true;
}

void MagicTowers::Swap(MagicTowers* other) {
  if (other != this) {
    magic_towers_.Swap(&other->magic_towers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MagicTowers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MagicTowers_descriptor_;
  metadata.reflection = MagicTowers_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CfgMagic

// @@protoc_insertion_point(global_scope)
