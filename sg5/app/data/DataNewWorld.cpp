/*
 * DataNewWorld.cpp
 *
 *  Created on: 2014-9-17
 *      Author: Ralf
 */

#include "DataNewWorld.h"

#include "CBroadcast.h"
#include "LogicAdmin.h"

#include <netdb.h>
#include <sys/time.h>

const unsigned CDataNewWorld::c_crit_dodge[120] = {
		437,
		441,
		446,
		450,
		455,
		459,
		464,
		468,
		473,
		477,
		482,
		486,
		491,
		495,
		500,
		510,
		520,
		531,
		541,
		552,
		562,
		572,
		583,
		593,
		604,
		614,
		625,
		635,
		645,
		656,
		672,
		688,
		705,
		721,
		737,
		753,
		770,
		786,
		802,
		818,
		835,
		851,
		867,
		883,
		900,
		927,
		955,
		982,
		1010,
		1037,
		1065,
		1092,
		1120,
		1147,
		1175,
		1202,
		1230,
		1257,
		1285,
		1312,
		1377,
		1442,
		1508,
		1573,
		1638,
		1703,
		1768,
		1833,
		1899,
		1964,
		2064,
		2165,
		2265,
		2366,
		2466,
		2566,
		2667,
		2767,
		2868,
		2968,
		3131,
		3294,
		3457,
		3620,
		3782,
		3945,
		4108,
		4271,
		4434,
		4597,
		4855,
		5112,
		5370,
		5628,
		5886,
		6143,
		6401,
		6659,
		6917,
		7175,
		7246,
		7318,
		7391,
		7464,
		7538,
		7613,
		7689,
		7765,
		7842,
		7920,
		7999,
		8078,
		8158,
		8239,
		8321,
		8404,
		8488,
		8572,
		8657,
		8743
};
const unsigned CDataNewWorld::c_attack[120] = {
		160,
		166,
		173,
		180,
		186,
		193,
		200,
		209,
		218,
		228,
		237,
		247,
		257,
		267,
		278,
		289,
		300,
		311,
		323,
		334,
		346,
		358,
		370,
		382,
		398,
		414,
		431,
		447,
		465,
		482,
		502,
		521,
		541,
		561,
		581,
		601,
		622,
		643,
		663,
		691,
		719,
		748,
		777,
		808,
		838,
		872,
		905,
		939,
		974,
		1009,
		1044,
		1080,
		1116,
		1152,
		1201,
		1249,
		1299,
		1350,
		1403,
		1455,
		1543,
		1631,
		1722,
		1813,
		1907,
		2001,
		2099,
		2196,
		2358,
		2527,
		2680,
		2833,
		2990,
		3148,
		3312,
		3475,
		3644,
		3814,
		4094,
		4388,
		4654,
		4919,
		5193,
		5467,
		5751,
		6035,
		6329,
		6622,
		7110,
		7620,
		8081,
		8541,
		9017,
		9494,
		9986,
		10479,
		10989,
		11500,
		12346,
		13233,
		13656,
		14092,
		14542,
		15007,
		15487,
		15982,
		16493,
		17020,
		17564,
		18126,
		18706,
		19304,
		19921,
		20558,
		21215,
		21893,
		22593,
		23315,
		24061,
		24830
};

const unsigned CDataNewWorld::npc_day_default[NEW_WORLD_HERO_DAY] = {
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		2,
		2,
		3,
		3,
		3,
		3,
		3,
		4,
		4,
		4,
		4,
		4,
		5,
		5,
		5,
		5,
		5,
		6,
		6,
		6,
		6,
		6,
		7,
		7,
		8,
		8,
		9,
		9,
		10,
		10,
		11,
		11,
		12,
		12,
		13,
		13,
		14,
		14,
		14,
		15,
		15,
		16,
		16,
		16,
		17,
		17,
		18,
		18,
		18,
		19,
		19,
		19,
		20,
		20,
		20,
		21,
		21,
		21,
		22,
		22,
		22,
		22,
		23,
		23,
		23,
		24,
		24,
		24,
		25,
		25,
		25,
		25,
		26,
		26,
		26,
		26,
		27,
		27,
		27,
		27,
		28,
		28,
		28,
		28,
		29,
		29,
		29,
		29,
		30,
		30,
		30,
		30,
		30,
		31,
		31,
		31,
		31,
		31,
		32,
		32,
		32,
		32,
		33,
		33,
		33,
		33,
		33,
		34,
		34,
		34,
		34,
		34,
		34,
		35,
		35,
		35,
		35,
		35,
		36,
		36,
		36,
		36,
		36,
		36,
		37,
		37,
		37,
		37,
		37,
		37,
		38,
		38,
		38,
		38,
		38,
		38,
		39,
		39,
		39,
		39,
		39,
		39,
		40,
		40,
		40,
		40,
		40,
		40,
		40,
		41,
		41,
		41,
		41,
		41,
		41,
		41,
		42,
		42,
		42,
		42,
		42,
		42,
		42,
		43,
		43,
		43,
		43,
		43,
		43,
		43,
		44,
		44,
		44,
		44,
		44,
		44,
		44,
		44,
		45,
		45,
		45,
		45,
		45,
		45,
		45,
		45,
		46,
		46,
		46,
		46,
		46,
		46,
		46,
		46,
		46
};

const unsigned CDataNewWorld::npc_level[NEW_WORLD_HERO_NPC_DEFAULT] = {
		50,
		59,
		65,
		70,
		74,
		77,
		80,
		81,
		82,
		83,
		84,
		85,
		86,
		87,
		88,
		89,
		90,
		91,
		92,
		93,
		94,
		95,
		96,
		97,
		98,
		99,
		100,
		101,
		102,
		103,
		104,
		105,
		106,
		107,
		108,
		109,
		110,
		111,
		112,
		113,
		114,
		115,
		116,
		117,
		118,
		119,
		120
};

const unsigned CDataNewWorld::npc_property[3][NEW_WORLD_HERO_NPC_DEFAULT][NewWorldProperty_max] = {
		{
			{165,26,56,100,90,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{224,35,76,118,99,10,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{303,48,103,130,105,16,0,0,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{373,59,127,140,110,21,0,0,21,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{450,71,153,148,114,25,0,0,25,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{506,80,172,154,117,28,0,0,28,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{572,90,195,160,120,31,0,0,31,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{601,95,204,162,121,32,0,0,32,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{629,99,214,164,122,33,0,0,33,33,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{657,104,223,166,123,34,0,0,34,34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{685,108,233,168,124,35,0,0,35,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{712,113,242,170,125,36,0,0,36,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{740,117,252,172,126,37,0,0,37,37,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{767,121,261,174,127,38,0,0,38,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{794,126,270,176,128,39,0,0,39,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{821,130,279,178,129,40,0,0,40,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{863,137,294,180,130,41,0,0,41,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{905,143,308,182,131,42,0,0,42,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{946,150,322,184,132,43,0,0,43,43,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{987,156,336,186,133,44,0,0,44,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1027,163,350,188,134,45,0,0,45,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1068,169,363,190,135,46,0,0,46,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1107,175,377,192,136,47,0,0,47,47,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1147,182,390,194,137,48,0,0,48,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1186,188,404,196,138,49,0,0,49,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1225,194,417,198,139,50,0,0,50,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1264,200,430,200,140,51,0,0,51,51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1278,202,435,202,141,52,0,0,52,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1291,204,439,204,142,53,0,0,53,53,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1304,206,444,206,143,54,0,0,54,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1316,208,448,208,144,55,0,0,55,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1327,210,452,210,145,56,0,0,56,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1338,212,455,212,146,57,0,0,57,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1349,214,459,214,147,58,0,0,58,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1359,215,463,216,148,59,0,0,59,59,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1369,217,466,218,149,60,0,0,60,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1378,218,469,220,150,61,0,0,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1396,221,475,222,151,62,0,0,62,62,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1414,224,481,224,152,63,0,0,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1432,227,487,226,153,64,0,0,64,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1450,230,493,228,154,65,0,0,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1467,232,499,230,155,66,0,0,66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1485,235,505,232,156,67,0,0,67,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1502,238,511,234,157,68,0,0,68,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1519,241,517,236,158,69,0,0,69,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1536,243,523,238,159,70,0,0,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1553,246,529,240,160,70,0,0,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		},
		{
			{122,34,41,100,90,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{165,46,56,118,99,10,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{223,63,76,130,105,16,0,0,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{275,78,94,140,110,21,0,0,21,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{331,94,113,148,114,25,0,0,25,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{373,105,128,154,117,28,0,0,28,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{422,119,144,160,120,31,0,0,31,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{443,125,152,162,121,32,0,0,32,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{463,131,159,164,122,33,0,0,33,33,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{484,137,166,166,123,34,0,0,34,34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{505,143,173,168,124,35,0,0,35,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{525,148,180,170,125,36,0,0,36,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{545,154,187,172,126,37,0,0,37,37,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{565,160,194,174,127,38,0,0,38,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{585,165,200,176,128,39,0,0,39,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{605,171,207,178,129,40,0,0,40,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{636,180,218,180,130,41,0,0,41,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{667,189,229,182,131,42,0,0,42,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{688,195,236,184,132,43,0,0,43,43,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{713,202,244,186,133,44,0,0,44,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{737,209,253,188,134,45,0,0,45,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{761,215,261,190,135,46,0,0,46,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{785,222,269,192,136,47,0,0,47,47,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{808,229,277,194,137,48,0,0,48,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{830,235,285,196,138,49,0,0,49,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{853,241,292,198,139,50,0,0,50,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{874,247,300,200,140,51,0,0,51,51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{889,252,305,202,141,52,0,0,52,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{904,256,310,204,142,53,0,0,53,53,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{918,260,315,206,143,54,0,0,54,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{933,264,320,208,144,55,0,0,55,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{947,268,325,210,145,56,0,0,56,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{961,272,329,212,146,57,0,0,57,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{975,276,334,214,147,58,0,0,58,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{988,280,339,216,148,59,0,0,59,59,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1002,284,344,218,149,60,0,0,60,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1015,287,348,220,150,61,0,0,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1029,291,353,222,151,62,0,0,62,62,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1042,295,357,224,152,63,0,0,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1055,299,362,226,153,64,0,0,64,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1068,302,366,228,154,65,0,0,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1081,306,371,230,155,66,0,0,66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1094,310,375,232,156,67,0,0,67,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1107,313,380,234,157,68,0,0,68,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1119,317,384,236,158,69,0,0,69,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1132,320,388,238,159,70,0,0,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{1144,324,393,240,160,70,0,0,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		},
		{
			{102,41,54,100,90,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{138,56,73,118,99,10,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{186,76,98,130,105,16,0,0,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{230,93,121,140,110,21,0,0,21,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{277,113,146,148,114,25,0,0,25,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{312,127,165,154,117,28,0,0,28,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{352,144,186,160,120,31,0,0,31,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{370,151,195,162,121,32,0,0,32,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{387,158,205,164,122,33,0,0,33,33,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{405,165,214,166,123,34,0,0,34,34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{422,172,223,168,124,35,0,0,35,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{439,179,232,170,125,36,0,0,36,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{453,184,239,172,126,37,0,0,37,37,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{466,190,246,174,127,38,0,0,38,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{479,195,253,176,128,39,0,0,39,39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{492,200,260,178,129,40,0,0,40,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{514,209,271,180,130,41,0,0,41,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{535,218,283,182,131,42,0,0,42,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{556,227,294,184,132,43,0,0,43,43,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{576,235,304,186,133,44,0,0,44,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{596,243,315,188,134,45,0,0,45,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{615,251,325,190,135,46,0,0,46,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{634,259,335,192,136,47,0,0,47,47,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{653,266,345,194,137,48,0,0,48,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{671,274,354,196,138,49,0,0,49,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{689,281,364,198,139,50,0,0,50,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{707,288,373,200,140,51,0,0,51,51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{719,293,379,202,141,52,0,0,52,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{730,298,386,204,142,53,0,0,53,53,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{742,302,392,206,143,54,0,0,54,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{754,307,398,208,144,55,0,0,55,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{765,312,404,210,145,56,0,0,56,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{776,316,410,212,146,57,0,0,57,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{788,321,416,214,147,58,0,0,58,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{799,326,422,216,148,59,0,0,59,59,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{810,330,428,218,149,60,0,0,60,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{821,335,433,220,150,61,0,0,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{831,339,439,222,151,62,0,0,62,62,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{842,343,445,224,152,63,0,0,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{853,348,450,226,153,64,0,0,64,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{863,352,456,228,154,65,0,0,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{874,356,461,230,155,66,0,0,66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{884,360,467,232,156,67,0,0,67,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{894,365,472,234,157,68,0,0,68,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{905,369,478,236,158,69,0,0,69,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{915,373,483,238,159,70,0,0,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{925,377,488,240,160,70,0,0,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
		}
};

const unsigned CDataNewWorld::road_map[NEW_WORLD_ROAD][2] = {
		{1,2},
		{1,3},
		{1,4},
		{2,5},
		{2,7},
		{3,5},
		{3,6},
		{4,6},
		{4,7},
		{5,172},
		{5,272},
		{6,272},
		{6,372},
		{7,372},
		{7,172},
		{101,102},
		{101,103},
		{101,104},
		{102,114},
		{102,103},
		{103,108},
		{103,104},
		{104,105},
		{105,120},
		{105,106},
		{108,107},
		{108,109},
		{103,110},
		{110,145},
		{110,148},
		{103,111},
		{111,119},
		{111,112},
		{114,113},
		{114,115},
		{115,116},
		{113,116},
		{112,116},
		{112,118},
		{109,141},
		{109,137},
		{107,137},
		{107,126},
		{106,126},
		{120,126},
		{126,121},
		{126,129},
		{137,130},
		{137,136},
		{145,141},
		{145,147},
		{148,147},
		{148,153},
		{119,153},
		{119,118},
		{118,158},
		{118,117},
		{117,162},
		{116,166},
		{116,171},
		{170,165},
		{171,170},
		{165,168},
		{168,167},
		{168,169},
		{165,164},
		{164,163},
		{165,160},
		{160,159},
		{160,157},
		{165,161},
		{161,154},
		{154,153},
		{161,156},
		{156,153},
		{165,162},
		{162,158},
		{153,155},
		{155,151},
		{153,152},
		{152,151},
		{147,146},
		{146,149},
		{147,150},
		{150,149},
		{141,144},
		{144,143},
		{141,142},
		{142,143},
		{141,139},
		{139,135},
		{141,140},
		{140,135},
		{135,128},
		{130,132},
		{136,132},
		{132,128},
		{129,125},
		{121,125},
		{125,128},
		{128,134},
		{134,138},
		{134,133},
		{128,127},
		{127,131},
		{128,123},
		{123,124},
		{123,122},
		{166,170},
		{201,202},
		{201,203},
		{201,204},
		{204,256},
		{256,259},
		{256,257},
		{257,260},
		{260,261},
		{261,265},
		{265,266},
		{260,262},
		{262,265},
		{260,255},
		{259,260},
		{203,244},
		{244,245},
		{255,254},
		{254,263},
		{263,264},
		{264,266},
		{254,258},
		{258,264},
		{244,255},
		{245,254},
		{245,246},
		{246,253},
		{253,252},
		{252,266},
		{246,249},
		{249,252},
		{246,247},
		{247,241},
		{246,243},
		{243,241},
		{246,242},
		{203,237},
		{237,242},
		{242,238},
		{238,240},
		{240,239},
		{238,236},
		{236,239},
		{237,231},
		{231,238},
		{232,234},
		{231,232},
		{234,235},
		{232,233},
		{233,235},
		{232,228},
		{228,224},
		{224,212},
		{232,229},
		{229,224},
		{232,227},
		{203,230},
		{230,227},
		{227,222},
		{230,226},
		{226,222},
		{226,214},
		{222,219},
		{219,215},
		{215,212},
		{222,218},
		{218,215},
		{202,225},
		{225,217},
		{225,221},
		{217,214},
		{221,214},
		{214,210},
		{210,207},
		{207,212},
		{214,211},
		{211,207},
		{212,206},
		{206,205},
		{206,208},
		{212,213},
		{213,209},
		{212,220},
		{220,223},
		{220,216},
		{266,269},
		{269,271},
		{269,270},
		{266,267},
		{267,268},
		{266,251},
		{251,250},
		{251,248},
		{204,203},
		{203,202},
		{301,302},
		{301,303},
		{301,304},
		{302,303},
		{303,304},
		{302,332},
		{332,330},
		{330,320},
		{320,317},
		{317,311},
		{311,312},
		{332,331},
		{331,320},
		{320,318},
		{318,311},
		{320,333},
		{303,334},
		{334,333},
		{333,329},
		{329,321},
		{321,319},
		{319,312},
		{334,335},
		{335,329},
		{329,328},
		{328,319},
		{335,326},
		{303,354},
		{354,336},
		{336,326},
		{336,338},
		{338,339},
		{339,325},
		{354,355},
		{355,338},
		{355,352},
		{338,346},
		{346,325},
		{352,351},
		{351,350},
		{350,349},
		{352,353},
		{353,350},
		{352,345},
		{345,340},
		{352,343},
		{343,340},
		{303,356},
		{362,361},
		{357,352},
		{357,361},
		{361,358},
		{358,359},
		{359,349},
		{356,362},
		{362,366},
		{356,357},
		{361,360},
		{360,359},
		{304,363},
		{363,364},
		{364,366},
		{366,367},
		{367,369},
		{369,349},
		{363,365},
		{365,366},
		{366,368},
		{368,369},
		{349,337},
		{337,371},
		{337,370},
		{349,348},
		{348,347},
		{349,342},
		{342,341},
		{342,344},
		{312,307},
		{307,305},
		{307,306},
		{312,309},
		{309,308},
		{312,313},
		{313,314},
		{313,310},
		{312,322},
		{322,323},
		{323,326},
		{326,315},
		{315,316},
		{322,327},
		{327,326},
		{326,324},
		{324,316},
		{272,235},
		{272,239},
		{272,241},
		{372,340},
		{372,325},
		{372,316},
		{172,151},
		{172,149},
		{172,143},
		{223,138},
		{216,133},
		{213,131},
		{209,127},
		{208,124},
		{205,122},
		{248,341},
		{250,344},
		{267,347},
		{268,348},
		{270,370},
		{271,371},
		{169,305},
		{167,306},
		{164,308},
		{163,309},
		{159,310},
		{157,314}
};
NewWorldRoadMap CDataNewWorld::m_roadmap;

const unsigned CDataNewWorld::mission_city[3][3][NEW_WORLD_MISSION_CITY] =
{
		{
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{122,123,124,127,131,133,134,138,128,125,121,129,126,106,120,105,132,130,136,137,107,108,109,135,140,139,141,142,143,144,149,146,145,1,2,3,4,5,6,7,172,272,372,0},
			{114,113,115,116,166,171,170,111,112,119,118,158,117,162,110,147,150,148,151,152,155,153,154,156,161,165,157,160,159,163,164,167,168,169,1,2,3,4,5,6,7,172,272,372}
		},
		{
			{225,221,217,214,211,210,207,230,227,226,222,219,218,215,212,237,238,231,236,232,234,235,233,228,229,224,223,220,216,213,209,208,205,206,1,2,3,4,5,6,7,172,272,372},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{256,257,259,260,261,262,265,244,245,255,254,258,263,264,266,252,253,249,246,247,241,242,243,240,239,251,248,250,267,269,268,270,271,1,2,3,4,5,6,7,172,272,372,0}
		},
		{
			{332,330,331,320,317,318,311,334,333,335,329,321,328,319,312,305,306,307,308,309,310,313,314,322,323,327,326,324,315,316,325,339,336,1,2,3,4,5,6,7,172,272,372,0},
			{363,364,365,366,368,367,369,356,362,357,358,361,360,359,349,371,370,337,348,347,344,341,342,350,351,352,353,345,343,340,346,338,355,354,1,2,3,4,5,6,7,172,272,372},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		}
};

const int CDataNewWorld::move_r1[NEW_WORLD_MOVE_LEVEL] = {
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	575,
	632,
	692,
	756,
	824,
	933,
	1054,
	1183,
	1321,
	1468,
	1623,
	1787,
	1959,
	2139,
	2328,
	2525,
	2729,
	2941,
	3161,
	3387,
	3620,
	3860,
	4108,
	4367,
	4636,
	5367,
	5797,
	6244,
	6710,
	7195,
	7699,
	8222,
	8766,
	9330,
	9915,
	10831,
	11746,
	12696,
	13684,
	14709,
	15772,
	16874,
	18017,
	19200,
	20425,
	21692,
	22560,
	23462,
	24401,
	25377,
	26392,
	27448,
	28546,
	29688,
	30875,
	32110,
	33395,
	34730,
	36120,
	37564,
	39067,
	40630,
	42255,
	43945,
	45703,
	47531,
	48957,
	50426,
	51938,
	53497,
	55102,
	56755,
	58457,
	60211,
	62017,
	63878,
	65794,
	67768,
	69801,
	71895,
	74052,
	76274,
	78562,
	80919,
	83346,
	85847,
	88422,
	91075,
	93807,
	96621,
	99520,
	102506,
	105581,
	108748,
	112011,
	115371
};

const unsigned CDataNewWorld::kill_reward_kill[NEW_WORLD_KILL_REWARD_LEVEL_MAX-NEW_WORLD_KILL_REWARD_LEVEL_MIN+1][NEW_WORLD_KILL_REWARD_KILL] = {
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000},
		{2000,6000,15000}
};
const unsigned CDataNewWorld::kill_reward_p[NEW_WORLD_KILL_REWARD_LEVEL_MAX-NEW_WORLD_KILL_REWARD_LEVEL_MIN+1][NEW_WORLD_KILL_REWARD_P] = {
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{6990,4661,1864,186},
	{7255,4838,1935,193},
	{7525,5018,2007,200},
	{7800,5201,2080,208},
	{8080,5388,2155,215},
	{8365,5578,2231,223},
	{8660,5773,2309,230},
	{8955,5970,2388,238},
	{9255,6171,2468,246},
	{9565,6376,2550,255},
	{9875,6585,2634,263},
	{10195,6796,2718,271},
	{10515,7011,2804,280},
	{10845,7231,2892,289},
	{11180,7453,2981,298},
	{11520,7680,3072,307},
	{11865,7910,3164,316},
	{12215,8145,3258,325},
	{12570,8381,3352,335},
	{12935,8623,3449,344},
	{13300,8868,3547,354},
	{13675,9116,3646,364},
	{14050,9368,3747,374},
	{14435,9623,3849,384},
	{14825,9883,3953,395},
	{15220,10146,4058,405},
	{15620,10415,4166,416},
	{16025,10685,4274,427},
	{16440,10960,4384,438},
	{16855,11238,4495,449},
	{17280,11520,4608,460},
	{17710,11806,4722,472},
	{18145,12096,4838,483},
	{18585,12390,4956,495},
	{19030,12686,5074,507},
	{19480,12988,5195,519},
	{19940,13293,5317,531},
	{20400,13601,5440,544},
	{20870,13915,5566,556},
	{21345,14231,5692,569},
	{21825,14551,5820,582},
	{22315,14876,5950,595},
	{22805,15205,6082,608},
	{23305,15536,6214,621},
	{23805,15871,6348,634},
	{24315,16211,6484,648},
	{24835,16556,6622,662},
	{25355,16903,6761,676},
	{25880,17255,6902,690},
	{26415,17610,7044,704},
	{26955,17970,7188,718},
	{27500,18333,7333,733},
	{28050,18701,7480,748},
	{28605,19071,7628,762},
	{29170,19446,7778,777},
	{29740,19826,7930,793},
	{30315,20210,8084,808},
	{30895,20596,8238,823},
	{31480,20988,8395,839},
	{32075,21383,8553,855},
	{32675,21783,8713,871},
	{33275,22185,8874,887},
	{33890,22593,9037,903},
	{34505,23005,9202,920},
	{35130,23420,9368,936},
	{35755,23838,9535,953},
	{36390,24261,9704,970},
	{37035,24690,9876,987},
	{37680,25121,10048,1004},
	{38335,25556,10222,1022},
	{38995,25996,10398,1039}
};

const unsigned CDataNewWorld::kill_a[NEW_WORLD_KILL_REWARD_LEVEL_MAX - NEW_WORLD_KILL_REWARD_LEVEL_MIN + 1] = {
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		165,
		224,
		224,
		224,
		224,
		224,
		224,
		303,
		303,
		303,
		303,
		303,
		373,
		373,
		373,
		373,
		450,
		450,
		450,
		506,
		506,
		506,
		572,
		601,
		629,
		657,
		685,
		712,
		740,
		767,
		794,
		821,
		863,
		905,
		946,
		987,
		1027,
		1068,
		1107,
		1147,
		1186,
		1225,
		1264,
		1278,
		1291,
		1304,
		1316,
		1327,
		1338,
		1349,
		1359,
		1369,
		1378,
		1396,
		1414,
		1432,
		1450,
		1467,
		1485,
		1502,
		1519,
		1536,
		1553
};
NewWorldNPCTimeMap CDataNewWorld::m_npctimemap;
const unsigned CDataNewWorld::m_npctime[NEW_WORLD_CITY][4] = {
		{1,480,480,480},
		{2,480,480,480},
		{3,480,480,480},
		{4,480,480,480},
		{5,480,480,480},
		{6,480,480,480},
		{7,480,480,480},
		{172,480,480,480},
		{272,480,480,480},
		{372,480,480,480},

		{120,60,900,900},
		{106,60,900,900},
		{107,60,900,900},
		{105,60,900,900},
		{108,60,900,900},
		{109,60,900,900},
		{115,60,900,900},
		{110,60,900,900},
		{111,60,900,900},
		{119,60,900,900},
		{112,60,900,900},
		{113,60,900,900},
		{114,60,900,900},
		{121,180,600,600},
		{125,180,600,600},
		{126,180,600,600},
		{128,180,600,600},
		{129,180,600,600},
		{132,180,600,600},
		{130,180,600,600},
		{136,180,600,600},
		{137,180,600,600},
		{145,180,600,600},
		{146,180,600,600},
		{147,180,600,600},
		{149,180,600,600},
		{150,180,600,600},
		{148,180,600,600},
		{118,180,600,600},
		{158,180,600,600},
		{117,180,600,600},
		{162,180,600,600},
		{116,180,600,600},
		{165,180,600,600},
		{166,180,600,600},
		{170,180,600,600},
		{171,180,600,600},
		{135,180,600,600},
		{153,180,600,600},
		{122,300,480,480},
		{124,300,480,480},
		{123,300,480,480},
		{127,300,480,480},
		{131,300,480,480},
		{133,300,480,480},
		{134,300,480,480},
		{140,300,480,480},
		{138,300,480,480},
		{139,300,480,480},
		{141,300,480,480},
		{142,300,480,480},
		{144,300,480,480},
		{143,300,480,480},
		{151,300,480,480},
		{152,300,480,480},
		{155,300,480,480},
		{154,300,480,480},
		{156,300,480,480},
		{157,300,480,480},
		{159,300,480,480},
		{160,300,480,480},
		{161,300,480,480},
		{163,300,480,480},
		{164,300,480,480},
		{167,300,480,480},
		{168,300,480,480},
		{169,300,480,480},

		{217,900,60,900},
		{221,900,60,900},
		{225,900,60,900},
		{226,900,60,900},
		{230,900,60,900},
		{227,900,60,900},
		{245,900,60,900},
		{244,900,60,900},
		{255,900,60,900},
		{256,900,60,900},
		{257,900,60,900},
		{259,900,60,900},
		{237,900,60,900},
		{207,600,180,600},
		{210,600,180,600},
		{211,600,180,600},
		{214,600,180,600},
		{212,600,180,600},
		{215,600,180,600},
		{218,600,180,600},
		{219,600,180,600},
		{222,600,180,600},
		{224,600,180,600},
		{231,600,180,600},
		{238,600,180,600},
		{236,600,180,600},
		{239,600,180,600},
		{240,600,180,600},
		{242,600,180,600},
		{243,600,180,600},
		{254,600,180,600},
		{258,600,180,600},
		{263,600,180,600},
		{264,600,180,600},
		{266,600,180,600},
		{265,600,180,600},
		{261,600,180,600},
		{260,600,180,600},
		{262,600,180,600},
		{206,480,300,480},
		{205,480,300,480},
		{208,480,300,480},
		{209,480,300,480},
		{213,480,300,480},
		{216,480,300,480},
		{220,480,300,480},
		{223,480,300,480},
		{228,480,300,480},
		{229,480,300,480},
		{232,480,300,480},
		{233,480,300,480},
		{234,480,300,480},
		{235,480,300,480},
		{241,480,300,480},
		{247,480,300,480},
		{248,480,300,480},
		{249,480,300,480},
		{246,480,300,480},
		{250,480,300,480},
		{251,480,300,480},
		{252,480,300,480},
		{253,480,300,480},
		{267,480,300,480},
		{268,480,300,480},
		{269,480,300,480},
		{270,480,300,480},
		{271,480,300,480},

		{332,900,900,60},
		{330,900,900,60},
		{331,900,900,60},
		{333,900,900,60},
		{334,900,900,60},
		{335,900,900,60},
		{354,900,900,60},
		{356,900,900,60},
		{357,900,900,60},
		{362,900,900,60},
		{363,900,900,60},
		{364,900,900,60},
		{365,900,900,60},
		{311,600,600,180},
		{312,600,600,180},
		{317,600,600,180},
		{318,600,600,180},
		{319,600,600,180},
		{321,600,600,180},
		{328,600,600,180},
		{329,600,600,180},
		{336,600,600,180},
		{325,600,600,180},
		{339,600,600,180},
		{338,600,600,180},
		{355,600,600,180},
		{346,600,600,180},
		{353,600,600,180},
		{358,600,600,180},
		{359,600,600,180},
		{360,600,600,180},
		{366,600,600,180},
		{367,600,600,180},
		{368,600,600,180},
		{369,600,600,180},
		{349,600,600,180},
		{326,600,600,180},
		{320,600,600,180},
		{361,600,600,180},
		{305,480,480,300},
		{306,480,480,300},
		{307,480,480,300},
		{308,480,480,300},
		{309,480,480,300},
		{310,480,480,300},
		{313,480,480,300},
		{322,480,480,300},
		{314,480,480,300},
		{323,480,480,300},
		{327,480,480,300},
		{315,480,480,300},
		{324,480,480,300},
		{316,480,480,300},
		{340,480,480,300},
		{343,480,480,300},
		{341,480,480,300},
		{342,480,480,300},
		{345,480,480,300},
		{352,480,480,300},
		{344,480,480,300},
		{351,480,480,300},
		{350,480,480,300},
		{347,480,480,300},
		{348,480,480,300},
		{370,480,480,300},
		{371,480,480,300},
		{337,480,480,300}
};

void NewWorldCity::MakeReward(){
	reward = nextReward;
	if(CDataNewWorld::isCapital(cid))
		nextReward = Math::GetRandomInt(NEW_WORLD_REWARD-1)+1;
	else
		nextReward = Math::GetRandomInt(NEW_WORLD_REWARD);
}

bool NewWorldHero::copy(NewWorldHero &other)
{
	bool fix = false;

	if(other.property[NewWorldProperty_hp] < property[NewWorldProperty_hp])
		hp = min(max(0, hp - (property[NewWorldProperty_hp] - other.property[NewWorldProperty_hp]))
			,hp * other.property[NewWorldProperty_hp] / property[NewWorldProperty_hp]);
	hid = other.hid;
	if(kingdom != other.kingdom && other.kingdom)
	{
		kingdom = other.kingdom;
		cid = CDataNewWorld::getCapital(kingdom);
		status = NewWorldHeroStatus_wait_defence;
		next = 0;
		fix = true;
	}
	job = other.job;
	level = other.level;
	if(level > NEW_WORLD_HERO_LEVEL)
		level = NEW_WORLD_HERO_LEVEL;
	if(level == 0)
		level = 1;
	memcpy(name, other.name, sizeof(name));
	memcpy(icon, other.icon, sizeof(icon));
	memcpy(property, other.property, sizeof(property));

	other.level = level;
	other.status = status;
	other.cid = cid;
	other.hp = hp;
	other.buff = buff;
	return fix;
}

CDataNewWorld::CDataNewWorld()
{
	m_init = false;
	m_tool = false;

	m_ts = m_count = 0;
	memset(m_history, 0, sizeof(m_history));
	memset(m_mission, 0, sizeof(m_mission));
}

CDataNewWorld::~CDataNewWorld()
{}

int CDataNewWorld::Init(const string &path, semdat sem)
{
	if(m_init)
		return 0;

	if(m_roadmap.empty())
	{
		for(unsigned i=0;i<NEW_WORLD_ROAD;++i)
		{
			m_roadmap[road_map[i][0]].push_back(road_map[i][1]);
			m_roadmap[road_map[i][1]].push_back(road_map[i][0]);
		}
	}

	if(m_npctimemap.empty())
	{
		for(unsigned i=0;i<NEW_WORLD_CITY;++i)
			m_npctimemap[m_npctime[i][0]] = DataNewWorldNPCTime(m_npctime[i][1],m_npctime[i][2],m_npctime[i][3]);
	}

	int semgroup = 0;
	int semserver = 0;
	Config::GetDomain(semserver);
	if(!semserver)
		Config::GetDB(semserver);
	if(!m_sh.CreateOrOpen(path.c_str(), sizeof(DataNewWorld), SEM_ID(sem,semgroup,semserver)))
	{
		error_log("[init_NewWorld_fail][path=%s]", path.c_str());
		return R_ERROR;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata)
	{
		CAutoLock lock(&m_sh, true);

		if(!m_sh.HasInit())
		{
			memset(pdata, 0, sizeof(*pdata));

			unsigned now = Time::GetGlobalTime();
			for(unsigned k=0;k<=3;++k)
			{
				unsigned i = k ? (NEW_WORLD_CITY_KINGDOM * (k - 1) + NEW_WORLD_CITY_NEUTRAL) : 0;
				unsigned n = NEW_WORLD_CITY_KINGDOM * k + NEW_WORLD_CITY_NEUTRAL;
				unsigned j = NEW_WORLD_CITY_KINGDOM_SEQ * k + NEW_WORLD_CITY_CAPITAL;
				for(;i<n;++i,++j)
				{
					pdata->city[i].seq = i;
					pdata->city[i].cid = j;
					pdata->city[i].kingdom = k;
					pdata->city[i].countN = NEW_WORLD_CITY_NPC;
					pdata->city[i].npcts = now;
					pdata->city[i].MakeReward();
					pdata->city[i].ts = now;
					if(isCapital(j))
						pdata->city[i].uid = 70003;
					else if(isCore(j))
						pdata->city[i].uid = 70002;
					else
						pdata->city[i].uid = 70001;
					pdata->city[i].name[0] = 'N';pdata->city[i].name[1] = 'P';pdata->city[i].name[2] = 'C';
				}
			}
			pdata->changets = now;
			pdata->ts = now;

			m_sh.SetInitDone();
		}
		sync(pdata);
	}
	else
		return R_ERR_DB;

	string change = path + ".change";
	if(!m_shChange.CreateOrOpen(change.c_str(), sizeof(DataNewWorldChange), SEM_ID(sem,semgroup,semserver)))
	{
		error_log("[init_NewWorld_Change_fail][path=%s]", change.c_str());
		return R_ERROR;
	}

	DataNewWorldChange *pdataChange = (DataNewWorldChange *)m_shChange.GetAddress();
	if(pdataChange)
	{
		CAutoLock lock(&m_shChange, true);

		if(!m_shChange.HasInit())
		{
			memset(pdataChange, 0, sizeof(*pdataChange));
			m_shChange.SetInitDone();
		}
	}
	else
		return R_ERR_DB;

	m_init = true;

	return 0;
}

const NewWorldCityMap& CDataNewWorld::GetWorld()
{
	checkTick();
	return m_citymap;
}
const unsigned* CDataNewWorld::GetHistory(unsigned index)
{
	checkTick();
	if(index < NEW_WORLD_HISTORY)
		return m_history[index];
	else
		return NULL;
}
const NewWorldMisson* CDataNewWorld::GetMission()
{
	checkTick();
	return m_mission;
}
const NewWorldCityBattle& CDataNewWorld::GetCity(unsigned cid)
{
	checkTick();
	if(m_citymap.count(cid))
		return m_citymap[cid];
	else
		return m_citymap[0];
}
const NewWorldHeroMap&  CDataNewWorld::GetAllHero()
{
	checkTick();
	return m_heromap;
}
const NewWorldHero&  CDataNewWorld::GetHero(NewWorldHeroIndex index)
{
	checkTick();
	if(isHero(index) && m_heromap.count(index))
		return m_heromap[index];
	else
		return m_heromap[NewWorldHeroIndex(0, 0)];
}

int CDataNewWorld::SetHero(NewWorldHero &hero, bool &fix)
{
	checkTick();

	if(!isHero(hero.index))
		return R_ERR_DB;

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	if(m_heromap.count(hero.index))
	{
		fix = pdata->hero[m_heromap[hero.index].seq].copy(hero);
		pdata->hero[m_heromap[hero.index].seq].ts = now;
	}
	else
	{
		if(pdata->count == NEW_WORLD_HERO)
			return  R_ERR_DB;

		bool add = true;
		for(unsigned i=0;i<pdata->count;++i)
		{
			if(pdata->hero[i].index == hero.index)
			{
				fix = pdata->hero[i].copy(hero);
				pdata->hero[i].ts = now;
				add = false;
				break;
			}

		}
		if(add)
		{
			hero.seq = pdata->count;
			hero.hp = hero.property[NewWorldProperty_hp];
			hero.cid = getCapital(hero.kingdom);
			if(hero.kingdom == 0)
				return  R_ERR_PARAM;
			if(hero.cid == 0)
				return  R_ERR_PARAM;
			hero.status = NewWorldHeroStatus_wait_defence;
			hero.ts = now;

			pdata->hero[pdata->count] = hero;
			++pdata->count;

			pdata->city[m_citymap[hero.cid].city.seq].ts = now;
			/*20141114 change countN*/
			if(hero.kingdom)
				++pdata->city[m_citymap[hero.cid].city.seq].count[hero.kingdom-1];
			//debug_log("city=%u,count%u=%d,hero=%u,%u",hero.cid,hero.kingdom,pdata->city[m_citymap[hero.cid].city.seq].count[hero.kingdom-1],hero.index.uid,hero.index.index);
		}
	}

	return 0;
}
int CDataNewWorld::Move(NewWorldHeroIndex index, unsigned cid, bool leave, unsigned fly, unsigned &status)
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	if(!m_heromap.count(index))
	{
		status = m_heromap[index].status;
		return R_ERR_DB;
	}
	if(!m_citymap.count(cid))
	{
		status = m_heromap[index].status;
		return R_ERR_DB;
	}
	if(fly == 2)
	{
		if(m_heromap[index].kingdom != m_citymap[cid].city.kingdom)
		{
			bool f = true;
			if(m_roadmap.count(cid))
			{
				for(vector<unsigned>::const_iterator it=m_roadmap[cid].begin();it!=m_roadmap[cid].end();++it)
				{
					if(m_citymap[*it].city.kingdom == m_heromap[index].kingdom)
					{
						f = false;
						break;
					}
				}
			}
			if(f)
			{
				status = m_heromap[index].status;
				LOGIC_ERROR_RETURN_MSG("newworld_city_can_not_move");
			}
		}
	}
	else if(fly == 1)
	{
		if(m_heromap[index].kingdom != m_citymap[cid].city.kingdom && !m_citymap[cid].city.Fighting())
		{
			status = m_heromap[index].status;
			LOGIC_ERROR_RETURN_MSG("newworld_city_can_not_move");
		}
	}
	else if(!hasRoad(m_heromap[index].cid, cid))
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_city_can_not_move");
	}
	if(m_heromap[index].kingdom != m_citymap[cid].city.kingdom && !canAttack(cid))
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_city_can_not_move");
	}

	if(!CanMove(m_heromap[index].status))
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_can_not_move");
	}
	if((((m_citymap[m_heromap[index].cid].city.kingdom == m_heromap[index].kingdom
	&& m_citymap[m_heromap[index].cid].city.attacker.uid)
	|| (m_citymap[m_heromap[index].cid].city.kingdom != m_heromap[index].kingdom)) && !leave)
	/*|| (m_citymap[m_heromap[index].cid].city.kingdom == m_heromap[index].kingdom
	&& !m_citymap[m_heromap[index].cid].city.attacker.uid && leave)*/)
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_can_not_move");
	}

	// 兵员低于5%时不能移动
	const static unsigned int precent = 5;
	if (m_heromap[index].hp < (m_heromap[index].property[NewWorldProperty_hp] * precent / 100))
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_hp_low_percent_5");
	}

	if(m_citymap[m_heromap[index].cid].city.kingdom != m_heromap[index].kingdom
	&& m_citymap[m_heromap[index].cid].city.jm.jm3ts > now)
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_move_jm3");
	}
	if(m_citymap[cid].city.kingdom != m_heromap[index].kingdom
	&& m_citymap[cid].city.jm.jm4ts > now)
	{
		status = m_heromap[index].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_move_jm4");
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_heromap[index].seq;
	if(!CanMove(pdata->hero[seq].status))
	{
		status = pdata->hero[seq].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_can_not_move");
	}
	unsigned cityseq = m_citymap[pdata->hero[seq].cid].city.seq;
	unsigned tcityseq = m_citymap[cid].city.seq;
	if((((pdata->city[cityseq].kingdom == pdata->hero[seq].kingdom
	&& pdata->city[cityseq].attacker.uid)
	|| (pdata->city[cityseq].kingdom != pdata->hero[seq].kingdom)) && !leave)
	/*|| (pdata->city[cityseq].kingdom == pdata->hero[seq].kingdom
	&& !pdata->city[cityseq].attacker.uid && leave)*/)
	{
		status = pdata->hero[seq].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_can_not_move");
	}

	if (pdata->hero[seq].hp < (pdata->hero[seq].property[NewWorldProperty_hp] * precent / 100))
	{
		status = pdata->hero[seq].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_hp_low_percent_5");
	}

	if(pdata->city[cityseq].kingdom != pdata->hero[seq].kingdom
	&& pdata->city[cityseq].jm.jm3ts > now)
	{
		status = pdata->hero[seq].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_move_jm3");
	}
	if(pdata->city[tcityseq].kingdom != pdata->hero[seq].kingdom
	&& pdata->city[tcityseq].jm.jm4ts > now)
	{
		status = pdata->hero[seq].status;
		LOGIC_ERROR_RETURN_MSG("newworld_hero_move_jm4");
	}

	pdata->changets = now;

	pdata->hero[seq].status = NewWorldHeroStatus_wait_move;
	pdata->hero[seq].next = cid;
	pdata->hero[seq].ts = now;

	status = NewWorldHeroStatus_wait_move;

	//debug_log("city=%u,next=%u,hero=%u,%u",pdata->hero[seq].cid,cid,index.uid,index.index);
	return 0;
}
int CDataNewWorld::Change(NewWorldHeroIndex index, unsigned type)
{
	checkTick();

	if(!m_heromap.count(index))
		return R_ERR_DB;

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	pdata->hero[m_heromap[index].seq].type = type;
	pdata->hero[m_heromap[index].seq].ts = now;

	return 0;
}
int CDataNewWorld::Clone(NewWorldHeroIndex index,bool issuper)
{
	checkTick();

	if(!m_heromap.count(index))
		return R_ERR_DB;
	if(!m_citymap.count(m_heromap[index].cid))
		return R_ERR_DB;

	if(m_citymap[m_heromap[index].cid].city.countV == NEW_WORLD_CITY_VISION)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_vision_full_1");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	if(isCapital(pdata->hero[m_heromap[index].seq].cid) || pdata->hero[m_heromap[index].seq].cid != m_heromap[index].cid)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_hero_die");
	}

	unsigned seq = m_citymap[m_heromap[index].cid].city.seq;

	if(pdata->city[seq].countV > NEW_WORLD_CITY_VISION)
	{
		pdata->city[seq].countV = 0;
		for(unsigned count=0;count<NEW_WORLD_CITY_VISION;++count)
		{
			if(pdata->city[seq].vision[count].index.uid)
				++pdata->city[seq].countV;
		}
	}
	if(issuper && pdata->city[seq].countV < NEW_WORLD_CITY_VISION_BASE)
	{
		debug_log("uid=%u,cid=%u,countV=%u",index.uid,m_heromap[index].cid,pdata->city[seq].countV);
		LOGIC_ERROR_RETURN_MSG("newworld_vision_not_full");
	}
	if(pdata->city[seq].countV >= (issuper?NEW_WORLD_CITY_VISION-5+1:NEW_WORLD_CITY_VISION_BASE))
	{
		debug_log("uid=%u,seq=%u,issuper=%d,countV=%u",index.uid,seq,int(issuper),pdata->city[seq].countV);
		if (issuper)
		{
			LOGIC_ERROR_RETURN_MSG("newworld_vision_full_1");
		}
		else
		{
			LOGIC_ERROR_RETURN_MSG("newworld_vision_full_0");
		}
	}


	for (int loop=0;loop<(issuper?5:1);loop++)
	{
		for(unsigned count=0;count<(issuper?NEW_WORLD_CITY_VISION:NEW_WORLD_CITY_VISION_BASE);++count)
		{
			if(!pdata->city[seq].vision[count].index.uid)
			{
				pdata->city[seq].vision[count] = pdata->hero[m_heromap[index].seq];
				pdata->city[seq].vision[count].status = pdata->city[seq].kingdom == pdata->city[seq].vision[count].kingdom?
															NewWorldHeroStatus_wait_defence:NewWorldHeroStatus_wait_attack;
				pdata->city[seq].vision[count].index.uid = index.index + 1;
				pdata->city[seq].vision[count].index.index = count;
				pdata->city[seq].vision[count].seq = index.uid;
				pdata->city[seq].vision[count].ts = now;
				pdata->city[seq].vision[count].next = now;
				pdata->city[seq].vision[count].buff = 0;

				++pdata->city[seq].countV;
				/*20141114 change countN*/
				if(pdata->city[seq].vision[count].kingdom)
					++pdata->city[seq].count[pdata->city[seq].vision[count].kingdom-1];
				//debug_log("city=%u,count%u=%d,countV=%d,hero=%u,%u",pdata->city[seq].cid,pdata->city[seq].vision[count].kingdom,pdata->city[seq].count[pdata->city[seq].vision[count].kingdom-1],pdata->city[seq].countV,index.uid,index.index);

				pdata->city[seq].ts = now;
				pdata->changets = now;

				addKill(pdata->hero[m_heromap[index].seq], NEW_WORLD_KILL_ADD_CLONE, now, pdata);

				if (issuper)
					break;
				else
					return 0;
			}
		}
	}

	if (!issuper)
	{
		debug_log("uid=%u,seq=%u,issuper=%d,countV=%u",index.uid,seq,int(issuper),pdata->city[seq].countV);
		LOGIC_ERROR_RETURN_MSG("newworld_vision_full_0");
	}
	return 0;
}
int CDataNewWorld::Rush(NewWorldHeroIndex index, NewWorldHero &other, NewWorldHero &end)
{
	checkTick();

	if(!m_heromap.count(index))
		return R_ERR_DB;
	if(!m_citymap.count(m_heromap[index].cid))
		return R_ERR_DB;

	unsigned r = 0;
	unsigned cid = m_heromap[index].cid;
	if(!CanMove(m_heromap[index].status))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_rush");
	}
	if(m_heromap[index].kingdom == m_citymap[cid].city.kingdom
	&& (m_citymap[cid].attacker.size() <= NEW_WORLD_RUSH_MIN
	|| m_citymap[cid].defender.size() <= NEW_WORLD_RUSH_MIN))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_rush_min");
	}
	if(m_heromap[index].kingdom != m_citymap[cid].city.kingdom
	&& (m_citymap[cid].attacker.size() <= NEW_WORLD_RUSH_MIN
	|| m_citymap[cid].defender.size() + m_citymap[cid].city.countN  <= NEW_WORLD_RUSH_MIN))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_rush_min");
	}
	NewWorldCityQueue &checkqueue = m_heromap[index].kingdom == m_citymap[cid].city.kingdom?m_citymap[cid].defender:m_citymap[cid].attacker;
	for(NewWorldCityQueue::iterator sit=checkqueue.begin();sit!=checkqueue.end();++sit)
	{
		++r;
		if(index == sit->second)
		{
			LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_rush");
		}
		if(r >= NEW_WORLD_RUSH_MIN)
			break;
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned heroseq = m_heromap[index].seq;
	cid = pdata->hero[heroseq].cid;
	unsigned cityseq = m_citymap[cid].city.seq;
	unsigned otherseq = 0;

	if(!CanMove(pdata->hero[heroseq].status))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_rush");
	}

	bool rush_att = pdata->hero[heroseq].kingdom != pdata->city[cityseq].kingdom;
	NewWorldHero npc;
	r = 0;
	NewWorldCityQueue &queue = rush_att ? m_citymap[cid].defender : m_citymap[cid].attacker;
	NewWorldCityQueue::iterator it=queue.begin();
	for(;it!=queue.end();++it)
	{
		++r;
		if(r <= NEW_WORLD_RUSH_MIN)
			continue;
		if(isHero(it->second))
		{
			otherseq = m_heromap[it->second].seq;
			if(!CanMove(pdata->hero[otherseq].status) ||  pdata->hero[otherseq].cid != cid || (rush_att ? (pdata->hero[otherseq].kingdom != pdata->city[cityseq].kingdom) : (pdata->hero[otherseq].kingdom == pdata->city[cityseq].kingdom)))
				continue;
		}
		else if(!pdata->city[cityseq].vision[it->second.index].index.uid || !CanMove(pdata->city[cityseq].vision[it->second.index].status) || (rush_att ? (pdata->city[cityseq].vision[it->second.index].kingdom != pdata->city[cityseq].kingdom) : (pdata->city[cityseq].vision[it->second.index].kingdom == pdata->city[cityseq].kingdom)))
			continue;
		break;
	}
	if(it == queue.end())
	{
		if(rush_att && pdata->city[cityseq].countN)
			makeNPC(npc);
		else
		{
			LOGIC_ERROR_RETURN_MSG("newworld_rush_min");
		}
	}

	NewWorldHero &attacker = rush_att ? pdata->hero[heroseq] : (it==queue.end() ? npc : (isHero(it->second) ? pdata->hero[otherseq] : pdata->city[cityseq].vision[it->second.index]));
	NewWorldHero &defender = rush_att ? (it==queue.end() ? npc : (isHero(it->second) ? pdata->hero[otherseq] : pdata->city[cityseq].vision[it->second.index])) : pdata->hero[heroseq];
	other = rush_att ? defender : attacker;

	pdata->changets = now;
	pdata->city[cityseq].ts = now;
	unsigned result = NewWorldHeroAttackResult_none;
	attacker.ts = now;
	defender.ts = now;

	int ak, dk;
	result = attacking(attacker,defender,ak,dk,getCityEffect(defender),getTowerEffect(defender));
	addKill(attacker, defender, ak, dk, now, pdata);
	addKill(defender, attacker, dk, ak, now, pdata);

	if(result == NewWorldHeroAttackResult_attacker_win)
		end = attacker;
	else if(result == NewWorldHeroAttackResult_defender_win)
		end = defender;

	for(int r=0;r<2;++r)
	{
		if((r && result == NewWorldHeroAttackResult_attacker_win)
		|| (!r && result == NewWorldHeroAttackResult_defender_win))
			continue;

		NewWorldHero &loser = r?attacker:defender;
		if(isHero(loser.index))
		{
			loser.cid = getCapital(loser.kingdom);
			loser.status = NewWorldHeroStatus_wait_defence;
			/*20141114 change countN*/
			if(loser.kingdom)
			{
				--pdata->city[cityseq].count[loser.kingdom-1];
				//debug_log("[hero die]city=%u,count%u=%d,hero=%u,%u",pdata->city[cityseq].cid,loser.kingdom,pdata->city[cityseq].count[loser.kingdom-1],loser.index.uid,loser.index.index);
				++pdata->city[m_citymap[loser.cid].city.seq].count[loser.kingdom-1];
				//debug_log("[hero home]city=%u,count%u=%d,hero=%u,%u",loser.cid,loser.kingdom,pdata->city[m_citymap[loser.cid].city.seq].count[loser.kingdom-1],loser.index.uid,loser.index.index);
			}
		}
		else if(isVision(loser.index))
		{
			--pdata->city[cityseq].countV;
			if(pdata->city[cityseq].countV >= NEW_WORLD_CITY_VISION)
			{
				pdata->city[cityseq].countV = 0;
				for(unsigned count=0;count<NEW_WORLD_CITY_VISION;++count)
				{
					if(pdata->city[cityseq].vision[count].index.uid)
						++pdata->city[cityseq].countV;
				}
			}
			/*20141114 change countN*/
			if(loser.kingdom)
				--pdata->city[cityseq].count[loser.kingdom-1];
			//debug_log("[vision die]city=%u,count%u=%d,countV=%d,hero=%u,%u",pdata->city[cityseq].cid,loser.kingdom,pdata->city[cityseq].count[loser.kingdom-1],pdata->city[cityseq].countV,loser.index.uid,loser.index.index);

			memset(&(pdata->city[cityseq].vision[loser.index.index]),0,sizeof(NewWorldHero));
		}
		else if(isNPC(loser.index))
		{
			--pdata->city[cityseq].countN;
			if(pdata->city[cityseq].countN > NEW_WORLD_BUY_NPC)
				pdata->city[cityseq].countN = 0;
		}
	}

	addKill(pdata->hero[heroseq], NEW_WORLD_KILL_ADD_RUSH, now, pdata);

	return 0;
}

int CDataNewWorld::Recover(NewWorldHeroIndex index, unsigned num)
{
	if(!num)
		return 0;

	checkTick();

	if(!m_heromap.count(index))
		return R_ERR_DB;
	if(IsFighting(m_heromap[index].status))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_recover");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_heromap[index].seq;
	if(IsFighting(pdata->hero[seq].status))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_recover");
	}
	if(pdata->hero[seq].hp >= pdata->hero[seq].property[NewWorldProperty_hp])
	{
		LOGIC_ERROR_RETURN_MSG("newworld_full_can_not_recover");
	}

	pdata->changets = now;

	pdata->hero[seq].hp += num * NEW_WORLD_HERO_RECOVER;
	if(pdata->hero[seq].hp > pdata->hero[seq].property[NewWorldProperty_hp])
		pdata->hero[seq].hp = pdata->hero[seq].property[NewWorldProperty_hp];
	pdata->hero[seq].ts = now;

	return 0;
}

int CDataNewWorld::Explode(NewWorldHeroIndex index)
{
	checkTick();

	if(!m_heromap.count(index))
		return R_ERR_DB;
	if(IsFighting(m_heromap[index].status))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_explode");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_heromap[index].seq;
	if(IsFighting(pdata->hero[seq].status))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_fighting_can_not_explode");
	}

	pdata->changets = now;

	pdata->hero[seq].addBuff(NewWorldHeroBuff_explode);
	pdata->hero[seq].ts = now;

	return 0;
}

int CDataNewWorld::Challenge(unsigned uid, unsigned &olduid, unsigned cid, string &name, unsigned k)
{
	checkTick();

	if(!m_citymap.count(cid))
		return R_ERR_DB;

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_citymap[cid].city.seq;

	// 当城主只有一个挑战时, 这种情况将不存在
	if(pdata->city[seq].uid != olduid || pdata->city[seq].kingdom != k)
	{
		olduid = pdata->city[seq].uid;
		name = pdata->city[seq].name;
		LOGIC_ERROR_RETURN_MSG("newworld_city_too_late");
	}

	pdata->changets = now;

	for(unsigned j=0;j<NEW_WORLD_CITY;++j)
	{
		// 放弃原来的城池
		if(pdata->city[j].uid == uid)
		{
			if(isCapital(pdata->city[j].cid))
				pdata->city[j].uid = 70003;
			else if(isCore(pdata->city[j].cid))
				pdata->city[j].uid = 70002;
			else
				pdata->city[j].uid = 70001;
			memset(pdata->city[j].name,0,sizeof(pdata->city[j].name));
			pdata->city[j].name[0] = 'N';pdata->city[j].name[1] = 'P';pdata->city[j].name[2] = 'C';
			pdata->city[j].ts = now;
		}
	}

	pdata->city[seq].uid = uid;
	strncpy(pdata->city[seq].name, name.c_str(), sizeof(pdata->city[seq].name)-1);
	pdata->city[seq].lastChallengeTS = 0;
	pdata->city[seq].ts = now;

	return 0;
}


int CDataNewWorld::SetChallengeTS(unsigned cid, int set, unsigned k)
{
	checkTick();

	if(!m_citymap.count(cid))
		return R_ERR_DB;

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	if (set && (m_citymap[cid].city.lastChallengeTS > now))
	{
		error_log("the lastChallengeTS already set, lastChallengeTS: %u, now: %u", m_citymap[cid].city.lastChallengeTS, now);
		return R_ERR_LOGIC;
	}
	if(m_citymap[cid].city.kingdom != k)
		return R_ERR_LOGIC;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(NULL == pdata)
	{
		return R_ERR_DB;
	}

	CAutoLock lock(&(m_sh), true);

	unsigned cityseq = m_citymap[cid].city.seq;

	if(pdata->city[cityseq].kingdom != k)
		return R_ERR_LOGIC;

	if (set)
	{
		if (pdata->city[cityseq].lastChallengeTS > now)
		{
			return R_ERR_LOGIC;
		}
		else
		{
			pdata->city[cityseq].lastChallengeTS = now + NEW_WORLD_CHALLENGE_TIME;
		}
	}
	else
	{
		pdata->city[cityseq].lastChallengeTS = 0;
	}

	pdata->changets = now;
	pdata->city[cityseq].ts = now;

	return 0;
}


int CDataNewWorld::Collect(unsigned uid, unsigned cid, unsigned &reward)
{
	checkTick();

	if(!m_citymap.count(cid))
		return R_ERR_DB;

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_citymap[cid].city.seq;
	if(pdata->city[seq].uid != uid)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_city_not_yours");
	}
	if(!pdata->city[seq].reward)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_city_no_reward");
	}

	pdata->changets = now;

	reward = pdata->city[seq].reward;
	pdata->city[seq].reward = 0;
	pdata->city[seq].ts = now;

	return 0;
}

int CDataNewWorld::WorldReward()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	for(unsigned i=NEW_WORLD_HISTORY-1;i>0;--i)
		memcpy(pdata->history[i],pdata->history[i-1],sizeof(pdata->history[i]));
	for(unsigned j=0;j<NEW_WORLD_CITY;++j)
		pdata->history[0][j] = pdata->city[j].kingdom;

	return 0;
}
int CDataNewWorld::CityReward()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	for(unsigned j=0;j<NEW_WORLD_CITY;++j)
	{
		pdata->city[j].MakeReward();
		pdata->city[j].ts = now;
	}

	return 0;
}
int CDataNewWorld::StartMission()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	vector<unsigned> kingdomcity[3];
	unsigned kingdomcityNum[3];
	unsigned over70 = 0, less51 = 0, less52 = 0, more51 = 0, more52 = 0;
	unsigned i,j,m,n,k;
	unsigned b = Math::GetRandomInt(2);

	vector<unsigned> kingdomcity_mission[3][3];
	for(m=0;m<3;++m)
	{
		for(n=0;n<3;++n)
		{
			if(m != n)
			{
				for(k=0;k<NEW_WORLD_MISSION_CITY;++k)
				{
					unsigned cid = mission_city[m][n][k];
					if(m_citymap[cid].city.kingdom == m+1)
						kingdomcity_mission[m][n].push_back(cid);
				}
			}
		}
	}
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		if(pdata->city[j].kingdom)
		{
			if(canAttack(pdata->city[j].cid))
				kingdomcity[pdata->city[j].kingdom-1].push_back(pdata->city[j].cid);
		}
	}
	for(i=0;i<3;++i)
	{
		kingdomcityNum[i] = kingdomcity[i].size();
		if(kingdomcityNum[i] + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE > 70)
			over70 = i + 1;
		else if(kingdomcityNum[i] < 5)
		{
			if(less51)
				less52 = i + 1;
			else
				less51 = i + 1;
		}
		else
		{
			if(more51)
				more52 = i + 1;
			else
				more51 = i + 1;
		}
	}

	if(over70)//2vs1, 2attack, 2defend, 2defend with out attack
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[over70-1]);
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[over70-1]);
		if(a1 == a2)
		{
			a2 = a1 + 1;
			if(a2 == kingdomcityNum[over70-1])
				a2 = a1 - 1;
		}
		a1 = kingdomcity[over70-1][a1];
		a2 = kingdomcity[over70-1][a2];

		pdata->mission[over70-1].defend = a1;
		pdata->mission[over70-1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[over70-1].attack = a2;
		pdata->mission[over70-1].attackStatus = NewWorldMissonStatus_defending;

		if(less51 && less52)
		{
			pdata->mission[less51-1].attack = a1;
			pdata->mission[less51-1].attackStatus = NewWorldMissonStatus_attacking;
			pdata->mission[less52-1].attack = a2;
			pdata->mission[less52-1].attackStatus = NewWorldMissonStatus_attacking;

			unsigned d1 = 0;
			if(kingdomcityNum[less51-1] == 0)
				d1 = getCapital(less51);
			else
			{
				d1 = Math::GetRandomInt(kingdomcityNum[less51-1]);
				d1 = kingdomcity[less51-1][d1];
			}
			unsigned d2 = 0;
			if(kingdomcityNum[less52-1] == 0)
				d2 = getCapital(less52);
			else
			{
				d2 = Math::GetRandomInt(kingdomcityNum[less52-1]);
				d2 = kingdomcity[less52-1][d2];
			}

			pdata->mission[less51-1].defend = d1;
			pdata->mission[less51-1].defendStatus = NewWorldMissonStatus_defending;
			pdata->mission[less52-1].defend = d2;
			pdata->mission[less52-1].defendStatus = NewWorldMissonStatus_defending;
		}
		else if(more51 && more52)
		{
			pdata->mission[more51-1].attack = a1;
			pdata->mission[more51-1].attackStatus = NewWorldMissonStatus_attacking;
			pdata->mission[more52-1].attack = a2;
			pdata->mission[more52-1].attackStatus = NewWorldMissonStatus_attacking;

			unsigned d1 = Math::GetRandomInt(kingdomcityNum[more51-1]);
			unsigned d2 = Math::GetRandomInt(kingdomcityNum[more52-1]);
			d1 = kingdomcity[more51-1][d1];
			d2 = kingdomcity[more52-1][d2];

			pdata->mission[more51-1].defend = d1;
			pdata->mission[more51-1].defendStatus = NewWorldMissonStatus_defending;
			pdata->mission[more52-1].defend = d2;
			pdata->mission[more52-1].defendStatus = NewWorldMissonStatus_defending;
		}
		else//more51 && less51
		{
			pdata->mission[more51-1].attack = a1;
			pdata->mission[more51-1].attackStatus = NewWorldMissonStatus_attacking;
			pdata->mission[less51-1].attack = a2;
			pdata->mission[less51-1].attackStatus = NewWorldMissonStatus_attacking;

			unsigned d1 = 0;
			if(kingdomcityNum[less51-1] == 0)
				d1 = getCapital(less51);
			else
			{
				d1 = Math::GetRandomInt(kingdomcityNum[less51-1]);
				d1 = kingdomcity[less51-1][d1];
			}
			unsigned d2 = Math::GetRandomInt(kingdomcityNum[more51-1]);
			d2 = kingdomcity[more51-1][d2];

			pdata->mission[less51-1].defend = d1;
			pdata->mission[less51-1].defendStatus = NewWorldMissonStatus_defending;
			pdata->mission[more51-1].defend = d2;
			pdata->mission[more51-1].defendStatus = NewWorldMissonStatus_defending;
		}
	}
	else if(less51)//2vs1, 1attack, 2attack with same defend, 1defend, 1defend with out attack, 1defend with 2attack
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[more51-1]);
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[more52-1]);
		unsigned d1 = 0;
		if(kingdomcityNum[less51-1] == 0)
			d1 = getCapital(less51);
		else
		{
			d1 = Math::GetRandomInt(kingdomcityNum[less51-1]);
			d1 = kingdomcity[less51-1][d1];
		}
		a1 = kingdomcity[more51-1][a1];
		a2 = kingdomcity[more52-1][a2];

		pdata->mission[more51-1].defend = a1;
		pdata->mission[more51-1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[more51-1].attack = a2;
		pdata->mission[more51-1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[more52-1].defend = a2;
		pdata->mission[more52-1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[more52-1].attack = a1;
		pdata->mission[more52-1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[less51-1].defend = d1;
		pdata->mission[less51-1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[less51-1].attack = kingdomcityNum[more51-1]>kingdomcityNum[more52-1]?a1:a2;
		pdata->mission[less51-1].attackStatus = NewWorldMissonStatus_attacking;
	}
	else//turn, 3attack, 3defend
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[0]);
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[1]);
		unsigned a3 = Math::GetRandomInt(kingdomcityNum[2]);
		a1 = kingdomcity[0][a1];
		a2 = kingdomcity[1][a2];
		a3 = kingdomcity[2][a3];

		pdata->mission[0].defend = a1;
		pdata->mission[0].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[0].attack = b?a2:a3;
		pdata->mission[0].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[1].defend = a2;
		pdata->mission[1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[1].attack = b?a3:a1;
		pdata->mission[1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[2].defend = a3;
		pdata->mission[2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[2].attack = b?a1:a2;
		pdata->mission[2].attackStatus = NewWorldMissonStatus_attacking;
	}

	if(over70)//over70 <-- dk, ak
	{
		unsigned dk = 0, ak = 0;
		if(less51 && less52)
		{
			dk = less51;
			ak = less52;
		}
		else if(more51 && more52)
		{
			dk = more51;
			ak = more52;
		}
		else//more51 && less51
		{
			dk = more51;
			ak = less51;
		}
		if(kingdomcity_mission[over70-1][dk-1].size())
		{
			pdata->mission[over70-1].defend = pdata->mission[dk-1].attack
					= kingdomcity_mission[over70-1][dk-1][Math::GetRandomInt(kingdomcity_mission[over70-1][dk-1].size())];
			//debug_log("mission city changed %u",pdata->mission[over70-1].defend);
		}
		if(kingdomcity_mission[over70-1][ak-1].size())
		{
			pdata->mission[over70-1].attack = pdata->mission[ak-1].attack
					= kingdomcity_mission[over70-1][ak-1][Math::GetRandomInt(kingdomcity_mission[over70-1][ak-1].size())];
			//debug_log("mission city changed %u",pdata->mission[over70-1].attack);
		}
	}
	else if(less51)//more51 <--> more52
	{
		if(kingdomcity_mission[more51-1][more52-1].size())
		{
			pdata->mission[more51-1].defend = pdata->mission[more52-1].attack
					= kingdomcity_mission[more51-1][more52-1][Math::GetRandomInt(kingdomcity_mission[more51-1][more52-1].size())];
			//debug_log("mission city changed %u",pdata->mission[more51-1].defend);
		}
		if(kingdomcity_mission[more52-1][more51-1].size())
		{
			pdata->mission[more52-1].defend = pdata->mission[more51-1].attack
					= kingdomcity_mission[more52-1][more51-1][Math::GetRandomInt(kingdomcity_mission[more52-1][more51-1].size())];
			//debug_log("mission city changed %u",pdata->mission[more52-1].defend);
		}
		pdata->mission[less51-1].attack	= kingdomcityNum[more51-1]>kingdomcityNum[more52-1]
		    ?pdata->mission[more51-1].defend:pdata->mission[more52-1].defend;
	}
	else//b? 1 --> 2 --> 3 --> 1 : 1 --> 3 --> 2 --> 1
	{
		if(b)
		{
			if(kingdomcity_mission[0][2].size())
			{
				pdata->mission[0].defend = pdata->mission[2].attack
						= kingdomcity_mission[0][2][Math::GetRandomInt(kingdomcity_mission[0][2].size())];
				//debug_log("mission city changed %u",pdata->mission[0].defend);
			}
			if(kingdomcity_mission[1][0].size())
			{
				pdata->mission[1].defend = pdata->mission[0].attack
						= kingdomcity_mission[1][0][Math::GetRandomInt(kingdomcity_mission[1][0].size())];
				//debug_log("mission city changed %u",pdata->mission[1].defend);
			}
			if(kingdomcity_mission[2][1].size())
			{
				pdata->mission[2].defend = pdata->mission[1].attack
						= kingdomcity_mission[2][1][Math::GetRandomInt(kingdomcity_mission[2][1].size())];
				//debug_log("mission city changed %u",pdata->mission[2].defend);
			}
		}
		else
		{
			if(kingdomcity_mission[0][1].size())
			{
				pdata->mission[0].defend = pdata->mission[1].attack
						= kingdomcity_mission[0][1][Math::GetRandomInt(kingdomcity_mission[0][1].size())];
				//debug_log("mission city changed %u",pdata->mission[0].defend);
			}
			if(kingdomcity_mission[1][2].size())
			{
				pdata->mission[1].defend = pdata->mission[2].attack
						= kingdomcity_mission[1][2][Math::GetRandomInt(kingdomcity_mission[1][2].size())];
				//debug_log("mission city changed %u",pdata->mission[1].defend);
			}
			if(kingdomcity_mission[2][0].size())
			{
				pdata->mission[2].defend = pdata->mission[0].attack
						= kingdomcity_mission[2][0][Math::GetRandomInt(kingdomcity_mission[2][0].size())];
				//debug_log("mission city changed %u",pdata->mission[2].defend);
			}
		}
	}

	for(unsigned i=0;i<3;++i)
	{
		unsigned seqa = m_citymap[pdata->mission[i].attack].city.seq;
		pdata->city[seqa].countN = max(pdata->city[seqa].countN, NEW_WORLD_CITY_NPC);
		pdata->city[seqa].ts = now;
		unsigned seqd = m_citymap[pdata->mission[i].defend].city.seq;
		pdata->city[seqd].countN = max(pdata->city[seqd].countN, NEW_WORLD_CITY_NPC);
		pdata->city[seqd].ts = now;
	}

	return 0;
}
int CDataNewWorld::StartMission1()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	vector<unsigned> kingdomcity[3];
	unsigned kingdomcityNum[3];
	unsigned r1 = 0, r2 = 0, r3 = 0;
	unsigned i,j,m,n,k;
	unsigned b = Math::GetRandomInt(2);

	vector<unsigned> kingdomcity_mission[3][3];
	for(m=0;m<3;++m)
	{
		for(n=0;n<3;++n)
		{
			if(m != n)
			{
				for(k=0;k<NEW_WORLD_MISSION_CITY;++k)
				{
					unsigned cid = mission_city[m][n][k];
					if(m_citymap[cid].city.kingdom == m+1)
						kingdomcity_mission[m][n].push_back(cid);
				}
			}
		}
	}
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		if(pdata->city[j].kingdom)
		{
			if(canAttack(pdata->city[j].cid))
				kingdomcity[pdata->city[j].kingdom-1].push_back(pdata->city[j].cid);
		}
	}
	map<pair<unsigned, unsigned>, unsigned> temp;
	for(i=0;i<3;++i)
	{
		kingdomcityNum[i] = kingdomcity[i].size();
		temp[pair<unsigned, unsigned>(kingdomcityNum[i], i)] = i;
	}
	map<pair<unsigned, unsigned>, unsigned>::iterator it = temp.begin();
	r3 = it->second;
	++it;
	r2 = it->second;
	++it;
	r1 = it->second;

	if(kingdomcityNum[r3] == 0 && kingdomcityNum[r2] == 0)//2vs1, 2attack, 2defend, 2defend with out attack
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[r1]);
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[r1]);
		if(a1 == a2)
		{
			a2 = a1 + 1;
			if(a2 == kingdomcityNum[r1])
				a2 = a1 - 1;
		}
		a1 = kingdomcity[r1][a1];
		a2 = kingdomcity[r1][a2];

		pdata->mission[r1].defend = a1;
		pdata->mission[r1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r1].attack = a2;
		pdata->mission[r1].attackStatus = NewWorldMissonStatus_defending;

		pdata->mission[r2].attack = a1;
		pdata->mission[r2].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r3].attack = a2;
		pdata->mission[r3].attackStatus = NewWorldMissonStatus_attacking;

		unsigned d1 = getCapital(r2+1);
		unsigned d2 = getCapital(r3+1);
		pdata->mission[r2].defend = d1;
		pdata->mission[r2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r3].defend = d2;
		pdata->mission[r3].defendStatus = NewWorldMissonStatus_defending;
	}
	else if(kingdomcityNum[r3] == 0)//2vs1, 1attack, 2attack with same defend, 1defend, 1defend with out attack, 1defend with 2attack
	{
		unsigned a0 = Math::GetRandomInt(kingdomcityNum[r1]);
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[r1]);
		if(a1 == a0)
		{
			a0 = a1 + 1;
			if(a0 == kingdomcityNum[r1])
				a0 = a1 - 1;
		}
		a1 = kingdomcity[r1][a1];
		a0 = kingdomcity[r1][a0];
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[r2]);
		a2 = kingdomcity[r2][a2];
		unsigned d1 = getCapital(r3+1);

		pdata->mission[r1].defend = a1;
		pdata->mission[r1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r1].attack = a2;
		pdata->mission[r1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r2].defend = a2;
		pdata->mission[r2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r2].attack = a1;
		pdata->mission[r2].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r3].defend = d1;
		pdata->mission[r3].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r3].attack = a0;
		pdata->mission[r3].attackStatus = NewWorldMissonStatus_attacking;
	}
	else//turn, 3attack, 3defend
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[0]);
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[1]);
		unsigned a3 = Math::GetRandomInt(kingdomcityNum[2]);
		a1 = kingdomcity[0][a1];
		a2 = kingdomcity[1][a2];
		a3 = kingdomcity[2][a3];

		pdata->mission[0].defend = a1;
		pdata->mission[0].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[0].attack = b?a2:a3;
		pdata->mission[0].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[1].defend = a2;
		pdata->mission[1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[1].attack = b?a3:a1;
		pdata->mission[1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[2].defend = a3;
		pdata->mission[2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[2].attack = b?a1:a2;
		pdata->mission[2].attackStatus = NewWorldMissonStatus_attacking;
	}

	if(kingdomcityNum[r3] == 0 && kingdomcityNum[r2] == 0)//r3 --> r1 <-- r2
	{
		if(kingdomcity_mission[r1][r2].size())
		{
			pdata->mission[r1].defend = pdata->mission[r2].attack = (r2 + 1) * 100 + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE + 1;
					//= kingdomcity_mission[r1][r2][Math::GetRandomInt(kingdomcity_mission[r1][r2].size())];
			//debug_log("mission city changed %u",pdata->mission[r1].defend);
		}
		if(kingdomcity_mission[r1][r3].size())
		{
			pdata->mission[r1].attack = pdata->mission[r3].attack = (r3 + 1) * 100 + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE + 1;
					//= kingdomcity_mission[r1][r3][Math::GetRandomInt(kingdomcity_mission[r1][r3].size())];
			//debug_log("mission city changed %u",pdata->mission[r1].attack);
		}
	}
	else if(kingdomcityNum[r3] == 0)//r3 --> r1 <--> r2
	{
		if(kingdomcity_mission[r1][r2].size())
		{
			pdata->mission[r1].defend = pdata->mission[r2].attack
					= kingdomcity_mission[r1][r2][Math::GetRandomInt(kingdomcity_mission[r1][r2].size())];
			//debug_log("mission city changed %u",pdata->mission[r1].defend);
		}
		if(kingdomcity_mission[r2][r1].size())
		{
			pdata->mission[r2].defend = pdata->mission[r1].attack
					= kingdomcity_mission[r2][r1][Math::GetRandomInt(kingdomcity_mission[r2][r1].size())];
			//debug_log("mission city changed %u",pdata->mission[r2].defend);
		}
		if(kingdomcity_mission[r1][r3].size())
		{
			pdata->mission[r3].attack = (r3 + 1) * 100 + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE + 1;
				//= kingdomcity_mission[r1][r3][Math::GetRandomInt(kingdomcity_mission[r1][r3].size())];
			//debug_log("mission city changed %u",pdata->mission[r3].defend);
		}
	}
	else//b? 1 --> 2 --> 3 --> 1 : 1 --> 3 --> 2 --> 1
	{
		if(b)
		{
			if(kingdomcity_mission[0][2].size())
			{
				pdata->mission[0].defend = pdata->mission[2].attack
						= kingdomcity_mission[0][2][Math::GetRandomInt(kingdomcity_mission[0][2].size())];
				//debug_log("mission city changed %u",pdata->mission[0].defend);
			}
			if(kingdomcity_mission[1][0].size())
			{
				pdata->mission[1].defend = pdata->mission[0].attack
						= kingdomcity_mission[1][0][Math::GetRandomInt(kingdomcity_mission[1][0].size())];
				//debug_log("mission city changed %u",pdata->mission[1].defend);
			}
			if(kingdomcity_mission[2][1].size())
			{
				pdata->mission[2].defend = pdata->mission[1].attack
						= kingdomcity_mission[2][1][Math::GetRandomInt(kingdomcity_mission[2][1].size())];
				//debug_log("mission city changed %u",pdata->mission[2].defend);
			}
		}
		else
		{
			if(kingdomcity_mission[0][1].size())
			{
				pdata->mission[0].defend = pdata->mission[1].attack
						= kingdomcity_mission[0][1][Math::GetRandomInt(kingdomcity_mission[0][1].size())];
				//debug_log("mission city changed %u",pdata->mission[0].defend);
			}
			if(kingdomcity_mission[1][2].size())
			{
				pdata->mission[1].defend = pdata->mission[2].attack
						= kingdomcity_mission[1][2][Math::GetRandomInt(kingdomcity_mission[1][2].size())];
				//debug_log("mission city changed %u",pdata->mission[1].defend);
			}
			if(kingdomcity_mission[2][0].size())
			{
				pdata->mission[2].defend = pdata->mission[0].attack
						= kingdomcity_mission[2][0][Math::GetRandomInt(kingdomcity_mission[2][0].size())];
				//debug_log("mission city changed %u",pdata->mission[2].defend);
			}
		}
	}

	for(unsigned i=0;i<3;++i)
	{
		unsigned seqa = m_citymap[pdata->mission[i].attack].city.seq;
		pdata->city[seqa].countN = max(pdata->city[seqa].countN, NEW_WORLD_CITY_NPC);
		pdata->city[seqa].ts = now;
		unsigned seqd = m_citymap[pdata->mission[i].defend].city.seq;
		pdata->city[seqd].countN = max(pdata->city[seqd].countN, NEW_WORLD_CITY_NPC);
		pdata->city[seqd].ts = now;
	}

	return 0;
}
int CDataNewWorld::StartMission2()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	vector<unsigned> kingdomcity[3];
	unsigned kingdomcityNum[3];
	unsigned r1 = 0, r2 = 0, r3 = 0;
	unsigned i,j,m,n,k;
	unsigned b = Math::GetRandomInt(2);

	vector<unsigned> kingdomcity_mission1[3][3];
	for(m=0;m<3;++m)
	{
		for(n=0;n<3;++n)
		{
			if(m != n)
			{
				for(k=NEW_WORLD_CITY_CAPITAL+NEW_WORLD_CITY_KINGDOM_CORE+1;k<=NEW_WORLD_CITY_KINGDOM;++k)
				{
					unsigned cid = (n + 1) * NEW_WORLD_CITY_KINGDOM_SEQ + k;
					if(m_citymap[cid].city.kingdom == m+1)
						kingdomcity_mission1[m][n].push_back(cid);
				}
			}
		}
	}
	vector<unsigned> kingdomcity_mission[3][3];
	for(m=0;m<3;++m)
	{
		for(n=0;n<3;++n)
		{
			if(m != n)
			{
				for(k=0;k<NEW_WORLD_MISSION_CITY;++k)
				{
					unsigned cid = mission_city[m][n][k];
					if(m_citymap[cid].city.kingdom == m+1)
						kingdomcity_mission[m][n].push_back(cid);
				}
			}
		}
	}
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		if(pdata->city[j].kingdom)
		{
			if(canAttack(pdata->city[j].cid))
				kingdomcity[pdata->city[j].kingdom-1].push_back(pdata->city[j].cid);
		}
	}
	map<pair<unsigned, unsigned>, unsigned> temp;
	for(i=0;i<3;++i)
	{
		kingdomcityNum[i] = kingdomcity[i].size();
		temp[pair<unsigned, unsigned>(kingdomcityNum[i], i)] = i;
	}
	map<pair<unsigned, unsigned>, unsigned>::iterator it = temp.begin();
	r3 = it->second;
	++it;
	r2 = it->second;
	++it;
	r1 = it->second;

	if(kingdomcityNum[r3] == 0 && kingdomcityNum[r2] == 0)//2vs1, 2attack, 2defend, 2defend with out attack
	{
		pdata->mission[r1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r1].attackStatus = NewWorldMissonStatus_defending;
		pdata->mission[r2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r2].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r3].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r3].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r1].defend = pdata->mission[r2].attack = (r2 + 1) * 100 + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE + 1;
		pdata->mission[r1].attack = pdata->mission[r3].attack = (r3 + 1) * 100 + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE + 1;
		pdata->mission[r2].defend = getCapital(r2+1);
		pdata->mission[r3].defend = getCapital(r3+1);
	}
	else if(kingdomcityNum[r3] == 0)//2vs1, 1attack, 2attack with same defend, 1defend, 1defend with out attack, 1defend with 2attack
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[r1]);
		a1 = kingdomcity[r1][a1];
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[r2]);
		a2 = kingdomcity[r2][a2];

		pdata->mission[r1].defend = a1;
		pdata->mission[r1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r1].attack = a2;
		pdata->mission[r1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r2].defend = a2;
		pdata->mission[r2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r2].attack = a1;
		pdata->mission[r2].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[r3].defend = getCapital(r3+1);
		pdata->mission[r3].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[r3].attack = (r3 + 1) * 100 + NEW_WORLD_CITY_CAPITAL + NEW_WORLD_CITY_KINGDOM_CORE + 1;
		pdata->mission[r3].attackStatus = NewWorldMissonStatus_attacking;
	}
	else//turn, 3attack, 3defend
	{
		unsigned a1 = Math::GetRandomInt(kingdomcityNum[0]);
		unsigned a2 = Math::GetRandomInt(kingdomcityNum[1]);
		unsigned a3 = Math::GetRandomInt(kingdomcityNum[2]);
		a1 = kingdomcity[0][a1];
		a2 = kingdomcity[1][a2];
		a3 = kingdomcity[2][a3];

		pdata->mission[0].defend = a1;
		pdata->mission[0].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[0].attack = b?a2:a3;
		pdata->mission[0].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[1].defend = a2;
		pdata->mission[1].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[1].attack = b?a3:a1;
		pdata->mission[1].attackStatus = NewWorldMissonStatus_attacking;
		pdata->mission[2].defend = a3;
		pdata->mission[2].defendStatus = NewWorldMissonStatus_defending;
		pdata->mission[2].attack = b?a1:a2;
		pdata->mission[2].attackStatus = NewWorldMissonStatus_attacking;
	}

	if(kingdomcityNum[r3] == 0)//r3 --> r1 <--> r2
	{
		if(kingdomcity_mission1[r1][r2].size())
		{
			pdata->mission[r1].defend = pdata->mission[r2].attack
					= kingdomcity_mission1[r1][r2][Math::GetRandomInt(kingdomcity_mission1[r1][r2].size())];
		}
		else if(kingdomcity_mission[r1][r2].size())
		{
			pdata->mission[r1].defend = pdata->mission[r2].attack
					= kingdomcity_mission[r1][r2][Math::GetRandomInt(kingdomcity_mission[r1][r2].size())];
		}

		if(kingdomcity_mission1[r2][r1].size())
		{
			pdata->mission[r2].defend = pdata->mission[r1].attack
					= kingdomcity_mission1[r2][r1][Math::GetRandomInt(kingdomcity_mission1[r2][r1].size())];
		}
		else if(kingdomcity_mission[r2][r1].size())
		{
			pdata->mission[r2].defend = pdata->mission[r1].attack
					= kingdomcity_mission[r2][r1][Math::GetRandomInt(kingdomcity_mission[r2][r1].size())];
		}
	}
	else//b? 1 --> 2 --> 3 --> 1 : 1 --> 3 --> 2 --> 1
	{
		if(b)
		{
			if(kingdomcity_mission1[0][2].size())
			{
				pdata->mission[0].defend = pdata->mission[2].attack
						= kingdomcity_mission1[0][2][Math::GetRandomInt(kingdomcity_mission1[0][2].size())];
			}
			else if(kingdomcity_mission[0][2].size())
			{
				pdata->mission[0].defend = pdata->mission[2].attack
						= kingdomcity_mission[0][2][Math::GetRandomInt(kingdomcity_mission[0][2].size())];
			}

			if(kingdomcity_mission1[1][0].size())
			{
				pdata->mission[1].defend = pdata->mission[0].attack
						= kingdomcity_mission1[1][0][Math::GetRandomInt(kingdomcity_mission1[1][0].size())];
			}
			else if(kingdomcity_mission[1][0].size())
			{
				pdata->mission[1].defend = pdata->mission[0].attack
						= kingdomcity_mission[1][0][Math::GetRandomInt(kingdomcity_mission[1][0].size())];
			}

			if(kingdomcity_mission1[2][1].size())
			{
				pdata->mission[2].defend = pdata->mission[1].attack
						= kingdomcity_mission1[2][1][Math::GetRandomInt(kingdomcity_mission1[2][1].size())];
			}
			else if(kingdomcity_mission[2][1].size())
			{
				pdata->mission[2].defend = pdata->mission[1].attack
						= kingdomcity_mission[2][1][Math::GetRandomInt(kingdomcity_mission[2][1].size())];
			}
		}
		else
		{
			if(kingdomcity_mission1[0][1].size())
			{
				pdata->mission[0].defend = pdata->mission[1].attack
						= kingdomcity_mission1[0][1][Math::GetRandomInt(kingdomcity_mission1[0][1].size())];
			}
			else if(kingdomcity_mission[0][1].size())
			{
				pdata->mission[0].defend = pdata->mission[1].attack
						= kingdomcity_mission[0][1][Math::GetRandomInt(kingdomcity_mission[0][1].size())];
			}

			if(kingdomcity_mission1[1][2].size())
			{
				pdata->mission[1].defend = pdata->mission[2].attack
						= kingdomcity_mission1[1][2][Math::GetRandomInt(kingdomcity_mission1[1][2].size())];
			}
			else if(kingdomcity_mission[1][2].size())
			{
				pdata->mission[1].defend = pdata->mission[2].attack
						= kingdomcity_mission[1][2][Math::GetRandomInt(kingdomcity_mission[1][2].size())];
			}

			if(kingdomcity_mission1[2][0].size())
			{
				pdata->mission[2].defend = pdata->mission[0].attack
						= kingdomcity_mission1[2][0][Math::GetRandomInt(kingdomcity_mission1[2][0].size())];
			}
			else if(kingdomcity_mission[2][0].size())
			{
				pdata->mission[2].defend = pdata->mission[0].attack
						= kingdomcity_mission[2][0][Math::GetRandomInt(kingdomcity_mission[2][0].size())];
			}
		}
	}

	for(unsigned i=0;i<3;++i)
	{
		unsigned seqa = m_citymap[pdata->mission[i].attack].city.seq;
		pdata->city[seqa].countN = max(pdata->city[seqa].countN, NEW_WORLD_CITY_NPC);
		pdata->city[seqa].ts = now;
		unsigned seqd = m_citymap[pdata->mission[i].defend].city.seq;
		pdata->city[seqd].countN = max(pdata->city[seqd].countN, NEW_WORLD_CITY_NPC);
		pdata->city[seqd].ts = now;
	}

	return 0;
}
int CDataNewWorld::EndMission()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	for(unsigned i=0;i<3;++i)
	{
		switch(pdata->mission[i].attackStatus)
		{
		case NewWorldMissonStatus_attacking:
			pdata->mission[i].attackStatus = NewWorldMissonStatus_attack_lose;
			break;
		case NewWorldMissonStatus_attack_over:
			pdata->mission[i].attackStatus = NewWorldMissonStatus_attack_win;
			break;
		case NewWorldMissonStatus_attack_fast_over:
			pdata->mission[i].attackStatus = NewWorldMissonStatus_attack_fast_win;
			break;
		case NewWorldMissonStatus_defending:
			pdata->mission[i].attackStatus = NewWorldMissonStatus_defend_win;
			break;
		case NewWorldMissonStatus_defend_over:
			pdata->mission[i].attackStatus = NewWorldMissonStatus_defend_lose;
			break;
		}
		switch(pdata->mission[i].defendStatus)
		{
		case NewWorldMissonStatus_attacking:
			pdata->mission[i].defendStatus = NewWorldMissonStatus_attack_lose;
			break;
		case NewWorldMissonStatus_attack_over:
			pdata->mission[i].defendStatus = NewWorldMissonStatus_attack_win;
			break;
		case NewWorldMissonStatus_attack_fast_over:
			pdata->mission[i].defendStatus = NewWorldMissonStatus_attack_fast_win;
			break;
		case NewWorldMissonStatus_defending:
			pdata->mission[i].defendStatus = NewWorldMissonStatus_defend_win;
			break;
		case NewWorldMissonStatus_defend_over:
			pdata->mission[i].defendStatus = NewWorldMissonStatus_defend_lose;
			break;
		}
	}

	return 0;
}

int CDataNewWorld::KillReward()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;

	for(unsigned j=0;j<pdata->count;++j)
	{
		if(pdata->hero[j].kill)
		{
			pdata->hero[j].kill = 0;
			pdata->hero[j].ts = now;
			pdata->hero[j].inc_kill = 0;
		}
	}

	return 0;
}

int CDataNewWorld::sync(DataNewWorld *pdata)
{
	m_count = pdata->count;
	m_ts = pdata->ts;
	memcpy(m_history,pdata->history,sizeof(m_history));
	memcpy(m_mission,pdata->mission,sizeof(m_mission));
	memset(m_kingdomcityNum, 0 , sizeof(m_kingdomcityNum));
	for(unsigned i=0;i<NEW_WORLD_CITY;++i)
	{
		if(pdata->city[i].kingdom)
			++m_kingdomcityNum[pdata->city[i].kingdom - 1];
		unsigned cid = pdata->city[i].cid;
		if(m_citymap[cid].city.ts != pdata->city[i].ts)
		{
			//debug_log("[sync city]cid=%u",pdata->city[i].cid);
			m_citymap[cid].city = pdata->city[i];
			m_citymap[cid].attacker.clear();
			m_citymap[cid].defender.clear();

			if(canAttack(cid) && pdata->city[i].Fighting())
			{
				//debug_log("[sync queue]cid=%u",pdata->city[i].cid);
				if(pdata->city[i].countV)
				{
					for(unsigned idata=0;idata<NEW_WORLD_CITY_VISION;++idata)
					{
						if(pdata->city[i].vision[idata].index.uid && IsReady(pdata->city[i].vision[idata].status))
						{
							pair<pair<unsigned, unsigned>, NewWorldHeroIndex> queue(pair<unsigned, unsigned>(pdata->city[i].vision[idata].next,pdata->city[i].vision[idata].index.index),pdata->city[i].vision[idata].index);
							if(IsDefender(pdata->city[i].vision[idata].status))
								m_citymap[cid].defender.insert(queue);
							else if(IsAttacker(pdata->city[i].vision[idata].status))
								m_citymap[cid].attacker.insert(queue);
						}
					}
				}
			}
		}
	}
	for(unsigned j=0;j<pdata->count;++j)
	{
		NewWorldHeroIndex index = pdata->hero[j].index;
		if(m_heromap[index].ts != pdata->hero[j].ts)
			m_heromap[index] = pdata->hero[j];

		unsigned cid = pdata->hero[j].cid;
		if(m_citymap[cid].city.Fighting()
		&& canAttack(cid)
		&& IsReady(pdata->hero[j].status))
		{
			pair<pair<unsigned, unsigned>, NewWorldHeroIndex> queue(pair<unsigned, unsigned>(pdata->hero[j].next,pdata->hero[j].seq),index);
			if(IsDefender(pdata->hero[j].status))
			{
				//debug_log("[defend queue]city=%u,hero=%u,%u",cid,pdata->hero[j].index.uid,pdata->hero[j].index.index);
				m_citymap[cid].defender.insert(queue);
			}
			else if(IsAttacker(pdata->hero[j].status))
			{
				//debug_log("[attack queue]city=%u,hero=%u,%u",cid,pdata->hero[j].index.uid,pdata->hero[j].index.index);
				m_citymap[cid].attacker.insert(queue);
			}
			else
			{
				if(m_citymap[cid].city.kingdom == pdata->hero[j].kingdom)
				{
					//debug_log("[defend queue]city=%u,hero=%u,%u",cid,pdata->hero[j].index.uid,pdata->hero[j].index.index);
					m_citymap[cid].defender.insert(queue);
				}
				else
				{
					//debug_log("[attack queue]city=%u,hero=%u,%u",cid,pdata->hero[j].index.uid,pdata->hero[j].index.index);
					m_citymap[cid].attacker.insert(queue);
				}
			}
		}
	}

	return 0;
}

int CDataNewWorld::checkTick()
{
	//check tick first for sync
	unsigned now = Time::GetGlobalTime();
	if(now < m_ts + NEW_WORLD_TICK)
		return 0;

	m_battlechange.clear();
	set<unsigned> changeset;
	set<pair<unsigned, unsigned> > occupyset;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata)
	{
		CAutoLock lock(&(m_sh), true);

		//check tick again for lock
		if(now < pdata->ts + NEW_WORLD_TICK)
		{
			//debug_log("sync only ts=%u->%u,%u",m_ts,pdata->ts,pdata->changets);
			if(m_ts < pdata->changets || pdata->ts == pdata->changets || now < pdata->changets)
				sync(pdata);
			else
				m_ts = pdata->ts;
			return 0;
		}
		else if(m_ts != pdata->ts)
		{
			//debug_log("sync before ts=%u->%u,%u",m_ts,pdata->ts,pdata->changets);
			if(m_ts < pdata->changets || m_ts > pdata->ts)
				sync(pdata);
			else
				m_ts = pdata->ts;
		}

		//tick
		while(now >= pdata->ts + NEW_WORLD_TICK)
		{
			bool bugflag = false;
			//city
			for(unsigned i=0;i<NEW_WORLD_CITY;++i)
			{
				if(pdata->city[i].bug())
					bugflag = true;

				if(!canAttack(pdata->city[i].cid))
					continue;

				unsigned result = NewWorldHeroAttackResult_none;
			//stage 1. attack : hero:hp,cid,status; city:attacker,defender, vision:hp, count123, countN, countV
				if(pdata->city[i].attacker.uid && pdata->city[i].defender.uid)
				{
					pdata->changets = pdata->ts + NEW_WORLD_TICK;
					pdata->city[i].ts = pdata->ts + NEW_WORLD_TICK;

					NewWorldHero &attacker = isHero(pdata->city[i].attacker)?
							pdata->hero[m_heromap[pdata->city[i].attacker].seq]:
							pdata->city[i].vision[pdata->city[i].attacker.index];
					NewWorldHero &defender = isHero(pdata->city[i].defender)?
							pdata->hero[m_heromap[pdata->city[i].defender].seq]:
							pdata->city[i].vision[pdata->city[i].defender.index];

					attacker.ts = pdata->ts + NEW_WORLD_TICK;
					defender.ts = pdata->ts + NEW_WORLD_TICK;
					int ak, dk;
					result = attacking(attacker,defender,ak,dk,getCityEffect(defender),getTowerEffect(defender));
					addKill(attacker, defender, ak, dk, pdata->ts + NEW_WORLD_TICK, pdata);
					addKill(defender, attacker, dk, ak, pdata->ts + NEW_WORLD_TICK, pdata);

					for(int r=0;r<2;++r)
					{
						if((r && result == NewWorldHeroAttackResult_attacker_win)
						|| (!r && result == NewWorldHeroAttackResult_defender_win))
							continue;

						if(r)
							pdata->city[i].attacker.clear();
						else
							pdata->city[i].defender.clear();

						NewWorldHero &loser = r?attacker:defender;
						if(isHero(loser.index))
						{
							loser.cid = getCapital(loser.kingdom);
							loser.status = NewWorldHeroStatus_wait_defence;
							/*20141114 change countN*/
							if(loser.kingdom)
							{
								--pdata->city[i].count[loser.kingdom-1];
								//debug_log("[hero die]city=%u,count%u=%d,hero=%u,%u",pdata->city[i].cid,loser.kingdom,pdata->city[i].count[loser.kingdom-1],loser.index.uid,loser.index.index);
								++pdata->city[m_citymap[loser.cid].city.seq].count[loser.kingdom-1];
								//debug_log("[hero home]city=%u,count%u=%d,hero=%u,%u",loser.cid,loser.kingdom,pdata->city[m_citymap[loser.cid].city.seq].count[loser.kingdom-1],loser.index.uid,loser.index.index);
							}
						}
						else if(isVision(loser.index))
						{
							--pdata->city[i].countV;
							if(pdata->city[i].countV >= NEW_WORLD_CITY_VISION)
							{
								pdata->city[i].countV = 0;
								for(unsigned count=0;count<NEW_WORLD_CITY_VISION;++count)
								{
									if(pdata->city[i].vision[count].index.uid)
										++pdata->city[i].countV;
								}
							}
							/*20141114 change countN*/
							if(loser.kingdom)
								--pdata->city[i].count[loser.kingdom-1];
							//debug_log("[vision die]city=%u,count%u=%d,countV=%d,hero=%u,%u",pdata->city[i].cid,loser.kingdom,pdata->city[i].count[loser.kingdom-1],pdata->city[i].countV,loser.index.uid,loser.index.index);

							memset(&(pdata->city[i].vision[loser.index.index]),0,sizeof(NewWorldHero));
						}
						else if(isNPC(loser.index))
						{
							--pdata->city[i].countN;
							if(pdata->city[i].countN > NEW_WORLD_BUY_NPC)
								pdata->city[i].countN = 0;
							memset(&(pdata->city[i].vision[NEW_WORLD_CITY_VISION]),0,sizeof(NewWorldHero));
							//debug_log("[npc die]city=%u,countN=%u",pdata->city[i].cid,pdata->city[i].countN);
						}
					}
				}
			//stage 2. choose next : hero:status, city:attacker,defender, vision:status
				for(int r=1;r>=0;--r)
				{
					if((r && result == NewWorldHeroAttackResult_attacker_win)
					|| (!r && result == NewWorldHeroAttackResult_defender_win))
						continue;

					if(!r && !pdata->city[i].attacker.uid)
						continue;

					NewWorldHeroIndex &index = r?pdata->city[i].attacker:pdata->city[i].defender;
					NewWorldCityQueue &queue = r?m_citymap[pdata->city[i].cid].attacker:m_citymap[pdata->city[i].cid].defender;
					for(NewWorldCityQueue::iterator it=queue.begin();it!=queue.end();++it)
					{
						if(isHero(it->second))
						{
							unsigned seq = m_heromap[it->second].seq;
							if(IsReady(pdata->hero[seq].status) && pdata->hero[seq].cid == pdata->city[i].cid)
							{
								index = it->second;
								//debug_log("[choose hero]city=%u,r=%d,hero=%u,%u",pdata->city[i].cid,r,index.uid,index.index);
								pdata->hero[seq].status = r?NewWorldHeroStatus_attack:NewWorldHeroStatus_defence;
								pdata->hero[seq].ts = pdata->ts + NEW_WORLD_TICK;
								break;
							}
						}
						else if(isVision(it->second))
						{
							if(pdata->city[i].vision[it->second.index].index.uid && IsReady(pdata->city[i].vision[it->second.index].status))
							{
								index = it->second;
								//debug_log("[choose vision]city=%u,r=%d,hero=%u,%u",pdata->city[i].cid,r,index.uid,index.index);
								pdata->city[i].vision[it->second.index].status = r?NewWorldHeroStatus_attack:NewWorldHeroStatus_defence;
								break;
							}
						}
					}
					if(!index.uid)
					{
						if(pdata->city[i].countV)
						{
							for(unsigned v=0;v<NEW_WORLD_CITY_VISION;++v)
							{
								if(pdata->city[i].vision[v].index.uid
								&& IsReady(pdata->city[i].vision[v].status)
								&& ((r && pdata->city[i].vision[v].kingdom != pdata->city[i].kingdom)
								|| (!r && pdata->city[i].vision[v].kingdom == pdata->city[i].kingdom)))
								{
									index = pdata->city[i].vision[v].index;
									//debug_log("[choose vision]city=%u,r=%d,hero=%u,%u",pdata->city[i].cid,r,index.uid,index.index);
									pdata->city[i].vision[v].status = r?NewWorldHeroStatus_attack:NewWorldHeroStatus_defence;
									break;
								}
							}
						}
					}
					if(!index.uid && !r && pdata->city[i].countN)
					{
						if(pdata->city[i].vision[NEW_WORLD_CITY_VISION].index.uid)
						{
							pdata->city[i].vision[NEW_WORLD_CITY_VISION].status = NewWorldHeroStatus_defence;
							index = pdata->city[i].vision[NEW_WORLD_CITY_VISION].index;
						}
						else
						{
							pdata->city[i].vision[NEW_WORLD_CITY_VISION].job = pdata->city[i].countN;
							makeNPC(pdata->city[i].vision[NEW_WORLD_CITY_VISION]);
							pdata->city[i].vision[NEW_WORLD_CITY_VISION].cid = pdata->city[i].cid;
							pdata->city[i].vision[NEW_WORLD_CITY_VISION].kingdom = pdata->city[i].kingdom;
							index = pdata->city[i].vision[NEW_WORLD_CITY_VISION].index;
						}
						//debug_log("[choose npc]city=%u,r=%d,hero=%u,%u",pdata->city[i].cid,r,index.uid,index.index);
					}
					if(index.uid)
					{
						pdata->changets = pdata->ts + NEW_WORLD_TICK;
						pdata->city[i].ts = pdata->ts + NEW_WORLD_TICK;

						if(!result)
							changeset.insert(pdata->city[i].cid);
					}
				}
			//stage 3. occupy : mission; city:attacker, defender, npcts, countN, uid, kingdom, name; hero:status
				if(pdata->city[i].attacker.uid && !pdata->city[i].defender.uid)
				{
					//debug_log("[occupy]city=%u",pdata->city[i].cid);
					changeset.insert(pdata->city[i].cid);
					if(IsValidUid(pdata->city[i].uid))
						occupyset.insert(pair<unsigned, unsigned>(pdata->city[i].cid, pdata->city[i].uid));

					pdata->changets = pdata->ts + NEW_WORLD_TICK;
					pdata->city[i].ts = pdata->ts + NEW_WORLD_TICK;
					if(isHero(pdata->city[i].attacker))
						pdata->city[i].kingdom = pdata->hero[m_heromap[pdata->city[i].attacker].seq].kingdom;
					else
						pdata->city[i].kingdom = pdata->city[i].vision[pdata->city[i].attacker.index].kingdom;
					pdata->city[i].tower.clear();
					if(isCapital(pdata->city[i].cid))
						pdata->city[i].uid = 70003;
					else if(isCore(pdata->city[i].cid))
						pdata->city[i].uid = 70002;
					else
						pdata->city[i].uid = 70001;
					memset(pdata->city[i].name,0,sizeof(pdata->city[i].name));
					pdata->city[i].name[0] = 'N';pdata->city[i].name[1] = 'P';pdata->city[i].name[2] = 'C';
					pdata->city[i].npcts = pdata->ts + NEW_WORLD_TICK;
					pdata->city[i].countN = NEW_WORLD_CITY_OCCUPY_NPC;
					if(isHero(pdata->city[i].attacker))
					{
						pdata->hero[m_heromap[pdata->city[i].attacker].seq].status = NewWorldHeroStatus_wait_defence;
						pdata->hero[m_heromap[pdata->city[i].attacker].seq].ts = pdata->ts + NEW_WORLD_TICK;
					}
					addKill(pdata->hero[m_heromap[pdata->city[i].attacker].seq], NEW_WORLD_KILL_ADD_LAST, pdata->ts + NEW_WORLD_TICK, pdata);
					pdata->city[i].attacker.clear();
					for(NewWorldCityQueue::iterator it=m_citymap[pdata->city[i].cid].attacker.begin();it!=m_citymap[pdata->city[i].cid].attacker.end();++it)
					{
						if(isHero(it->second))
						{
							unsigned seq = m_heromap[it->second].seq;
							if(IsInCity(pdata->hero[seq].status))
							{
								pdata->hero[seq].ts = pdata->ts + NEW_WORLD_TICK;
								if(pdata->hero[seq].kingdom == pdata->city[i].kingdom)
									pdata->hero[seq].status = NewWorldHeroStatus_wait_defence;
								else
									pdata->hero[seq].status = NewWorldHeroStatus_wait_attack;
								addKill(pdata->hero[seq], NEW_WORLD_KILL_ADD_QUEUE, pdata->ts + NEW_WORLD_TICK, pdata);
							}
						}
					}
					if(pdata->city[i].countV)
					{
						for(unsigned v=0;v<NEW_WORLD_CITY_VISION;++v)
						{
							if(pdata->city[i].vision[v].index.uid)
							{
								if(pdata->city[i].vision[v].kingdom == pdata->city[i].kingdom)
									pdata->city[i].vision[v].status = NewWorldHeroStatus_wait_defence;
								else
									pdata->city[i].vision[v].status = NewWorldHeroStatus_wait_attack;
								addKill(pdata->city[i].vision[v], NEW_WORLD_KILL_ADD_QUEUE, pdata->ts + NEW_WORLD_TICK, pdata);
							}
						}
					}

					for(unsigned m=0;m<3;++m)
					{
						if(pdata->mission[m].defend == pdata->city[i].cid && pdata->mission[m].defendStatus == NewWorldMissonStatus_defending)
							pdata->mission[m].defendStatus = NewWorldMissonStatus_defend_over;
						if(pdata->mission[m].defend == pdata->city[i].cid && pdata->mission[m].defendStatus == NewWorldMissonStatus_attacking)
						{
							if (now >= getFastMissionStartTime() && now <= getFastMissionEndTime())
							{
								debug_log("m=%u",m);
								pdata->mission[m].defendStatus = NewWorldMissonStatus_attack_fast_over;
							}
							else
							{
								debug_log("m=%u",m);
								pdata->mission[m].defendStatus = NewWorldMissonStatus_attack_over;
							}
						}
						if(pdata->mission[m].attack == pdata->city[i].cid && pdata->mission[m].attackStatus == NewWorldMissonStatus_defending)
							pdata->mission[m].attackStatus = NewWorldMissonStatus_defend_over;
						if(pdata->mission[m].attack == pdata->city[i].cid && pdata->mission[m].attackStatus == NewWorldMissonStatus_attacking)
						{
							if (now >= getFastMissionStartTime() && now <= getFastMissionEndTime())
							{
								debug_log("m=%u",m);
								pdata->mission[m].attackStatus = NewWorldMissonStatus_attack_fast_over;
							}
							else
							{
								debug_log("m=%u",m);
								pdata->mission[m].attackStatus = NewWorldMissonStatus_attack_over;
							}
						}
					}
				}
				else if(pdata->city[i].defender.uid && !pdata->city[i].attacker.uid)
				{
					changeset.insert(pdata->city[i].cid);

					pdata->changets = pdata->ts + NEW_WORLD_TICK;
					pdata->city[i].ts = pdata->ts + NEW_WORLD_TICK;
					if(isHero(pdata->city[i].defender))
					{
						pdata->hero[m_heromap[pdata->city[i].defender].seq].status = NewWorldHeroStatus_wait_defence;
						pdata->hero[m_heromap[pdata->city[i].defender].seq].ts = pdata->ts + NEW_WORLD_TICK;
					}
					else if(isVision(pdata->city[i].defender))
					{
						pdata->city[i].vision[pdata->city[i].defender.index].status = NewWorldHeroStatus_wait_defence;
					}
					else if(isNPC(pdata->city[i].defender))
					{
						pdata->city[i].vision[pdata->city[i].defender.index].status = NewWorldHeroStatus_wait_defence;
					}
					pdata->city[i].defender.clear();
				}

				unsigned npctime = m_npctimemap[pdata->city[i].cid].GetNPCTime(pdata->city[i].kingdom);//pdata->city[i].kingdom?getNPCTime(m_kingdomcityNum[pdata->city[i].kingdom-1]):NEW_WORLD_CITY_NPC_TIME_1;
				if(pdata->city[i].npcts + npctime < pdata->ts + NEW_WORLD_TICK)
				{
					//debug_log("++npc cid=%u,time=%u,npcts=%u,ts=%u",pdata->city[i].cid,npctime,pdata->city[i].npcts,pdata->ts+NEW_WORLD_TICK);
					pdata->city[i].npcts = pdata->ts + NEW_WORLD_TICK;
					if(pdata->city[i].countN < NEW_WORLD_CITY_NPC)
					{
						pdata->changets = pdata->ts + NEW_WORLD_TICK;
						pdata->city[i].ts = pdata->ts + NEW_WORLD_TICK;
						++pdata->city[i].countN;
					}
					else if(pdata->city[i].countN > NEW_WORLD_BUY_NPC)
						pdata->city[i].countN = 0;
				}
			}
			//hero
			for(unsigned j=0;j<pdata->count;++j)
			{
				//error check
				if((pdata->hero[j].status == NewWorldHeroStatus_attack
				&& pdata->city[m_citymap[pdata->hero[j].cid].city.seq].attacker != pdata->hero[j].index)
				|| (pdata->hero[j].status == NewWorldHeroStatus_defence
				&& pdata->city[m_citymap[pdata->hero[j].cid].city.seq].defender != pdata->hero[j].index))
				{
					if(pdata->city[m_citymap[pdata->hero[j].cid].city.seq].kingdom == pdata->hero[j].kingdom)
						pdata->hero[j].status = NewWorldHeroStatus_wait_defence;
					else
						pdata->hero[j].status = NewWorldHeroStatus_wait_attack;
				}
			//stage 4. move & recover : hero:status,cid,next,hp; city: count123
				if(!pdata->city[m_citymap[pdata->hero[j].cid].city.seq].Fighting()
				&& !IsFighting(pdata->hero[j].status)
				&& pdata->hero[j].recover(pdata->hero[j].kingdom?m_kingdomcityNum[pdata->hero[j].kingdom-1]:NEW_WORLD_CITY_KINGDOM))
				{
					pdata->changets = pdata->ts + NEW_WORLD_TICK;
					pdata->hero[j].ts = pdata->ts + NEW_WORLD_TICK;
				}
				if(pdata->hero[j].status == NewWorldHeroStatus_wait_move)
				{
					pdata->changets = pdata->ts + NEW_WORLD_TICK;
					pdata->hero[j].ts = pdata->ts + NEW_WORLD_TICK;
					unsigned seq = m_citymap[pdata->hero[j].cid].city.seq;
					pdata->city[seq].ts = pdata->ts + NEW_WORLD_TICK;
					/*20141114 change countN*/
					if(pdata->hero[j].kingdom)
					{
						--pdata->city[seq].count[pdata->hero[j].kingdom-1];
						//debug_log("[leave]city=%u,count%u=%d,hero=%u,%u",pdata->city[seq].cid,pdata->hero[j].kingdom,pdata->city[seq].count[pdata->hero[j].kingdom-1],pdata->hero[j].index.uid,pdata->hero[j].index.index);
					}
					if(pdata->hero[j].next && pdata->hero[j].next < NEW_WORLD_CITY_KINGDOM_SEQ*4)
						pdata->hero[j].cid = pdata->hero[j].next;
					pdata->hero[j].status = NewWorldHeroStatus_move;
					unsigned newseq = m_citymap[pdata->hero[j].cid].city.seq;
					pdata->city[newseq].ts = pdata->ts + NEW_WORLD_TICK;
					/*20141114 change countN*/
					if(pdata->hero[j].kingdom)
					{
						++pdata->city[newseq].count[pdata->hero[j].kingdom-1];
						//debug_log("[arrive]city=%u,count%u=%d,hero=%u,%u",pdata->city[newseq].cid,pdata->hero[j].kingdom,pdata->city[newseq].count[pdata->hero[j].kingdom-1],pdata->hero[j].index.uid,pdata->hero[j].index.index);
					}
					pdata->hero[j].next = pdata->ts + NEW_WORLD_TICK*2;
				}
				else if(pdata->hero[j].status == NewWorldHeroStatus_move)
				{
					pdata->changets = pdata->ts + NEW_WORLD_TICK;
					pdata->hero[j].ts = pdata->ts + NEW_WORLD_TICK;
					unsigned seq = m_citymap[pdata->hero[j].cid].city.seq;
					if(pdata->city[seq].kingdom == pdata->hero[j].kingdom)
						pdata->hero[j].status = NewWorldHeroStatus_wait_defence;
					else
						pdata->hero[j].status = NewWorldHeroStatus_wait_attack;
				}
			}

			if(bugflag)
				_fix(pdata, pdata->ts + NEW_WORLD_TICK);

			pdata->ts += NEW_WORLD_TICK;

			//debug_log("sync after ts=%u->%u,%u",m_ts,pdata->ts,pdata->changets);
			if(m_ts < pdata->changets || pdata->ts == pdata->changets || now < pdata->changets)
				sync(pdata);
			else
				m_ts = pdata->ts;
		}
	}
	else
		return R_ERR_DB;

	if(m_tool && !occupyset.empty())
	{
		CLogicUpdates logicUpdates;
		Json::Value updates;
		for(set<pair<unsigned,unsigned> >::iterator it=occupyset.begin();it!=occupyset.end();++it)
		{
			if(IsValidUid(it->second))
			{
				updates["s"] = "SUBBASELOSS";
				updates["name"] = "";
				updates["uid"] = 0;
				updates["ts"] = now;
				updates["cid"] = it->first;
				logicUpdates.AddUpdate(it->second,updates);
			}
		}
	}
	else if(!occupyset.empty())// || !changeset.empty())
	{
		DataNewWorldChange *pdataChange = (DataNewWorldChange *)m_shChange.GetAddress();
		if(pdataChange)
		{
			CAutoLock lock(&m_shChange, true);

			pdataChange->clear();

			if(!occupyset.empty())
			{
				unsigned i = 0;
				for(set<pair<unsigned,unsigned> >::iterator it=occupyset.begin();it!=occupyset.end();++it)
				{
					pdataChange->city[i].uid = it->second;
					pdataChange->city[i].cid = it->first;
					++i;
				}
			}

			/*
			if(!changeset.empty())
			{
				unsigned i = 0;
				for(set<unsigned>::iterator it=changeset.begin();it!=changeset.end();++it)
				{
					pdataChange->battle[i].cid = *it;
					pdataChange->battle[i].kingdom = m_citymap[*it].city.kingdom;
					pdataChange->battle[i].battle = m_citymap[*it].city.Fighting()?1:0;
					++i;
				}
			}
			*/
		}
		string cmd = "cd " + Config::GetPath(CONFIG_DIR_TOOL) + " && ./NewWorldTool change &";
		system(cmd.c_str());
	}
	if(!changeset.empty())
	{
		for(set<unsigned>::iterator it=changeset.begin();it!=changeset.end();++it)
		{
			m_battlechange[*it].cid = *it;
			m_battlechange[*it].kingdom = m_citymap[*it].city.kingdom;
			m_battlechange[*it].battle = m_citymap[*it].city.Fighting()?1:0;
		}
	}

	return 0;
}

int CDataNewWorld::change()
{
	int semgroup = 1;
	int semserver = 0;
	Config::GetDomain(semserver);
	if(!semserver)
		Config::GetDB(semserver);
	string path = Config::GetPath(CONFIG_NEW_WORLD_DATA) + ".change";
	if(!m_shChange.CreateOrOpen(path.c_str(), sizeof(DataNewWorldChange), SEM_ID(sem_new_world,semgroup,semserver)))
	{
		error_log("[init_NewWorld_change_fail][path=%s]", path.c_str());
		return R_ERR_DB;
	}

	DataNewWorldChange *pdata = (DataNewWorldChange *)m_shChange.GetAddress();
	if(pdata == NULL)
	{
		error_log("change address fail");
		return R_ERR_DB;
	}

	CAutoLock lock(&m_shChange, true);

	if(!m_shChange.HasInit())
	{
		memset(pdata, 0, sizeof(*pdata));
		m_shChange.SetInitDone();
		return 0;
	}

	if(pdata->city[0].uid)
	{
		CLogicUpdates logicUpdates;
		Json::Value updates;
		for(unsigned i=0;i<NEW_WORLD_CITY;++i)
		{
			if(pdata->city[i].uid == 0)
				break;

			updates["s"] = "SUBBASELOSS";
			updates["name"] = "";
			updates["uid"] = 0;
			updates["ts"] = Time::GetGlobalTime();
			updates["cid"] = pdata->city[i].cid;
			logicUpdates.AddUpdate(pdata->city[i].uid,updates);
		}
	}

	if(pdata->battle[0].cid)
	{
		CBroadcastNewWorldBattle m_client;
		if(!m_client.InitSocket() && !m_client.LoginServer())
		{
			for(unsigned i=0;i<NEW_WORLD_CITY;++i)
			{
				if(pdata->battle[i].cid == 0)
					break;

				if(m_client.SubmitBattle(pdata->battle[i].cid, pdata->battle[i].kingdom, pdata->battle[i].battle))
					break;
				//debug_log("[SubmitBattle]city=%u,kingdom=%u,battle=%u",pdata->battle[i].cid,pdata->battle[i].kingdom,pdata->battle[i].battle);
			}
		}
	}

	pdata->clear();

	/*
	CBroadcastNewWorldBattle m_client;
	if(!m_client.InitSocket() && !m_client.LoginServer())
		m_client.SubmitBattle(1, 1, 1);
	*/

	return 0;
}
int CDataNewWorld::PrintHero()
{
	int semgroup = 0;
	int semserver = 0;
	Config::GetDomain(semserver);
	if(!semserver)
		Config::GetDB(semserver);
	if(!m_sh.CreateOrOpen(Config::GetPath(CONFIG_NEW_WORLD_DATA).c_str(), sizeof(DataNewWorld), SEM_ID(sem_new_world,semgroup,semserver)))
	{
		cout<<"shm fail"<<endl;
		return R_ERR_DB;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		cout<<"address fail"<<endl;
		return R_ERR_DB;
	}

	CAutoLock lock(&m_sh, true);

	cout<<"heros:"<<pdata->count<<endl;
	for(unsigned j=0;j<pdata->count;++j)
	{
		cout<<"uid:"<<pdata->hero[j].index.uid<<","<<pdata->hero[j].index.index
			<<" kingdom:"<<pdata->hero[j].kingdom<<" hid:"<<pdata->hero[j].hid
			<<" level:"<<pdata->hero[j].level<<" job:"<<pdata->hero[j].job
			<<" type:"<<pdata->hero[j].type<<" cid:"<<pdata->hero[j].cid
			<<" next:"<<pdata->hero[j].next<<" status:"<<pdata->hero[j].status
			<<" hp:"<<pdata->hero[j].hp<<" kill:"<<pdata->hero[j].kill
			<<endl;
	}

	return 0;
}
int CDataNewWorld::PrintCity()
{
	int semgroup = 0;
	int semserver = 0;
	Config::GetDomain(semserver);
	if(!semserver)
		Config::GetDB(semserver);
	if(!m_sh.CreateOrOpen(Config::GetPath(CONFIG_NEW_WORLD_DATA).c_str(), sizeof(DataNewWorld), SEM_ID(sem_new_world,semgroup,semserver)))
	{
		cout<<"shm fail"<<endl;
		return R_ERR_DB;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		cout<<"address fail"<<endl;
		return R_ERR_DB;
	}

	CAutoLock lock(&m_sh, true);

	for(unsigned j=0;j<NEW_WORLD_CITY;++j)
	{
		cout<<"cid:"<<pdata->city[j].cid<<" uid:"<<pdata->city[j].uid
			<<" kingdom:"<<pdata->city[j].kingdom
			<<" attacker:"<<pdata->city[j].attacker.uid<<","<<pdata->city[j].attacker.index
			<<" defender:"<<pdata->city[j].defender.uid<<","<<pdata->city[j].defender.index
			<<" count:"<<pdata->city[j].count[0]<<","<<pdata->city[j].count[1]<<","<<pdata->city[j].count[2]
			<<","<<pdata->city[j].countV<<","<<pdata->city[j].countN
			<<" npcts:"<<pdata->city[j].npcts
			<<" reward:"<<pdata->city[j].reward<<","<<pdata->city[j].nextReward
			<<endl;
		for(unsigned i=0;i<NEW_WORLD_CITY_VISION;++i)
		{
			if(pdata->city[j].vision[i].index.uid)
				cout<<" seq:"<<pdata->city[j].vision[i].index.index
				<<" uid:"<<pdata->city[j].vision[i].seq<<","<<pdata->city[j].vision[i].index.uid-1
				<<" kingdom:"<<pdata->city[j].vision[i].kingdom<<" hid:"<<pdata->city[j].vision[i].hid
				<<" level:"<<pdata->city[j].vision[i].level<<" job:"<<pdata->city[j].vision[i].job
				<<" type:"<<pdata->city[j].vision[i].type<<" cid:"<<pdata->city[j].vision[i].cid
				<<" next:"<<pdata->city[j].vision[i].next<<" status:"<<pdata->city[j].vision[i].status
				<<" hp:"<<pdata->city[j].vision[i].hp<<endl;
		}
	}

	return 0;
}
int CDataNewWorld::Watch()
{
	checkTick();

	for(NewWorldHeroMap::iterator it=m_heromap.begin();it!=m_heromap.end();++it)
	{
		cout<<"uid:"<<it->second.index.uid<<","<<it->second.index.index
			<<" kingdom:"<<it->second.kingdom<<" hid:"<<it->second.hid
			<<" level:"<<it->second.level<<" job:"<<it->second.job
			<<" type:"<<it->second.type<<" cid:"<<it->second.cid
			<<" next:"<<it->second.next<<" status:"<<it->second.status
			<<" hp:"<<it->second.hp<<" kill:"<<it->second.kill
			<<endl;
	}
	for(NewWorldCityMap::iterator it=m_citymap.begin();it!=m_citymap.end();++it)
	{
		cout<<"cid:"<<it->second.city.cid<<" uid:"<<it->second.city.uid
			<<" kingdom:"<<it->second.city.kingdom
			<<" attacker:"<<it->second.city.attacker.uid<<","<<it->second.city.attacker.index
			<<" defender:"<<it->second.city.defender.uid<<","<<it->second.city.defender.index
			<<" count:"<<it->second.city.count[0]<<","<<it->second.city.count[1]<<","<<it->second.city.count[2]
			<<","<<it->second.city.countV<<","<<it->second.city.countN
			<<" npcts:"<<it->second.city.npcts
			<<" reward:"<<it->second.city.reward<<","<<it->second.city.nextReward
			<<endl;
	}
	for(unsigned i=0;i<3;++i)
	{
		cout<<"kingdom:"<<i+1
			<<" attack:"<<m_mission[i].attack
			<<" attackStatus:"<<m_mission[i].attackStatus
			<<" defend:"<<m_mission[i].defend
			<<" defendStatus:"<<m_mission[i].defendStatus
			<<endl;
	}
	return 0;
}
int CDataNewWorld::FixOld()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->count = 0;
	memset(pdata->hero, 0, sizeof(pdata->hero));
	for(NewWorldHeroMap::iterator it=m_heromap.begin();it!=m_heromap.end();++it)
	{
		if(it->second.ts+86400*7 > now)
		{
			pdata->hero[pdata->count] = it->second;
			pdata->hero[pdata->count].seq = pdata->count;
			pdata->hero[pdata->count].ts = now;
			++pdata->count;
		}
	}

	_fix(pdata, now);

	return 0;
}
int CDataNewWorld::Fix()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	_fix(pdata, now);

	return 0;
}
void CDataNewWorld::_fix(DataNewWorld *pdata, unsigned ts)
{
	pdata->changets = ts;
	unsigned j=0;
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		pdata->city[j].ts = ts;
		pdata->city[j].count[0] = 0;
		pdata->city[j].count[1] = 0;
		pdata->city[j].count[2] = 0;
		pdata->city[j].countV = 0;
		for(unsigned count=0;count<NEW_WORLD_CITY_VISION;++count)
		{
			if(pdata->city[j].vision[count].index.uid)
			{
				++pdata->city[j].countV;
				if(pdata->city[j].vision[count].kingdom)
					++pdata->city[j].count[pdata->city[j].vision[count].kingdom-1];
				if(pdata->city[j].kingdom == pdata->city[j].vision[count].kingdom)
					pdata->city[j].vision[count].status = NewWorldHeroStatus_wait_defence;
				else
					pdata->city[j].vision[count].status = NewWorldHeroStatus_wait_attack;
			}
		}
		if(pdata->city[j].countN > NEW_WORLD_BUY_NPC)
			pdata->city[j].countN = 0; 
	}
	for(j=0;j<pdata->count;++j)
	{
		if(!pdata->hero[j].kingdom)
			pdata->hero[j].kingdom = 1;
		if(!pdata->hero[j].cid || pdata->hero[j].cid > NEW_WORLD_CITY_KINGDOM_SEQ*4)
			pdata->hero[j].cid = getCapital(pdata->hero[j].kingdom);

		if(pdata->hero[j].kingdom)
			++pdata->city[m_citymap[pdata->hero[j].cid].city.seq].count[pdata->hero[j].kingdom-1];
		if(pdata->hero[j].kingdom == pdata->city[m_citymap[pdata->hero[j].cid].city.seq].kingdom)
			pdata->hero[j].status = NewWorldHeroStatus_wait_defence;
		else
			pdata->hero[j].status = NewWorldHeroStatus_wait_attack;
	}

	system("killall -12 CgiNewWorld");
	exit(0);
}
int CDataNewWorld::Reset()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;
	unsigned j=0;
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		pdata->city[j].ts = now;
		for(unsigned count=0;count<NEW_WORLD_CITY_VISION_NPC;++count)
		{
			if(pdata->city[j].vision[count].index.uid)
			{
				pdata->city[j].vision[count].hp = 1;
				for(unsigned i=0;i<NewWorldProperty_max;++i)
					pdata->city[j].vision[count].property[i] = 1;
			}
		}
	}
	for(j=0;j<pdata->count;++j)
	{
		pdata->hero[j].ts = now;
		pdata->hero[j].hp = 1;
		for(unsigned i=0;i<NewWorldProperty_max;++i)
			pdata->hero[j].property[i] = 1;
	}
	return 0;
}
int CDataNewWorld::Back()
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	pdata->changets = now;
	unsigned j=0;
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		pdata->city[j].ts = now;
		memset(pdata->city[j].vision, 0, sizeof(pdata->city[j].vision));
		pdata->city[j].count[0] = pdata->city[j].count[1] = pdata->city[j].count[2] = pdata->city[j].countN = pdata->city[j].countV = 0;
		pdata->city[j].npcts += 3600;
	}
	for(j=0;j<pdata->count;++j)
	{
		pdata->hero[j].ts = now;
		pdata->hero[j].cid = getCapital(pdata->hero[j].kingdom);
	}
	return 0;
}
int CDataNewWorld::Test(NewWorldHero &attacker, unsigned hpa, NewWorldHero &defender, unsigned hpd)
{
	checkTick();
	if(!m_heromap.count(attacker.index) || !m_heromap.count(defender.index))
		return R_ERR_PARAM;
	attacker = m_heromap[attacker.index];
	defender = m_heromap[defender.index];
	attacker.hp = (double)attacker.property[NewWorldProperty_hp]*(double)hpa/double(100);
	defender.hp = (double)defender.property[NewWorldProperty_hp]*(double)hpd/double(100);
	attacker.kill = defender.kill = 0;
	attacker.inc_kill = defender.inc_kill = 0;
	int ak, dk;
	attacking(attacker,defender,ak,dk);
	//addKill(attacker, defender, ak, dk, 0, NULL);
	//addKill(defender, attacker, dk, ak, 0, NULL);
	return 0;
}
int CDataNewWorld::Time()
{
	unsigned now = Time::GetGlobalTime();

	int semgroup = 0;
	int semserver = 0;
	Config::GetDomain(semserver);
	if(!semserver)
		Config::GetDB(semserver);
	if(!m_sh.CreateOrOpen(Config::GetPath(CONFIG_NEW_WORLD_DATA).c_str(), sizeof(DataNewWorld), SEM_ID(sem_new_world,semgroup,semserver)))
	{
		cout<<"shm fail"<<endl;
		return R_ERR_DB;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		cout<<"address fail"<<endl;
		return R_ERR_DB;
	}

	CAutoLock lock(&m_sh, true);

	if(pdata->ts > now)
		pdata->ts = now;
	pdata->changets = now;
	unsigned j=0;
	for(j=0;j<NEW_WORLD_CITY;++j)
	{
		if(pdata->city[j].ts > now)
			pdata->city[j].ts = now;
		if(pdata->city[j].npcts > now)
			pdata->city[j].npcts = now;
		for(unsigned count=0;count<NEW_WORLD_CITY_VISION_NPC;++count)
		{
			if(pdata->city[j].vision[count].ts > now)
				pdata->city[j].vision[count].ts = now;
			if(pdata->city[j].vision[count].next > now)
				pdata->city[j].vision[count].next = now;
		}
	}
	for(j=0;j<pdata->count;++j)
	{
		if(pdata->hero[j].ts > now)
			pdata->hero[j].ts = now;
		if(pdata->hero[j].next > now)
			pdata->hero[j].next = now;
	}

	return 0;
}

int CDataNewWorld::GetMoveR1(unsigned level)
{
	if(level > NEW_WORLD_MOVE_LEVEL || !level)
		return 100000000;
	return move_r1[level - 1];
}

unsigned CDataNewWorld::GetKillExp(unsigned kill, unsigned level)
{
	if(!kill)
		return 0;
	if(level < NEW_WORLD_KILL_REWARD_LEVEL_MIN || level > NEW_WORLD_KILL_REWARD_LEVEL_MAX)
		return 0;

	level -= NEW_WORLD_KILL_REWARD_LEVEL_MIN;
	unsigned exp = 0;
	if(kill <= kill_reward_kill[level][0])
		exp += (double)kill * (double)kill_reward_p[level][0] / double(10000);
	else
	{
		exp += kill_reward_kill[level][0] * (double)kill_reward_p[level][0] / double(10000);
		if(kill <= kill_reward_kill[level][1])
			exp += (double)(kill - kill_reward_kill[level][0]) * (double)kill_reward_p[level][1] / double(10000);
		else
		{
			exp += (double)(kill_reward_kill[level][1] - kill_reward_kill[level][0]) * (double)kill_reward_p[level][1] / double(10000);
			if(kill <= kill_reward_kill[level][2])
				exp += (double)(kill - kill_reward_kill[level][1]) * (double)kill_reward_p[level][2] / double(10000);
			else
			{
				exp += (double)(kill_reward_kill[level][2] - kill_reward_kill[level][1]) * (double)kill_reward_p[level][2] / double(10000);
				exp += (double)(kill - kill_reward_kill[level][2]) * (double)kill_reward_p[level][3] / double(10000);
			}
		}
	}
	return exp;
}
unsigned CDataNewWorld::GetKillReward1(unsigned rank)
{
	if(rank == 1)
		return 15;
	else if(rank == 2)
		return 15;
	else if(rank == 3)
		return 15;
	else if(rank <= 10)
		return 12;
	else if(rank <= 30)
		return 8;
	else if(rank <= 50)
		return 5;
	else if(rank <= 100)
		return 2;
	else
		return 0;
}
unsigned CDataNewWorld::GetKillReward2(unsigned rank)
{
	if(rank == 1)
		return 30;
	else if(rank == 2)
		return 25;
	else if(rank == 3)
		return 20;
	else if(rank <= 10)
		return 20;
	else if(rank <= 30)
		return 15;
	else if(rank <= 50)
		return 10;
	else if(rank <= 100)
		return 5;
	else
		return 0;
}
unsigned CDataNewWorld::GetKillRewardNew(unsigned rank)
{
	if(rank == 1)
		return 180;
	else if(rank <= 3)
		return 150;
	else if(rank <= 10)
		return 100;
	else if(rank <= 30)
		return 80;
	else if(rank <= 50)
		return 50;
	else if(rank <= 100)
		return 20;
	else
		return 0;
}

CBroadcastNewWorldBattle::CBroadcastNewWorldBattle():m_skey(0)
{}
CBroadcastNewWorldBattle::~CBroadcastNewWorldBattle()
{
	Close();
}
int CBroadcastNewWorldBattle::Close()
{
	if(!m_socket.IsClosed())
	{
		m_socket.Close();
	}
	return 0;
}
int CBroadcastNewWorldBattle::InitSocket()
{
	bool result;
	result = m_socket.Socket(SOCK_STREAM, 0, AF_INET);
	if (!result)
	{
		error_log("[create secket error]");
		return R_ERROR;
	}
	struct timeval timeo = {3, 0};
	m_socket.SetSockOpt(SOL_SOCKET, SO_SNDTIMEO, &timeo, sizeof(timeo));
	m_socket.SetSockOpt(SOL_SOCKET, SO_RCVTIMEO, &timeo, sizeof(timeo));

	int serverid = 0;
	Config::GetDomain(serverid);
	if(!serverid)
	{
		m_serverid = Config::GetValue("server_id");
		serverid = MainConfig::GetMergedDomain(CTrans::STOI(m_serverid));
	}
	m_serverid = CTrans::UTOS(serverid);
	m_tcpserver = Config::GetValue(CONFIG_TCP_HOST);
	size_t pos = m_tcpserver.find(':');
	string hostname = m_tcpserver.substr(0, pos);
	string port = m_tcpserver.substr(pos + 1, m_tcpserver.length() - pos - 1);
	CLogicAdmin logicAdmin;
	string host;
	if(logicAdmin.CheckIp(hostname))
	{
		host = hostname;
	}
	else
	{
		host = string(inet_ntoa(*(struct in_addr*) *(gethostbyname(hostname.c_str())->h_addr_list)));
	}

	struct sockaddr_in server;
	server.sin_addr.s_addr = inet_addr(host.c_str());
	server.sin_port = htons(atoi(port.c_str()));
	server.sin_family = AF_INET;
	memset(server.sin_zero, 0x00, sizeof(server.sin_zero));
	result = m_socket.Connect((struct sockaddr *) &server, sizeof(struct sockaddr));
	if (!result)
	{
		error_log("connect socket error,addr=%s,port=%s,errno=%d,errmsg = %s",
				host.c_str(),port.c_str(),errno, strerror(errno));
		return R_ERR_REFUSE;
	}
	return 0;
}
int CBroadcastNewWorldBattle::LoginServer()
{
	bool result;
	string firstpack = "tgw_l7_forward\r\nHost: " + m_tcpserver + " serverid:" + m_serverid + "\r\n\r\n";
	int firstpackLen = firstpack.length();
	byte packbyte[firstpackLen];
	memset(packbyte, 0x00, firstpackLen);
	memcpy(packbyte, firstpack.c_str(), firstpackLen);
	result = m_socket.Send(packbyte, firstpackLen, 0);
	if (!result)
	{
		error_log("[send firstpack error]errno=%d,errmsg = %s",errno, strerror(errno));
		return R_ERR_REFUSE;
	}

	CPacket1 cpacket;
	cpacket.UserId = 1999999998;
	cpacket.ProtocolType = PROTOCOL_TYPE_LOGIN;
	cpacket.MainProtocolType = 1;
	cpacket.SubProtocolType = 1;
	cpacket.PacketType = PT_CSRequest;
	cpacket.ProtocolBody.Clear();

	CLoginSend cloginsend;
	cloginsend.name = "{\"name\":\"系统管理员\",\"hname\":\"\",\"hlvl\":0}";
	cloginsend.platform = 4;

	if (!cloginsend.Encode(&cpacket.ProtocolBody))
	{
		error_log("[login_body_encode_error]");
		return R_ERR_DATA;
	}

	CStaticBuffer<1000> buffer;
	buffer.Clear();
	if (!cpacket.Encode(&buffer))
	{
		error_log("[login_packet_encode_failed]");
		return R_ERR_DATA;
	}

	result = m_socket.Send(buffer.GetConstBuffer(), buffer.GetSize(), 0);
	if (!result)
	{
		error_log("[send_login_paket_error]errno=%d,errmsg = %s",errno, strerror(errno));
		return R_ERR_REFUSE;
	}

	int recvsize = 0;
	buffer.Clear();
	recvsize = m_socket.Receive(buffer.GetNativeBuffer(), buffer.GetFreeCapacity());
	if (recvsize < 0)
	{
		error_log("[receive socket error:%d]errno=%d,errmsg = %s",recvsize, errno, strerror(errno));
		return R_ERR_REFUSE;
	}

	buffer.SetSize(recvsize);
	CPacket1 loginreply;
	if (!loginreply.Decode(&buffer))
	{
		error_log("cpacket decode error, %u:%s", recvsize, buffer.GetNativeBuffer());
		return R_ERR_DATA;
	}

	CLoginReceive cloginrec;
	if (!cloginrec.Decode(&(loginreply.ProtocolBody))) {
		error_log("decode error");
		return R_ERR_DATA;
	}

	m_skey = cloginrec.SessionKey;
	return 0;
}

int CBroadcastNewWorldBattle::SubmitBattle(unsigned cid, unsigned kingdom, unsigned battle)
{
	bool result;
	CPacket1 RequestPacket;
	RequestPacket.ProtocolType = PROTOCOL_TYPE_NEW_WORLD_BATTLE;
	RequestPacket.MainProtocolType = 9;
	RequestPacket.SubProtocolType = 1;
	RequestPacket.PacketType = PT_CSRequest;
	RequestPacket.Key =m_skey;
	RequestPacket.UserId = 1999999998;

	CNewWorldBattleReplyProtocol ReplytProtocol;
	ReplytProtocol.cid = cid;
	ReplytProtocol.kingdom = kingdom;
	ReplytProtocol.battle = battle;
	ReplytProtocol.Encode(&(RequestPacket.ProtocolBody));

	CStaticBuffer<1000> buffer;
	buffer.Clear();
	result = RequestPacket.Encode(&buffer);
	if (!result)
	{
		error_log("[Encode_submit_packet_error]");
		return R_ERROR;
	}
	result = m_socket.Send(buffer.GetConstBuffer(), buffer.GetSize());
	if (!result)
	{
		error_log("[send_submit_packet_error]errno=%d,errmsg = %s",errno, strerror(errno));
		return R_ERROR;
	}
/*
	char buf[1000];
	result = m_socket.Receive(buf, 1000);
	if (result < 0)
	{
		error_log("receive socket error");
		return R_ERR_REFUSE;
	}
	buf[result] = 0;
	debug_log("%u,%s",result,buf);
*/
	return 0;
}

int CDataNewWorld::Double(unsigned uid, unsigned kingdom, unsigned cid)
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if (now == m_ts)
	{
		++now;
	}

	if (kingdom > 3 || kingdom < 1)
	{
		return R_ERR_PARAM;
	}

	if (!m_citymap.count(cid))
	{
		return R_ERR_DB;
	}

	unsigned i= 0;
	NewWorldHeroIndex nindex;
	for (i= 0; i< NEW_WORLD_HERO_INDEX; ++i)
	{
		nindex = NewWorldHeroIndex(uid, i);
		if (m_heromap.count(nindex))
		{
			break;
		}
	}

	if (NEW_WORLD_HERO_INDEX == i)
	{
		return R_ERR_DB;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if (NULL == pdata)
	{
		return R_ERR_DB;
	}

	{
		CAutoLock lock(&(m_sh), true);

		pdata->changets = now;

		unsigned cityseq = m_citymap[cid].city.seq;
		unsigned heroseq = m_heromap[nindex].seq;
		NewWorldHero &hero = pdata->hero[heroseq];

		// 双倍时间叠加
		if (pdata->city[cityseq].extraKillTS[kingdom - 1] < now)
		{
			pdata->city[cityseq].extraKillTS[kingdom - 1] = now;
		}

		pdata->city[cityseq].extraKillTS[kingdom - 1] += NEW_WORLD_DOUBLE_TIME;

		pdata->city[cityseq].ts = now;

		// 增加 功勋
		addKill(hero, NEW_WORLD_DOUBLE_KILL, now, pdata);
		hero.ts = now;
	}

	return 0;
}

int CDataNewWorld::rushTS(unsigned uid, unsigned kingdom, unsigned cid)
{
	checkTick();

	unsigned now = Time::GetGlobalTime();
	if (now == m_ts)
	{
		++now;
	}

	if (kingdom > 3 || kingdom < 1)
	{
		return R_ERR_PARAM;
	}

	if (!m_citymap.count(cid))
	{
		return R_ERR_DB;
	}

	unsigned i= 0;
	NewWorldHeroIndex nindex;
	for (i= 0; i< NEW_WORLD_HERO_INDEX; ++i)
	{
		nindex = NewWorldHeroIndex(uid, i);
		if (m_heromap.count(nindex))
		{
			break;
		}
	}

	if (NEW_WORLD_HERO_INDEX == i)
	{
		return R_ERR_DB;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if (NULL == pdata)
	{
		return R_ERR_DB;
	}

	{
		CAutoLock lock(&(m_sh), true);

		pdata->changets = now;

		unsigned cityseq = m_citymap[cid].city.seq;
		unsigned heroseq = m_heromap[nindex].seq;
		NewWorldHero &hero = pdata->hero[heroseq];

		// 双倍时间叠加
		if (pdata->city[cityseq].rushTS[kingdom - 1] + 1800 > now)
		{
			LOGIC_ERROR_RETURN_MSG("newworld_city_can_not_rushTS");     
		}
		else
			pdata->city[cityseq].rushTS[kingdom - 1] = now + 300;

		pdata->city[cityseq].ts = now;

		// 增加 功勋
		addKill(hero, 50, now, pdata);
		hero.ts = now;
	}

	return 0;
}

int CDataNewWorld::CollectOther(unsigned uid, unsigned cid)
{
	checkTick();

	unsigned now = Time::GetGlobalTime();

	if(now == m_ts)
	{
		++now;
	}

	if(!m_citymap.count(cid))
	{
		return R_ERR_DB;
	}

	unsigned i = 0;
	NewWorldHeroIndex nindex;
	for (i = 0; i < NEW_WORLD_HERO_INDEX; ++i)
	{
		// nindex.uid = uid
		// nindex.index = index;
		nindex = NewWorldHeroIndex(uid, i);
		if (m_heromap.count(nindex))
		{
			break;
		}
	}

	if (NEW_WORLD_HERO_INDEX == i)
	{
		return R_ERR_DB;
	}

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}

	{
		CAutoLock lock(&(m_sh), true);

		unsigned heroseq = m_heromap[nindex].seq;
		NewWorldHero &hero = pdata->hero[heroseq];

		pdata->changets = now;

		// 增加功勋
		addKill(hero, NEW_WORLD_COLLECTOTHER_KILL, now, pdata);
		hero.ts = now;
	}

	return 0;
}

int CDataNewWorld::Buildyjt(NewWorldHeroIndex index)
{
	checkTick();

	if(!m_heromap.count(index))
		return R_ERR_DB;
	if(!m_citymap.count(m_heromap[index].cid))
		return R_ERR_DB;

	if(m_citymap[m_heromap[index].cid].city.tower.uid)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jyt_full");
	}
	if(m_citymap[m_heromap[index].cid].city.kingdom != m_heromap[index].kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jyt_kingdom");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	if(isCapital(pdata->hero[m_heromap[index].seq].cid) || pdata->hero[m_heromap[index].seq].cid != m_heromap[index].cid)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_hero_die");
	}

	unsigned seq = m_citymap[m_heromap[index].cid].city.seq;
	if(pdata->city[seq].tower.uid)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jyt_full");
	}
	if(pdata->city[seq].kingdom != pdata->hero[m_heromap[index].seq].kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jyt_kingdom");
	}

	pdata->city[seq].tower.uid = index.uid;
	pdata->city[seq].tower.dps = 100;
	pdata->city[seq].tower.hit = 100;
	m_citymap[m_heromap[index].cid].city.tower = pdata->city[seq].tower;

	pdata->city[seq].ts = now;
	pdata->changets = now;

	addKill(pdata->hero[m_heromap[index].seq], 10, now, pdata);

	return 0;
}

int CDataNewWorld::UseJM(unsigned uid, unsigned jm, unsigned lv, unsigned cid, unsigned kingdom)
{
	switch(jm)
	{
	case e_JM_1:
		return jm1(jm, lv, cid, kingdom);
		break;
	case e_JM_2:
		return jm2(jm, lv, cid, kingdom);
		break;
	case e_JM_3:
		return jm3(jm, lv, cid, kingdom);
		break;
	case e_JM_4:
		return jm4(jm, lv, cid, kingdom);
		break;
	default:
		break;
	}
	return R_ERR_LOGIC;
}
int CDataNewWorld::jm1(unsigned jm, unsigned lv, unsigned cid, unsigned kingdom)
{
	const unsigned cd[NEW_WORLD_JM_LEVEL] =  {1, 2, 3};

	checkTick();

	if(!m_citymap.count(cid))
		return R_ERR_DB;

	if(!m_citymap[cid].city.Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm1_fight");
	}
	if((kingdom == m_citymap[cid].city.kingdom && m_citymap[cid].attacker.size() <= NEW_WORLD_RUSH_MIN)
	|| (kingdom != m_citymap[cid].city.kingdom && m_citymap[cid].defender.size() <= NEW_WORLD_RUSH_MIN))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm1_min");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned cityseq = m_citymap[cid].city.seq;
	if(!pdata->city[cityseq].Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm1_fight");
	}

	int s = cd[lv-1];
	int r = 0;
	unsigned otherseq = 0;
	NewWorldCityQueue &queue = kingdom==pdata->city[cityseq].kingdom?m_citymap[cid].attacker:m_citymap[cid].defender;
	NewWorldCityQueue::iterator it=queue.begin();
	for(;it!=queue.end();++it)
	{
		++r;
		if(r <= NEW_WORLD_RUSH_MIN)
			continue;
		if(isHero(it->second))
		{
			otherseq = m_heromap[it->second].seq;
			if(!CanMove(pdata->hero[otherseq].status) ||  pdata->hero[otherseq].cid != cid)
				continue;

			pdata->changets = now;
			pdata->city[cityseq].ts = now;

			pdata->hero[otherseq].ts = now;
			pdata->hero[otherseq].cid = getCapital(pdata->hero[otherseq].kingdom);
			pdata->hero[otherseq].status = NewWorldHeroStatus_wait_defence;
			if(pdata->hero[otherseq].kingdom)
			{
				--pdata->city[cityseq].count[pdata->hero[otherseq].kingdom-1];
				++pdata->city[m_citymap[pdata->hero[otherseq].cid].city.seq].count[pdata->hero[otherseq].kingdom-1];
			}

			--s;
		}
		if(s == 0)
			break;
	}
	if(s == cd[lv-1])
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm1_min");
	}

	return 0;
}
int CDataNewWorld::jm2(unsigned jm, unsigned lv, unsigned cid, unsigned kingdom)
{
	const int cd[NEW_WORLD_JM_LEVEL] =  {500, 800, 1000};

	checkTick();

	if(!m_citymap.count(cid))
		return R_ERR_DB;

	if(!m_citymap[cid].city.Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm2_fight");
	}
	if((kingdom == m_citymap[cid].city.kingdom && m_citymap[cid].attacker.size() <= NEW_WORLD_RUSH_MIN)
	|| (kingdom != m_citymap[cid].city.kingdom && m_citymap[cid].defender.size() <= NEW_WORLD_RUSH_MIN))
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm2_min");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned cityseq = m_citymap[cid].city.seq;
	if(!pdata->city[cityseq].Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm2_fight");
	}

	int r = 0;
	unsigned otherseq = 0;
	NewWorldCityQueue &queue = kingdom==pdata->city[cityseq].kingdom?m_citymap[cid].attacker:m_citymap[cid].defender;
	NewWorldCityQueue::iterator it=queue.begin();
	for(;it!=queue.end();++it)
	{
		++r;
		if(r <= NEW_WORLD_RUSH_MIN)
			continue;
		if(isHero(it->second))
		{
			otherseq = m_heromap[it->second].seq;
			if(!CanMove(pdata->hero[otherseq].status) ||  pdata->hero[otherseq].cid != cid)
				continue;
		}
		else if(!pdata->city[cityseq].vision[it->second.index].index.uid || !CanMove(pdata->city[cityseq].vision[it->second.index].status))
			continue;
		break;
	}
	if(it == queue.end())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm2_min");
	}

	pdata->changets = now;
	pdata->city[cityseq].ts = now;

	NewWorldHero &loser = isHero(it->second)?pdata->hero[otherseq]:pdata->city[cityseq].vision[it->second.index];
	loser.ts = now;
	loser.hp = max(0, loser.hp - cd[lv-1]);
	if(loser.hp < NEW_WORLD_HERO_MIN)
	{
		if(isHero(loser.index))
		{
			loser.cid = getCapital(loser.kingdom);
			loser.status = NewWorldHeroStatus_wait_defence;
			if(loser.kingdom)
			{
				--pdata->city[cityseq].count[loser.kingdom-1];
				++pdata->city[m_citymap[loser.cid].city.seq].count[loser.kingdom-1];
			}
		}
		else if(isVision(loser.index))
		{
			--pdata->city[cityseq].countV;
			if(pdata->city[cityseq].countV >= NEW_WORLD_CITY_VISION)
			{
				pdata->city[cityseq].countV = 0;
				for(unsigned count=0;count<NEW_WORLD_CITY_VISION;++count)
				{
					if(pdata->city[cityseq].vision[count].index.uid)
						++pdata->city[cityseq].countV;
				}
			}
			if(loser.kingdom)
				--pdata->city[cityseq].count[loser.kingdom-1];

			memset(&(pdata->city[cityseq].vision[loser.index.index]),0,sizeof(NewWorldHero));
		}
		else if(isNPC(loser.index))
		{
			--pdata->city[cityseq].countN;
			if(pdata->city[cityseq].countN > NEW_WORLD_BUY_NPC)
				pdata->city[cityseq].countN = 0;
		}
	}

	return 0;
}
int CDataNewWorld::jm3(unsigned jm, unsigned lv, unsigned cid, unsigned kingdom)
{
	const unsigned cd[NEW_WORLD_JM_LEVEL] =  {20, 30, 40};

	checkTick();

	if(!m_citymap.count(cid) || isCapital(cid))
		return R_ERR_DB;

	if(!m_citymap[cid].city.Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm3_fight");
	}
	if(m_citymap[cid].city.kingdom != kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm3_kingdom");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_citymap[cid].city.seq;
	if(!pdata->city[seq].Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm3_fight");
	}
	if(pdata->city[seq].kingdom != kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm3_kingdom");
	}

	m_citymap[cid].city.jm.jm3ts = pdata->city[seq].jm.jm3ts = now + cd[lv-1];

	pdata->city[seq].ts = now;
	pdata->changets = now;

	return 0;
}
int CDataNewWorld::jm4(unsigned jm, unsigned lv, unsigned cid, unsigned kingdom)
{
	const unsigned cd[NEW_WORLD_JM_LEVEL] =  {10, 20, 30};

	checkTick();

	if(!m_citymap.count(cid) || isCapital(cid))
		return R_ERR_DB;

	if(m_citymap[cid].city.Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm4_fight");
	}
	if(m_citymap[cid].city.kingdom != kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm4_kingdom");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_citymap[cid].city.seq;
	if(pdata->city[seq].Fighting())
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm4_fight");
	}
	if(pdata->city[seq].kingdom != kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_jm4_kingdom");
	}

	m_citymap[cid].city.jm.jm4ts = pdata->city[seq].jm.jm4ts = now + cd[lv-1];

	pdata->city[seq].ts = now;
	pdata->changets = now;

	return 0;
}
int CDataNewWorld::BuyNPC(unsigned uid, unsigned cid, unsigned kingdom)
{
	checkTick();

	if(!m_citymap.count(cid) || isCapital(cid))
		return R_ERR_DB;

	if(m_citymap[cid].city.countN >= NEW_WORLD_BUY_NPC)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_npc_full");
	}
	if(m_citymap[cid].city.kingdom != kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_npc_kingdom");
	}

	unsigned now = Time::GetGlobalTime();
	if(now == m_ts)
		++now;

	DataNewWorld *pdata = (DataNewWorld *)m_sh.GetAddress();
	if(pdata == NULL)
	{
		return R_ERR_DB;
	}
	CAutoLock lock(&(m_sh), true);

	unsigned seq = m_citymap[cid].city.seq;
	if(pdata->city[seq].countN >= NEW_WORLD_BUY_NPC)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_npc_full");
	}
	if(pdata->city[seq].kingdom != kingdom)
	{
		LOGIC_ERROR_RETURN_MSG("newworld_npc_kingdom");
	}

	m_citymap[cid].city.countN = pdata->city[seq].countN = min(NEW_WORLD_BUY_NPC, pdata->city[seq].countN + 10);

	pdata->city[seq].ts = now;
	pdata->changets = now;

	return 0;
}
