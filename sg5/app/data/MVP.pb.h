// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MVP.proto

#ifndef PROTOBUF_MVP_2eproto__INCLUDED
#define PROTOBUF_MVP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace MVP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MVP_2eproto();
void protobuf_AssignDesc_MVP_2eproto();
void protobuf_ShutdownFile_MVP_2eproto();

class MVPHero;
class MVPUser;
class MVP;

// ===================================================================

class MVPHero : public ::google::protobuf::Message {
 public:
  MVPHero();
  virtual ~MVPHero();

  MVPHero(const MVPHero& from);

  inline MVPHero& operator=(const MVPHero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVPHero& default_instance();

  void Swap(MVPHero* other);

  // implements Message ----------------------------------------------

  MVPHero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVPHero& from);
  void MergeFrom(const MVPHero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 lv = 2;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 2;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required uint32 dehp = 3;
  inline bool has_dehp() const;
  inline void clear_dehp();
  static const int kDehpFieldNumber = 3;
  inline ::google::protobuf::uint32 dehp() const;
  inline void set_dehp(::google::protobuf::uint32 value);

  // required bytes icon = 4;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 4;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const void* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // required bytes name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:MVP.MVPHero)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_dehp();
  inline void clear_has_dehp();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 lv_;
  ::std::string* icon_;
  ::std::string* name_;
  ::google::protobuf::uint32 dehp_;
  friend void  protobuf_AddDesc_MVP_2eproto();
  friend void protobuf_AssignDesc_MVP_2eproto();
  friend void protobuf_ShutdownFile_MVP_2eproto();

  void InitAsDefaultInstance();
  static MVPHero* default_instance_;
};
// -------------------------------------------------------------------

class MVPUser : public ::google::protobuf::Message {
 public:
  MVPUser();
  virtual ~MVPUser();

  MVPUser(const MVPUser& from);

  inline MVPUser& operator=(const MVPUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVPUser& default_instance();

  void Swap(MVPUser* other);

  // implements Message ----------------------------------------------

  MVPUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVPUser& from);
  void MergeFrom(const MVPUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // required uint32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes fig = 4;
  inline bool has_fig() const;
  inline void clear_fig();
  static const int kFigFieldNumber = 4;
  inline const ::std::string& fig() const;
  inline void set_fig(const ::std::string& value);
  inline void set_fig(const char* value);
  inline void set_fig(const void* value, size_t size);
  inline ::std::string* mutable_fig();
  inline ::std::string* release_fig();
  inline void set_allocated_fig(::std::string* fig);

  // required bytes sign = 5;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 5;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const void* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // required uint32 mcity = 6;
  inline bool has_mcity() const;
  inline void clear_mcity();
  static const int kMcityFieldNumber = 6;
  inline ::google::protobuf::uint32 mcity() const;
  inline void set_mcity(::google::protobuf::uint32 value);

  // required .MVP.MVPHero hero = 7;
  inline bool has_hero() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 7;
  inline const ::MVP::MVPHero& hero() const;
  inline ::MVP::MVPHero* mutable_hero();
  inline ::MVP::MVPHero* release_hero();
  inline void set_allocated_hero(::MVP::MVPHero* hero);

  // required uint32 fid = 8;
  inline bool has_fid() const;
  inline void clear_fid();
  static const int kFidFieldNumber = 8;
  inline ::google::protobuf::uint32 fid() const;
  inline void set_fid(::google::protobuf::uint32 value);

  // required uint32 fts = 9;
  inline bool has_fts() const;
  inline void clear_fts();
  static const int kFtsFieldNumber = 9;
  inline ::google::protobuf::uint32 fts() const;
  inline void set_fts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MVP.MVPUser)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fig();
  inline void clear_has_fig();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_mcity();
  inline void clear_has_mcity();
  inline void set_has_hero();
  inline void clear_has_hero();
  inline void set_has_fid();
  inline void clear_has_fid();
  inline void set_has_fts();
  inline void clear_has_fts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 uid_;
  ::std::string* name_;
  ::std::string* fig_;
  ::std::string* sign_;
  ::MVP::MVPHero* hero_;
  ::google::protobuf::uint32 mcity_;
  ::google::protobuf::uint32 fid_;
  ::google::protobuf::uint32 fts_;
  friend void  protobuf_AddDesc_MVP_2eproto();
  friend void protobuf_AssignDesc_MVP_2eproto();
  friend void protobuf_ShutdownFile_MVP_2eproto();

  void InitAsDefaultInstance();
  static MVPUser* default_instance_;
};
// -------------------------------------------------------------------

class MVP : public ::google::protobuf::Message {
 public:
  MVP();
  virtual ~MVP();

  MVP(const MVP& from);

  inline MVP& operator=(const MVP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MVP& default_instance();

  void Swap(MVP* other);

  // implements Message ----------------------------------------------

  MVP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MVP& from);
  void MergeFrom(const MVP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MVP.MVPUser user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::MVP::MVPUser& user(int index) const;
  inline ::MVP::MVPUser* mutable_user(int index);
  inline ::MVP::MVPUser* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
      mutable_user();

  // repeated .MVP.MVPUser player = 2;
  inline int player_size() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 2;
  inline const ::MVP::MVPUser& player(int index) const;
  inline ::MVP::MVPUser* mutable_player(int index);
  inline ::MVP::MVPUser* add_player();
  inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
      player() const;
  inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
      mutable_player();

  // repeated .MVP.MVPUser fight = 3;
  inline int fight_size() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 3;
  inline const ::MVP::MVPUser& fight(int index) const;
  inline ::MVP::MVPUser* mutable_fight(int index);
  inline ::MVP::MVPUser* add_fight();
  inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
      fight() const;
  inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
      mutable_fight();

  // repeated .MVP.MVPUser all = 4;
  inline int all_size() const;
  inline void clear_all();
  static const int kAllFieldNumber = 4;
  inline const ::MVP::MVPUser& all(int index) const;
  inline ::MVP::MVPUser* mutable_all(int index);
  inline ::MVP::MVPUser* add_all();
  inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
      all() const;
  inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
      mutable_all();

  // @@protoc_insertion_point(class_scope:MVP.MVP)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser > user_;
  ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser > player_;
  ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser > fight_;
  ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser > all_;
  friend void  protobuf_AddDesc_MVP_2eproto();
  friend void protobuf_AssignDesc_MVP_2eproto();
  friend void protobuf_ShutdownFile_MVP_2eproto();

  void InitAsDefaultInstance();
  static MVP* default_instance_;
};
// ===================================================================


// ===================================================================

// MVPHero

// required uint32 id = 1;
inline bool MVPHero::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVPHero::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVPHero::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVPHero::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MVPHero::id() const {
  // @@protoc_insertion_point(field_get:MVP.MVPHero.id)
  return id_;
}
inline void MVPHero::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPHero.id)
}

// required uint32 lv = 2;
inline bool MVPHero::has_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVPHero::set_has_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVPHero::clear_has_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVPHero::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 MVPHero::lv() const {
  // @@protoc_insertion_point(field_get:MVP.MVPHero.lv)
  return lv_;
}
inline void MVPHero::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPHero.lv)
}

// required uint32 dehp = 3;
inline bool MVPHero::has_dehp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MVPHero::set_has_dehp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MVPHero::clear_has_dehp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MVPHero::clear_dehp() {
  dehp_ = 0u;
  clear_has_dehp();
}
inline ::google::protobuf::uint32 MVPHero::dehp() const {
  // @@protoc_insertion_point(field_get:MVP.MVPHero.dehp)
  return dehp_;
}
inline void MVPHero::set_dehp(::google::protobuf::uint32 value) {
  set_has_dehp();
  dehp_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPHero.dehp)
}

// required bytes icon = 4;
inline bool MVPHero::has_icon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MVPHero::set_has_icon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MVPHero::clear_has_icon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MVPHero::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& MVPHero::icon() const {
  // @@protoc_insertion_point(field_get:MVP.MVPHero.icon)
  return *icon_;
}
inline void MVPHero::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:MVP.MVPHero.icon)
}
inline void MVPHero::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:MVP.MVPHero.icon)
}
inline void MVPHero::set_icon(const void* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MVP.MVPHero.icon)
}
inline ::std::string* MVPHero::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MVP.MVPHero.icon)
  return icon_;
}
inline ::std::string* MVPHero::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MVPHero::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MVP.MVPHero.icon)
}

// required bytes name = 5;
inline bool MVPHero::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MVPHero::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MVPHero::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MVPHero::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MVPHero::name() const {
  // @@protoc_insertion_point(field_get:MVP.MVPHero.name)
  return *name_;
}
inline void MVPHero::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:MVP.MVPHero.name)
}
inline void MVPHero::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:MVP.MVPHero.name)
}
inline void MVPHero::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MVP.MVPHero.name)
}
inline ::std::string* MVPHero::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MVP.MVPHero.name)
  return name_;
}
inline ::std::string* MVPHero::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MVPHero::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MVP.MVPHero.name)
}

// -------------------------------------------------------------------

// MVPUser

// required uint32 rank = 1;
inline bool MVPUser::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MVPUser::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MVPUser::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MVPUser::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 MVPUser::rank() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.rank)
  return rank_;
}
inline void MVPUser::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPUser.rank)
}

// required uint32 uid = 2;
inline bool MVPUser::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MVPUser::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MVPUser::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MVPUser::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 MVPUser::uid() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.uid)
  return uid_;
}
inline void MVPUser::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPUser.uid)
}

// required bytes name = 3;
inline bool MVPUser::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MVPUser::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MVPUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MVPUser::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MVPUser::name() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.name)
  return *name_;
}
inline void MVPUser::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:MVP.MVPUser.name)
}
inline void MVPUser::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:MVP.MVPUser.name)
}
inline void MVPUser::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MVP.MVPUser.name)
}
inline ::std::string* MVPUser::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MVP.MVPUser.name)
  return name_;
}
inline ::std::string* MVPUser::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MVPUser::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MVP.MVPUser.name)
}

// required bytes fig = 4;
inline bool MVPUser::has_fig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MVPUser::set_has_fig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MVPUser::clear_has_fig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MVPUser::clear_fig() {
  if (fig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fig_->clear();
  }
  clear_has_fig();
}
inline const ::std::string& MVPUser::fig() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.fig)
  return *fig_;
}
inline void MVPUser::set_fig(const ::std::string& value) {
  set_has_fig();
  if (fig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fig_ = new ::std::string;
  }
  fig_->assign(value);
  // @@protoc_insertion_point(field_set:MVP.MVPUser.fig)
}
inline void MVPUser::set_fig(const char* value) {
  set_has_fig();
  if (fig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fig_ = new ::std::string;
  }
  fig_->assign(value);
  // @@protoc_insertion_point(field_set_char:MVP.MVPUser.fig)
}
inline void MVPUser::set_fig(const void* value, size_t size) {
  set_has_fig();
  if (fig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fig_ = new ::std::string;
  }
  fig_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MVP.MVPUser.fig)
}
inline ::std::string* MVPUser::mutable_fig() {
  set_has_fig();
  if (fig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fig_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MVP.MVPUser.fig)
  return fig_;
}
inline ::std::string* MVPUser::release_fig() {
  clear_has_fig();
  if (fig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fig_;
    fig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MVPUser::set_allocated_fig(::std::string* fig) {
  if (fig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fig_;
  }
  if (fig) {
    set_has_fig();
    fig_ = fig;
  } else {
    clear_has_fig();
    fig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MVP.MVPUser.fig)
}

// required bytes sign = 5;
inline bool MVPUser::has_sign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MVPUser::set_has_sign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MVPUser::clear_has_sign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MVPUser::clear_sign() {
  if (sign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& MVPUser::sign() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.sign)
  return *sign_;
}
inline void MVPUser::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
  // @@protoc_insertion_point(field_set:MVP.MVPUser.sign)
}
inline void MVPUser::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
  // @@protoc_insertion_point(field_set_char:MVP.MVPUser.sign)
}
inline void MVPUser::set_sign(const void* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MVP.MVPUser.sign)
}
inline ::std::string* MVPUser::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MVP.MVPUser.sign)
  return sign_;
}
inline ::std::string* MVPUser::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MVPUser::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MVP.MVPUser.sign)
}

// required uint32 mcity = 6;
inline bool MVPUser::has_mcity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MVPUser::set_has_mcity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MVPUser::clear_has_mcity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MVPUser::clear_mcity() {
  mcity_ = 0u;
  clear_has_mcity();
}
inline ::google::protobuf::uint32 MVPUser::mcity() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.mcity)
  return mcity_;
}
inline void MVPUser::set_mcity(::google::protobuf::uint32 value) {
  set_has_mcity();
  mcity_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPUser.mcity)
}

// required .MVP.MVPHero hero = 7;
inline bool MVPUser::has_hero() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MVPUser::set_has_hero() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MVPUser::clear_has_hero() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MVPUser::clear_hero() {
  if (hero_ != NULL) hero_->::MVP::MVPHero::Clear();
  clear_has_hero();
}
inline const ::MVP::MVPHero& MVPUser::hero() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.hero)
  return hero_ != NULL ? *hero_ : *default_instance_->hero_;
}
inline ::MVP::MVPHero* MVPUser::mutable_hero() {
  set_has_hero();
  if (hero_ == NULL) hero_ = new ::MVP::MVPHero;
  // @@protoc_insertion_point(field_mutable:MVP.MVPUser.hero)
  return hero_;
}
inline ::MVP::MVPHero* MVPUser::release_hero() {
  clear_has_hero();
  ::MVP::MVPHero* temp = hero_;
  hero_ = NULL;
  return temp;
}
inline void MVPUser::set_allocated_hero(::MVP::MVPHero* hero) {
  delete hero_;
  hero_ = hero;
  if (hero) {
    set_has_hero();
  } else {
    clear_has_hero();
  }
  // @@protoc_insertion_point(field_set_allocated:MVP.MVPUser.hero)
}

// required uint32 fid = 8;
inline bool MVPUser::has_fid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MVPUser::set_has_fid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MVPUser::clear_has_fid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MVPUser::clear_fid() {
  fid_ = 0u;
  clear_has_fid();
}
inline ::google::protobuf::uint32 MVPUser::fid() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.fid)
  return fid_;
}
inline void MVPUser::set_fid(::google::protobuf::uint32 value) {
  set_has_fid();
  fid_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPUser.fid)
}

// required uint32 fts = 9;
inline bool MVPUser::has_fts() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MVPUser::set_has_fts() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MVPUser::clear_has_fts() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MVPUser::clear_fts() {
  fts_ = 0u;
  clear_has_fts();
}
inline ::google::protobuf::uint32 MVPUser::fts() const {
  // @@protoc_insertion_point(field_get:MVP.MVPUser.fts)
  return fts_;
}
inline void MVPUser::set_fts(::google::protobuf::uint32 value) {
  set_has_fts();
  fts_ = value;
  // @@protoc_insertion_point(field_set:MVP.MVPUser.fts)
}

// -------------------------------------------------------------------

// MVP

// repeated .MVP.MVPUser user = 1;
inline int MVP::user_size() const {
  return user_.size();
}
inline void MVP::clear_user() {
  user_.Clear();
}
inline const ::MVP::MVPUser& MVP::user(int index) const {
  // @@protoc_insertion_point(field_get:MVP.MVP.user)
  return user_.Get(index);
}
inline ::MVP::MVPUser* MVP::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:MVP.MVP.user)
  return user_.Mutable(index);
}
inline ::MVP::MVPUser* MVP::add_user() {
  // @@protoc_insertion_point(field_add:MVP.MVP.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
MVP::user() const {
  // @@protoc_insertion_point(field_list:MVP.MVP.user)
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
MVP::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:MVP.MVP.user)
  return &user_;
}

// repeated .MVP.MVPUser player = 2;
inline int MVP::player_size() const {
  return player_.size();
}
inline void MVP::clear_player() {
  player_.Clear();
}
inline const ::MVP::MVPUser& MVP::player(int index) const {
  // @@protoc_insertion_point(field_get:MVP.MVP.player)
  return player_.Get(index);
}
inline ::MVP::MVPUser* MVP::mutable_player(int index) {
  // @@protoc_insertion_point(field_mutable:MVP.MVP.player)
  return player_.Mutable(index);
}
inline ::MVP::MVPUser* MVP::add_player() {
  // @@protoc_insertion_point(field_add:MVP.MVP.player)
  return player_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
MVP::player() const {
  // @@protoc_insertion_point(field_list:MVP.MVP.player)
  return player_;
}
inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
MVP::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:MVP.MVP.player)
  return &player_;
}

// repeated .MVP.MVPUser fight = 3;
inline int MVP::fight_size() const {
  return fight_.size();
}
inline void MVP::clear_fight() {
  fight_.Clear();
}
inline const ::MVP::MVPUser& MVP::fight(int index) const {
  // @@protoc_insertion_point(field_get:MVP.MVP.fight)
  return fight_.Get(index);
}
inline ::MVP::MVPUser* MVP::mutable_fight(int index) {
  // @@protoc_insertion_point(field_mutable:MVP.MVP.fight)
  return fight_.Mutable(index);
}
inline ::MVP::MVPUser* MVP::add_fight() {
  // @@protoc_insertion_point(field_add:MVP.MVP.fight)
  return fight_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
MVP::fight() const {
  // @@protoc_insertion_point(field_list:MVP.MVP.fight)
  return fight_;
}
inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
MVP::mutable_fight() {
  // @@protoc_insertion_point(field_mutable_list:MVP.MVP.fight)
  return &fight_;
}

// repeated .MVP.MVPUser all = 4;
inline int MVP::all_size() const {
  return all_.size();
}
inline void MVP::clear_all() {
  all_.Clear();
}
inline const ::MVP::MVPUser& MVP::all(int index) const {
  // @@protoc_insertion_point(field_get:MVP.MVP.all)
  return all_.Get(index);
}
inline ::MVP::MVPUser* MVP::mutable_all(int index) {
  // @@protoc_insertion_point(field_mutable:MVP.MVP.all)
  return all_.Mutable(index);
}
inline ::MVP::MVPUser* MVP::add_all() {
  // @@protoc_insertion_point(field_add:MVP.MVP.all)
  return all_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >&
MVP::all() const {
  // @@protoc_insertion_point(field_list:MVP.MVP.all)
  return all_;
}
inline ::google::protobuf::RepeatedPtrField< ::MVP::MVPUser >*
MVP::mutable_all() {
  // @@protoc_insertion_point(field_mutable_list:MVP.MVP.all)
  return &all_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MVP

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MVP_2eproto__INCLUDED
