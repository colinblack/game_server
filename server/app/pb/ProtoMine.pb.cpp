// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoMine.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoMine.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ProtoMine {

namespace {

const ::google::protobuf::Descriptor* MineItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineRecord_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineInfoReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineInfoReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineInfoResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineInfoResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineNormalOpenReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineNormalOpenReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineKingdomOpenReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineKingdomOpenReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineOpenResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineOpenResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* DonateNormalReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DonateNormalReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* DonateKingdomReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DonateKingdomReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* DonateResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DonateResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineKingdomRewardReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineKingdomRewardReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineKingdomRewardResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineKingdomRewardResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineKingdomMinerRewardReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineKingdomMinerRewardReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineKingdomMinerRewardResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineKingdomMinerRewardResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineRecordReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineRecordReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineRecordResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineRecordResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SyncUserBaseInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SyncUserBaseInfo_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ProtoMine_2eproto() {
  protobuf_AddDesc_ProtoMine_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ProtoMine.proto");
  GOOGLE_CHECK(file != NULL);
  MineItem_descriptor_ = file->message_type(0);
  static const int MineItem_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, donate_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, is_donate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, name_),
  };
  MineItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineItem_descriptor_,
      MineItem::default_instance_,
      MineItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineItem));
  MineRecord_descriptor_ = file->message_type(1);
  static const int MineRecord_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, operate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, params_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, ts_),
  };
  MineRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineRecord_descriptor_,
      MineRecord::default_instance_,
      MineRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineRecord));
  MineInfoReq_descriptor_ = file->message_type(2);
  static const int MineInfoReq_offsets_[1] = {
  };
  MineInfoReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineInfoReq_descriptor_,
      MineInfoReq::default_instance_,
      MineInfoReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineInfoReq));
  MineInfoResp_descriptor_ = file->message_type(3);
  static const int MineInfoResp_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, mine_exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, mine_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, kingdom_mine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, normal_mine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, mine_normal_ts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, mine_reward_ts_),
  };
  MineInfoResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineInfoResp_descriptor_,
      MineInfoResp::default_instance_,
      MineInfoResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineInfoResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineInfoResp));
  MineNormalOpenReq_descriptor_ = file->message_type(4);
  static const int MineNormalOpenReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineNormalOpenReq, index_),
  };
  MineNormalOpenReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineNormalOpenReq_descriptor_,
      MineNormalOpenReq::default_instance_,
      MineNormalOpenReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineNormalOpenReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineNormalOpenReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineNormalOpenReq));
  MineKingdomOpenReq_descriptor_ = file->message_type(5);
  static const int MineKingdomOpenReq_offsets_[1] = {
  };
  MineKingdomOpenReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineKingdomOpenReq_descriptor_,
      MineKingdomOpenReq::default_instance_,
      MineKingdomOpenReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomOpenReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomOpenReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineKingdomOpenReq));
  MineOpenResp_descriptor_ = file->message_type(6);
  static const int MineOpenResp_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, mine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, assets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, mine_exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, mine_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, mine_normal_ts_),
  };
  MineOpenResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineOpenResp_descriptor_,
      MineOpenResp::default_instance_,
      MineOpenResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineOpenResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineOpenResp));
  DonateNormalReq_descriptor_ = file->message_type(7);
  static const int DonateNormalReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateNormalReq, index_),
  };
  DonateNormalReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DonateNormalReq_descriptor_,
      DonateNormalReq::default_instance_,
      DonateNormalReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateNormalReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateNormalReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DonateNormalReq));
  DonateKingdomReq_descriptor_ = file->message_type(8);
  static const int DonateKingdomReq_offsets_[1] = {
  };
  DonateKingdomReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DonateKingdomReq_descriptor_,
      DonateKingdomReq::default_instance_,
      DonateKingdomReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateKingdomReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateKingdomReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DonateKingdomReq));
  DonateResp_descriptor_ = file->message_type(9);
  static const int DonateResp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateResp, mine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateResp, assets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateResp, mine_exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateResp, mine_level_),
  };
  DonateResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DonateResp_descriptor_,
      DonateResp::default_instance_,
      DonateResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DonateResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DonateResp));
  MineKingdomRewardReq_descriptor_ = file->message_type(10);
  static const int MineKingdomRewardReq_offsets_[1] = {
  };
  MineKingdomRewardReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineKingdomRewardReq_descriptor_,
      MineKingdomRewardReq::default_instance_,
      MineKingdomRewardReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineKingdomRewardReq));
  MineKingdomRewardResp_descriptor_ = file->message_type(11);
  static const int MineKingdomRewardResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardResp, op_ts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardResp, assets_),
  };
  MineKingdomRewardResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineKingdomRewardResp_descriptor_,
      MineKingdomRewardResp::default_instance_,
      MineKingdomRewardResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineKingdomRewardResp));
  MineKingdomMinerRewardReq_descriptor_ = file->message_type(12);
  static const int MineKingdomMinerRewardReq_offsets_[1] = {
  };
  MineKingdomMinerRewardReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineKingdomMinerRewardReq_descriptor_,
      MineKingdomMinerRewardReq::default_instance_,
      MineKingdomMinerRewardReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomMinerRewardReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomMinerRewardReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineKingdomMinerRewardReq));
  MineKingdomMinerRewardResp_descriptor_ = file->message_type(13);
  static const int MineKingdomMinerRewardResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomMinerRewardResp, op_ts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomMinerRewardResp, exp_),
  };
  MineKingdomMinerRewardResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineKingdomMinerRewardResp_descriptor_,
      MineKingdomMinerRewardResp::default_instance_,
      MineKingdomMinerRewardResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomMinerRewardResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomMinerRewardResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineKingdomMinerRewardResp));
  MineRecordReq_descriptor_ = file->message_type(14);
  static const int MineRecordReq_offsets_[1] = {
  };
  MineRecordReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineRecordReq_descriptor_,
      MineRecordReq::default_instance_,
      MineRecordReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecordReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecordReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineRecordReq));
  MineRecordResp_descriptor_ = file->message_type(15);
  static const int MineRecordResp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecordResp, records_),
  };
  MineRecordResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineRecordResp_descriptor_,
      MineRecordResp::default_instance_,
      MineRecordResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecordResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineRecordResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineRecordResp));
  SyncUserBaseInfo_descriptor_ = file->message_type(16);
  static const int SyncUserBaseInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncUserBaseInfo, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncUserBaseInfo, level_),
  };
  SyncUserBaseInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SyncUserBaseInfo_descriptor_,
      SyncUserBaseInfo::default_instance_,
      SyncUserBaseInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncUserBaseInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncUserBaseInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SyncUserBaseInfo));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ProtoMine_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineItem_descriptor_, &MineItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineRecord_descriptor_, &MineRecord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineInfoReq_descriptor_, &MineInfoReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineInfoResp_descriptor_, &MineInfoResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineNormalOpenReq_descriptor_, &MineNormalOpenReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineKingdomOpenReq_descriptor_, &MineKingdomOpenReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineOpenResp_descriptor_, &MineOpenResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DonateNormalReq_descriptor_, &DonateNormalReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DonateKingdomReq_descriptor_, &DonateKingdomReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DonateResp_descriptor_, &DonateResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineKingdomRewardReq_descriptor_, &MineKingdomRewardReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineKingdomRewardResp_descriptor_, &MineKingdomRewardResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineKingdomMinerRewardReq_descriptor_, &MineKingdomMinerRewardReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineKingdomMinerRewardResp_descriptor_, &MineKingdomMinerRewardResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineRecordReq_descriptor_, &MineRecordReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineRecordResp_descriptor_, &MineRecordResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SyncUserBaseInfo_descriptor_, &SyncUserBaseInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ProtoMine_2eproto() {
  delete MineItem::default_instance_;
  delete MineItem_reflection_;
  delete MineRecord::default_instance_;
  delete MineRecord_reflection_;
  delete MineInfoReq::default_instance_;
  delete MineInfoReq_reflection_;
  delete MineInfoResp::default_instance_;
  delete MineInfoResp_reflection_;
  delete MineNormalOpenReq::default_instance_;
  delete MineNormalOpenReq_reflection_;
  delete MineKingdomOpenReq::default_instance_;
  delete MineKingdomOpenReq_reflection_;
  delete MineOpenResp::default_instance_;
  delete MineOpenResp_reflection_;
  delete DonateNormalReq::default_instance_;
  delete DonateNormalReq_reflection_;
  delete DonateKingdomReq::default_instance_;
  delete DonateKingdomReq_reflection_;
  delete DonateResp::default_instance_;
  delete DonateResp_reflection_;
  delete MineKingdomRewardReq::default_instance_;
  delete MineKingdomRewardReq_reflection_;
  delete MineKingdomRewardResp::default_instance_;
  delete MineKingdomRewardResp_reflection_;
  delete MineKingdomMinerRewardReq::default_instance_;
  delete MineKingdomMinerRewardReq_reflection_;
  delete MineKingdomMinerRewardResp::default_instance_;
  delete MineKingdomMinerRewardResp_reflection_;
  delete MineRecordReq::default_instance_;
  delete MineRecordReq_reflection_;
  delete MineRecordResp::default_instance_;
  delete MineRecordResp_reflection_;
  delete SyncUserBaseInfo::default_instance_;
  delete SyncUserBaseInfo_reflection_;
}

void protobuf_AddDesc_ProtoMine_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::DataCommon::protobuf_AddDesc_DataCommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017ProtoMine.proto\022\tProtoMine\032\020DataCommon"
    ".proto\"[\n\010MineItem\022\013\n\003uid\030\001 \002(\r\022\r\n\005level"
    "\030\002 \002(\r\022\022\n\ndonate_cnt\030\003 \002(\r\022\021\n\tis_donate\030"
    "\004 \002(\010\022\014\n\004name\030\005 \002(\014\"c\n\nMineRecord\022\017\n\007ope"
    "rate\030\001 \002(\014\022\016\n\006target\030\002 \002(\014\022\n\n\002op\030\003 \002(\r\022\014"
    "\n\004type\030\004 \002(\r\022\016\n\006params\030\005 \003(\r\022\n\n\002ts\030\006 \002(\r"
    "\"\r\n\013MineInfoReq\"\271\001\n\014MineInfoResp\022\020\n\010mine"
    "_exp\030\001 \002(\r\022\022\n\nmine_level\030\002 \002(\r\022)\n\014kingdo"
    "m_mine\030\003 \002(\0132\023.ProtoMine.MineItem\022(\n\013nor"
    "mal_mine\030\004 \003(\0132\023.ProtoMine.MineItem\022\026\n\016m"
    "ine_normal_ts\030\005 \002(\r\022\026\n\016mine_reward_ts\030\006 "
    "\002(\r\"\"\n\021MineNormalOpenReq\022\r\n\005index\030\001 \002(\r\""
    "\024\n\022MineKingdomOpenReq\"\234\001\n\014MineOpenResp\022!"
    "\n\004mine\030\001 \002(\0132\023.ProtoMine.MineItem\022+\n\006ass"
    "ets\030\002 \002(\0132\033.DataCommon.UserResourceCPP\022\020"
    "\n\010mine_exp\030\003 \002(\r\022\022\n\nmine_level\030\004 \002(\r\022\026\n\016"
    "mine_normal_ts\030\005 \001(\r\" \n\017DonateNormalReq\022"
    "\r\n\005index\030\001 \002(\r\"\022\n\020DonateKingdomReq\"\202\001\n\nD"
    "onateResp\022!\n\004mine\030\001 \002(\0132\023.ProtoMine.Mine"
    "Item\022+\n\006assets\030\002 \002(\0132\033.DataCommon.UserRe"
    "sourceCPP\022\020\n\010mine_exp\030\003 \002(\r\022\022\n\nmine_leve"
    "l\030\004 \002(\r\"\026\n\024MineKingdomRewardReq\"S\n\025MineK"
    "ingdomRewardResp\022\r\n\005op_ts\030\001 \002(\r\022+\n\006asset"
    "s\030\002 \002(\0132\033.DataCommon.UserResourceCPP\"\033\n\031"
    "MineKingdomMinerRewardReq\"S\n\032MineKingdom"
    "MinerRewardResp\022\r\n\005op_ts\030\001 \002(\r\022&\n\003exp\030\002 "
    "\002(\0132\031.DataCommon.RewardItemCPP\"\017\n\rMineRe"
    "cordReq\"8\n\016MineRecordResp\022&\n\007records\030\001 \003"
    "(\0132\025.ProtoMine.MineRecord\"P\n\020SyncUserBas"
    "eInfo\022-\n\004info\030\001 \002(\0132\037.DataCommon.CommonB"
    "aseRewardCPP\022\r\n\005level\030\002 \002(\r", 1227);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ProtoMine.proto", &protobuf_RegisterTypes);
  MineItem::default_instance_ = new MineItem();
  MineRecord::default_instance_ = new MineRecord();
  MineInfoReq::default_instance_ = new MineInfoReq();
  MineInfoResp::default_instance_ = new MineInfoResp();
  MineNormalOpenReq::default_instance_ = new MineNormalOpenReq();
  MineKingdomOpenReq::default_instance_ = new MineKingdomOpenReq();
  MineOpenResp::default_instance_ = new MineOpenResp();
  DonateNormalReq::default_instance_ = new DonateNormalReq();
  DonateKingdomReq::default_instance_ = new DonateKingdomReq();
  DonateResp::default_instance_ = new DonateResp();
  MineKingdomRewardReq::default_instance_ = new MineKingdomRewardReq();
  MineKingdomRewardResp::default_instance_ = new MineKingdomRewardResp();
  MineKingdomMinerRewardReq::default_instance_ = new MineKingdomMinerRewardReq();
  MineKingdomMinerRewardResp::default_instance_ = new MineKingdomMinerRewardResp();
  MineRecordReq::default_instance_ = new MineRecordReq();
  MineRecordResp::default_instance_ = new MineRecordResp();
  SyncUserBaseInfo::default_instance_ = new SyncUserBaseInfo();
  MineItem::default_instance_->InitAsDefaultInstance();
  MineRecord::default_instance_->InitAsDefaultInstance();
  MineInfoReq::default_instance_->InitAsDefaultInstance();
  MineInfoResp::default_instance_->InitAsDefaultInstance();
  MineNormalOpenReq::default_instance_->InitAsDefaultInstance();
  MineKingdomOpenReq::default_instance_->InitAsDefaultInstance();
  MineOpenResp::default_instance_->InitAsDefaultInstance();
  DonateNormalReq::default_instance_->InitAsDefaultInstance();
  DonateKingdomReq::default_instance_->InitAsDefaultInstance();
  DonateResp::default_instance_->InitAsDefaultInstance();
  MineKingdomRewardReq::default_instance_->InitAsDefaultInstance();
  MineKingdomRewardResp::default_instance_->InitAsDefaultInstance();
  MineKingdomMinerRewardReq::default_instance_->InitAsDefaultInstance();
  MineKingdomMinerRewardResp::default_instance_->InitAsDefaultInstance();
  MineRecordReq::default_instance_->InitAsDefaultInstance();
  MineRecordResp::default_instance_->InitAsDefaultInstance();
  SyncUserBaseInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoMine_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoMine_2eproto {
  StaticDescriptorInitializer_ProtoMine_2eproto() {
    protobuf_AddDesc_ProtoMine_2eproto();
  }
} static_descriptor_initializer_ProtoMine_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MineItem::kUidFieldNumber;
const int MineItem::kLevelFieldNumber;
const int MineItem::kDonateCntFieldNumber;
const int MineItem::kIsDonateFieldNumber;
const int MineItem::kNameFieldNumber;
#endif  // !_MSC_VER

MineItem::MineItem()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineItem)
}

void MineItem::InitAsDefaultInstance() {
}

MineItem::MineItem(const MineItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineItem)
}

void MineItem::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uid_ = 0u;
  level_ = 0u;
  donate_cnt_ = 0u;
  is_donate_ = false;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineItem::~MineItem() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineItem)
  SharedDtor();
}

void MineItem::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void MineItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineItem_descriptor_;
}

const MineItem& MineItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineItem* MineItem::default_instance_ = NULL;

MineItem* MineItem::New() const {
  return new MineItem;
}

void MineItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MineItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(uid_, is_donate_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 uid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // required uint32 level = 2;
      case 2: {
        if (tag == 16) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_donate_cnt;
        break;
      }

      // required uint32 donate_cnt = 3;
      case 3: {
        if (tag == 24) {
         parse_donate_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &donate_cnt_)));
          set_has_donate_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_is_donate;
        break;
      }

      // required bool is_donate = 4;
      case 4: {
        if (tag == 32) {
         parse_is_donate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_donate_)));
          set_has_is_donate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }

      // required bytes name = 5;
      case 5: {
        if (tag == 42) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineItem)
  return false;
#undef DO_
}

void MineItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineItem)
  // required uint32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->level(), output);
  }

  // required uint32 donate_cnt = 3;
  if (has_donate_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->donate_cnt(), output);
  }

  // required bool is_donate = 4;
  if (has_is_donate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_donate(), output);
  }

  // required bytes name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineItem)
}

::google::protobuf::uint8* MineItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineItem)
  // required uint32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint32 level = 2;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->level(), target);
  }

  // required uint32 donate_cnt = 3;
  if (has_donate_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->donate_cnt(), target);
  }

  // required bool is_donate = 4;
  if (has_is_donate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->is_donate(), target);
  }

  // required bytes name = 5;
  if (has_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineItem)
  return target;
}

int MineItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // required uint32 donate_cnt = 3;
    if (has_donate_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->donate_cnt());
    }

    // required bool is_donate = 4;
    if (has_is_donate()) {
      total_size += 1 + 1;
    }

    // required bytes name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineItem::MergeFrom(const MineItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_donate_cnt()) {
      set_donate_cnt(from.donate_cnt());
    }
    if (from.has_is_donate()) {
      set_is_donate(from.is_donate());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineItem::CopyFrom(const MineItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void MineItem::Swap(MineItem* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(level_, other->level_);
    std::swap(donate_cnt_, other->donate_cnt_);
    std::swap(is_donate_, other->is_donate_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineItem_descriptor_;
  metadata.reflection = MineItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineRecord::kOperateFieldNumber;
const int MineRecord::kTargetFieldNumber;
const int MineRecord::kOpFieldNumber;
const int MineRecord::kTypeFieldNumber;
const int MineRecord::kParamsFieldNumber;
const int MineRecord::kTsFieldNumber;
#endif  // !_MSC_VER

MineRecord::MineRecord()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineRecord)
}

void MineRecord::InitAsDefaultInstance() {
}

MineRecord::MineRecord(const MineRecord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineRecord)
}

void MineRecord::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  operate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  target_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  op_ = 0u;
  type_ = 0u;
  ts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineRecord::~MineRecord() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineRecord)
  SharedDtor();
}

void MineRecord::SharedDtor() {
  if (operate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operate_;
  }
  if (target_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete target_;
  }
  if (this != default_instance_) {
  }
}

void MineRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineRecord_descriptor_;
}

const MineRecord& MineRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineRecord* MineRecord::default_instance_ = NULL;

MineRecord* MineRecord::New() const {
  return new MineRecord;
}

void MineRecord::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MineRecord*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 47) {
    ZR_(op_, type_);
    if (has_operate()) {
      if (operate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        operate_->clear();
      }
    }
    if (has_target()) {
      if (target_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        target_->clear();
      }
    }
    ts_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  params_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes operate = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_operate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_target;
        break;
      }

      // required bytes target = 2;
      case 2: {
        if (tag == 18) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_op;
        break;
      }

      // required uint32 op = 3;
      case 3: {
        if (tag == 24) {
         parse_op:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &op_)));
          set_has_op();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // required uint32 type = 4;
      case 4: {
        if (tag == 32) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_params;
        break;
      }

      // repeated uint32 params = 5;
      case 5: {
        if (tag == 40) {
         parse_params:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_params())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_params())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_params;
        if (input->ExpectTag(48)) goto parse_ts;
        break;
      }

      // required uint32 ts = 6;
      case 6: {
        if (tag == 48) {
         parse_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineRecord)
  return false;
#undef DO_
}

void MineRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineRecord)
  // required bytes operate = 1;
  if (has_operate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->operate(), output);
  }

  // required bytes target = 2;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->target(), output);
  }

  // required uint32 op = 3;
  if (has_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->op(), output);
  }

  // required uint32 type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
  }

  // repeated uint32 params = 5;
  for (int i = 0; i < this->params_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->params(i), output);
  }

  // required uint32 ts = 6;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineRecord)
}

::google::protobuf::uint8* MineRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineRecord)
  // required bytes operate = 1;
  if (has_operate()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->operate(), target);
  }

  // required bytes target = 2;
  if (has_target()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->target(), target);
  }

  // required uint32 op = 3;
  if (has_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->op(), target);
  }

  // required uint32 type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
  }

  // repeated uint32 params = 5;
  for (int i = 0; i < this->params_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(5, this->params(i), target);
  }

  // required uint32 ts = 6;
  if (has_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->ts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineRecord)
  return target;
}

int MineRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes operate = 1;
    if (has_operate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->operate());
    }

    // required bytes target = 2;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target());
    }

    // required uint32 op = 3;
    if (has_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->op());
    }

    // required uint32 type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 ts = 6;
    if (has_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ts());
    }

  }
  // repeated uint32 params = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->params_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->params(i));
    }
    total_size += 1 * this->params_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineRecord::MergeFrom(const MineRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  params_.MergeFrom(from.params_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_operate()) {
      set_operate(from.operate());
    }
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_op()) {
      set_op(from.op());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineRecord::CopyFrom(const MineRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000002f) != 0x0000002f) return false;

  return true;
}

void MineRecord::Swap(MineRecord* other) {
  if (other != this) {
    std::swap(operate_, other->operate_);
    std::swap(target_, other->target_);
    std::swap(op_, other->op_);
    std::swap(type_, other->type_);
    params_.Swap(&other->params_);
    std::swap(ts_, other->ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineRecord_descriptor_;
  metadata.reflection = MineRecord_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

MineInfoReq::MineInfoReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineInfoReq)
}

void MineInfoReq::InitAsDefaultInstance() {
}

MineInfoReq::MineInfoReq(const MineInfoReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineInfoReq)
}

void MineInfoReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineInfoReq::~MineInfoReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineInfoReq)
  SharedDtor();
}

void MineInfoReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineInfoReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineInfoReq_descriptor_;
}

const MineInfoReq& MineInfoReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineInfoReq* MineInfoReq::default_instance_ = NULL;

MineInfoReq* MineInfoReq::New() const {
  return new MineInfoReq;
}

void MineInfoReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineInfoReq)
  return false;
#undef DO_
}

void MineInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineInfoReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineInfoReq)
}

::google::protobuf::uint8* MineInfoReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineInfoReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineInfoReq)
  return target;
}

int MineInfoReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineInfoReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineInfoReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineInfoReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineInfoReq::MergeFrom(const MineInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineInfoReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineInfoReq::CopyFrom(const MineInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineInfoReq::IsInitialized() const {

  return true;
}

void MineInfoReq::Swap(MineInfoReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineInfoReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineInfoReq_descriptor_;
  metadata.reflection = MineInfoReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineInfoResp::kMineExpFieldNumber;
const int MineInfoResp::kMineLevelFieldNumber;
const int MineInfoResp::kKingdomMineFieldNumber;
const int MineInfoResp::kNormalMineFieldNumber;
const int MineInfoResp::kMineNormalTsFieldNumber;
const int MineInfoResp::kMineRewardTsFieldNumber;
#endif  // !_MSC_VER

MineInfoResp::MineInfoResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineInfoResp)
}

void MineInfoResp::InitAsDefaultInstance() {
  kingdom_mine_ = const_cast< ::ProtoMine::MineItem*>(&::ProtoMine::MineItem::default_instance());
}

MineInfoResp::MineInfoResp(const MineInfoResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineInfoResp)
}

void MineInfoResp::SharedCtor() {
  _cached_size_ = 0;
  mine_exp_ = 0u;
  mine_level_ = 0u;
  kingdom_mine_ = NULL;
  mine_normal_ts_ = 0u;
  mine_reward_ts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineInfoResp::~MineInfoResp() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineInfoResp)
  SharedDtor();
}

void MineInfoResp::SharedDtor() {
  if (this != default_instance_) {
    delete kingdom_mine_;
  }
}

void MineInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineInfoResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineInfoResp_descriptor_;
}

const MineInfoResp& MineInfoResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineInfoResp* MineInfoResp::default_instance_ = NULL;

MineInfoResp* MineInfoResp::New() const {
  return new MineInfoResp;
}

void MineInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MineInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 55) {
    ZR_(mine_exp_, mine_level_);
    ZR_(mine_normal_ts_, mine_reward_ts_);
    if (has_kingdom_mine()) {
      if (kingdom_mine_ != NULL) kingdom_mine_->::ProtoMine::MineItem::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  normal_mine_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 mine_exp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_exp_)));
          set_has_mine_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mine_level;
        break;
      }

      // required uint32 mine_level = 2;
      case 2: {
        if (tag == 16) {
         parse_mine_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_level_)));
          set_has_mine_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_kingdom_mine;
        break;
      }

      // required .ProtoMine.MineItem kingdom_mine = 3;
      case 3: {
        if (tag == 26) {
         parse_kingdom_mine:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kingdom_mine()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_normal_mine;
        break;
      }

      // repeated .ProtoMine.MineItem normal_mine = 4;
      case 4: {
        if (tag == 34) {
         parse_normal_mine:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_normal_mine()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_normal_mine;
        if (input->ExpectTag(40)) goto parse_mine_normal_ts;
        break;
      }

      // required uint32 mine_normal_ts = 5;
      case 5: {
        if (tag == 40) {
         parse_mine_normal_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_normal_ts_)));
          set_has_mine_normal_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_mine_reward_ts;
        break;
      }

      // required uint32 mine_reward_ts = 6;
      case 6: {
        if (tag == 48) {
         parse_mine_reward_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_reward_ts_)));
          set_has_mine_reward_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineInfoResp)
  return false;
#undef DO_
}

void MineInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineInfoResp)
  // required uint32 mine_exp = 1;
  if (has_mine_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mine_exp(), output);
  }

  // required uint32 mine_level = 2;
  if (has_mine_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mine_level(), output);
  }

  // required .ProtoMine.MineItem kingdom_mine = 3;
  if (has_kingdom_mine()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->kingdom_mine(), output);
  }

  // repeated .ProtoMine.MineItem normal_mine = 4;
  for (int i = 0; i < this->normal_mine_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->normal_mine(i), output);
  }

  // required uint32 mine_normal_ts = 5;
  if (has_mine_normal_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->mine_normal_ts(), output);
  }

  // required uint32 mine_reward_ts = 6;
  if (has_mine_reward_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->mine_reward_ts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineInfoResp)
}

::google::protobuf::uint8* MineInfoResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineInfoResp)
  // required uint32 mine_exp = 1;
  if (has_mine_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->mine_exp(), target);
  }

  // required uint32 mine_level = 2;
  if (has_mine_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->mine_level(), target);
  }

  // required .ProtoMine.MineItem kingdom_mine = 3;
  if (has_kingdom_mine()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->kingdom_mine(), target);
  }

  // repeated .ProtoMine.MineItem normal_mine = 4;
  for (int i = 0; i < this->normal_mine_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->normal_mine(i), target);
  }

  // required uint32 mine_normal_ts = 5;
  if (has_mine_normal_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->mine_normal_ts(), target);
  }

  // required uint32 mine_reward_ts = 6;
  if (has_mine_reward_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->mine_reward_ts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineInfoResp)
  return target;
}

int MineInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 mine_exp = 1;
    if (has_mine_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_exp());
    }

    // required uint32 mine_level = 2;
    if (has_mine_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_level());
    }

    // required .ProtoMine.MineItem kingdom_mine = 3;
    if (has_kingdom_mine()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kingdom_mine());
    }

    // required uint32 mine_normal_ts = 5;
    if (has_mine_normal_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_normal_ts());
    }

    // required uint32 mine_reward_ts = 6;
    if (has_mine_reward_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_reward_ts());
    }

  }
  // repeated .ProtoMine.MineItem normal_mine = 4;
  total_size += 1 * this->normal_mine_size();
  for (int i = 0; i < this->normal_mine_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->normal_mine(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineInfoResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineInfoResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineInfoResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineInfoResp::MergeFrom(const MineInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  normal_mine_.MergeFrom(from.normal_mine_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mine_exp()) {
      set_mine_exp(from.mine_exp());
    }
    if (from.has_mine_level()) {
      set_mine_level(from.mine_level());
    }
    if (from.has_kingdom_mine()) {
      mutable_kingdom_mine()->::ProtoMine::MineItem::MergeFrom(from.kingdom_mine());
    }
    if (from.has_mine_normal_ts()) {
      set_mine_normal_ts(from.mine_normal_ts());
    }
    if (from.has_mine_reward_ts()) {
      set_mine_reward_ts(from.mine_reward_ts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineInfoResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineInfoResp::CopyFrom(const MineInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000037) != 0x00000037) return false;

  if (has_kingdom_mine()) {
    if (!this->kingdom_mine().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->normal_mine())) return false;
  return true;
}

void MineInfoResp::Swap(MineInfoResp* other) {
  if (other != this) {
    std::swap(mine_exp_, other->mine_exp_);
    std::swap(mine_level_, other->mine_level_);
    std::swap(kingdom_mine_, other->kingdom_mine_);
    normal_mine_.Swap(&other->normal_mine_);
    std::swap(mine_normal_ts_, other->mine_normal_ts_);
    std::swap(mine_reward_ts_, other->mine_reward_ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineInfoResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineInfoResp_descriptor_;
  metadata.reflection = MineInfoResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineNormalOpenReq::kIndexFieldNumber;
#endif  // !_MSC_VER

MineNormalOpenReq::MineNormalOpenReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineNormalOpenReq)
}

void MineNormalOpenReq::InitAsDefaultInstance() {
}

MineNormalOpenReq::MineNormalOpenReq(const MineNormalOpenReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineNormalOpenReq)
}

void MineNormalOpenReq::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineNormalOpenReq::~MineNormalOpenReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineNormalOpenReq)
  SharedDtor();
}

void MineNormalOpenReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineNormalOpenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineNormalOpenReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineNormalOpenReq_descriptor_;
}

const MineNormalOpenReq& MineNormalOpenReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineNormalOpenReq* MineNormalOpenReq::default_instance_ = NULL;

MineNormalOpenReq* MineNormalOpenReq::New() const {
  return new MineNormalOpenReq;
}

void MineNormalOpenReq::Clear() {
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineNormalOpenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineNormalOpenReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineNormalOpenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineNormalOpenReq)
  return false;
#undef DO_
}

void MineNormalOpenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineNormalOpenReq)
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineNormalOpenReq)
}

::google::protobuf::uint8* MineNormalOpenReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineNormalOpenReq)
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineNormalOpenReq)
  return target;
}

int MineNormalOpenReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineNormalOpenReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineNormalOpenReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineNormalOpenReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineNormalOpenReq::MergeFrom(const MineNormalOpenReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineNormalOpenReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineNormalOpenReq::CopyFrom(const MineNormalOpenReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineNormalOpenReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MineNormalOpenReq::Swap(MineNormalOpenReq* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineNormalOpenReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineNormalOpenReq_descriptor_;
  metadata.reflection = MineNormalOpenReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

MineKingdomOpenReq::MineKingdomOpenReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineKingdomOpenReq)
}

void MineKingdomOpenReq::InitAsDefaultInstance() {
}

MineKingdomOpenReq::MineKingdomOpenReq(const MineKingdomOpenReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineKingdomOpenReq)
}

void MineKingdomOpenReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineKingdomOpenReq::~MineKingdomOpenReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineKingdomOpenReq)
  SharedDtor();
}

void MineKingdomOpenReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineKingdomOpenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineKingdomOpenReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineKingdomOpenReq_descriptor_;
}

const MineKingdomOpenReq& MineKingdomOpenReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineKingdomOpenReq* MineKingdomOpenReq::default_instance_ = NULL;

MineKingdomOpenReq* MineKingdomOpenReq::New() const {
  return new MineKingdomOpenReq;
}

void MineKingdomOpenReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineKingdomOpenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineKingdomOpenReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineKingdomOpenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineKingdomOpenReq)
  return false;
#undef DO_
}

void MineKingdomOpenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineKingdomOpenReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineKingdomOpenReq)
}

::google::protobuf::uint8* MineKingdomOpenReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineKingdomOpenReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineKingdomOpenReq)
  return target;
}

int MineKingdomOpenReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineKingdomOpenReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineKingdomOpenReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineKingdomOpenReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineKingdomOpenReq::MergeFrom(const MineKingdomOpenReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineKingdomOpenReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineKingdomOpenReq::CopyFrom(const MineKingdomOpenReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineKingdomOpenReq::IsInitialized() const {

  return true;
}

void MineKingdomOpenReq::Swap(MineKingdomOpenReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineKingdomOpenReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineKingdomOpenReq_descriptor_;
  metadata.reflection = MineKingdomOpenReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineOpenResp::kMineFieldNumber;
const int MineOpenResp::kAssetsFieldNumber;
const int MineOpenResp::kMineExpFieldNumber;
const int MineOpenResp::kMineLevelFieldNumber;
const int MineOpenResp::kMineNormalTsFieldNumber;
#endif  // !_MSC_VER

MineOpenResp::MineOpenResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineOpenResp)
}

void MineOpenResp::InitAsDefaultInstance() {
  mine_ = const_cast< ::ProtoMine::MineItem*>(&::ProtoMine::MineItem::default_instance());
  assets_ = const_cast< ::DataCommon::UserResourceCPP*>(&::DataCommon::UserResourceCPP::default_instance());
}

MineOpenResp::MineOpenResp(const MineOpenResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineOpenResp)
}

void MineOpenResp::SharedCtor() {
  _cached_size_ = 0;
  mine_ = NULL;
  assets_ = NULL;
  mine_exp_ = 0u;
  mine_level_ = 0u;
  mine_normal_ts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineOpenResp::~MineOpenResp() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineOpenResp)
  SharedDtor();
}

void MineOpenResp::SharedDtor() {
  if (this != default_instance_) {
    delete mine_;
    delete assets_;
  }
}

void MineOpenResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineOpenResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineOpenResp_descriptor_;
}

const MineOpenResp& MineOpenResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineOpenResp* MineOpenResp::default_instance_ = NULL;

MineOpenResp* MineOpenResp::New() const {
  return new MineOpenResp;
}

void MineOpenResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MineOpenResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(mine_exp_, mine_normal_ts_);
    if (has_mine()) {
      if (mine_ != NULL) mine_->::ProtoMine::MineItem::Clear();
    }
    if (has_assets()) {
      if (assets_ != NULL) assets_->::DataCommon::UserResourceCPP::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineOpenResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineOpenResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoMine.MineItem mine = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mine()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_assets;
        break;
      }

      // required .DataCommon.UserResourceCPP assets = 2;
      case 2: {
        if (tag == 18) {
         parse_assets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assets()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mine_exp;
        break;
      }

      // required uint32 mine_exp = 3;
      case 3: {
        if (tag == 24) {
         parse_mine_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_exp_)));
          set_has_mine_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_mine_level;
        break;
      }

      // required uint32 mine_level = 4;
      case 4: {
        if (tag == 32) {
         parse_mine_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_level_)));
          set_has_mine_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mine_normal_ts;
        break;
      }

      // optional uint32 mine_normal_ts = 5;
      case 5: {
        if (tag == 40) {
         parse_mine_normal_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_normal_ts_)));
          set_has_mine_normal_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineOpenResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineOpenResp)
  return false;
#undef DO_
}

void MineOpenResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineOpenResp)
  // required .ProtoMine.MineItem mine = 1;
  if (has_mine()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mine(), output);
  }

  // required .DataCommon.UserResourceCPP assets = 2;
  if (has_assets()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->assets(), output);
  }

  // required uint32 mine_exp = 3;
  if (has_mine_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->mine_exp(), output);
  }

  // required uint32 mine_level = 4;
  if (has_mine_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->mine_level(), output);
  }

  // optional uint32 mine_normal_ts = 5;
  if (has_mine_normal_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->mine_normal_ts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineOpenResp)
}

::google::protobuf::uint8* MineOpenResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineOpenResp)
  // required .ProtoMine.MineItem mine = 1;
  if (has_mine()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mine(), target);
  }

  // required .DataCommon.UserResourceCPP assets = 2;
  if (has_assets()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->assets(), target);
  }

  // required uint32 mine_exp = 3;
  if (has_mine_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->mine_exp(), target);
  }

  // required uint32 mine_level = 4;
  if (has_mine_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->mine_level(), target);
  }

  // optional uint32 mine_normal_ts = 5;
  if (has_mine_normal_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->mine_normal_ts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineOpenResp)
  return target;
}

int MineOpenResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoMine.MineItem mine = 1;
    if (has_mine()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mine());
    }

    // required .DataCommon.UserResourceCPP assets = 2;
    if (has_assets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assets());
    }

    // required uint32 mine_exp = 3;
    if (has_mine_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_exp());
    }

    // required uint32 mine_level = 4;
    if (has_mine_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_level());
    }

    // optional uint32 mine_normal_ts = 5;
    if (has_mine_normal_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_normal_ts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineOpenResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineOpenResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineOpenResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineOpenResp::MergeFrom(const MineOpenResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mine()) {
      mutable_mine()->::ProtoMine::MineItem::MergeFrom(from.mine());
    }
    if (from.has_assets()) {
      mutable_assets()->::DataCommon::UserResourceCPP::MergeFrom(from.assets());
    }
    if (from.has_mine_exp()) {
      set_mine_exp(from.mine_exp());
    }
    if (from.has_mine_level()) {
      set_mine_level(from.mine_level());
    }
    if (from.has_mine_normal_ts()) {
      set_mine_normal_ts(from.mine_normal_ts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineOpenResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineOpenResp::CopyFrom(const MineOpenResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineOpenResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_mine()) {
    if (!this->mine().IsInitialized()) return false;
  }
  if (has_assets()) {
    if (!this->assets().IsInitialized()) return false;
  }
  return true;
}

void MineOpenResp::Swap(MineOpenResp* other) {
  if (other != this) {
    std::swap(mine_, other->mine_);
    std::swap(assets_, other->assets_);
    std::swap(mine_exp_, other->mine_exp_);
    std::swap(mine_level_, other->mine_level_);
    std::swap(mine_normal_ts_, other->mine_normal_ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineOpenResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineOpenResp_descriptor_;
  metadata.reflection = MineOpenResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DonateNormalReq::kIndexFieldNumber;
#endif  // !_MSC_VER

DonateNormalReq::DonateNormalReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.DonateNormalReq)
}

void DonateNormalReq::InitAsDefaultInstance() {
}

DonateNormalReq::DonateNormalReq(const DonateNormalReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.DonateNormalReq)
}

void DonateNormalReq::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DonateNormalReq::~DonateNormalReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.DonateNormalReq)
  SharedDtor();
}

void DonateNormalReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DonateNormalReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DonateNormalReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DonateNormalReq_descriptor_;
}

const DonateNormalReq& DonateNormalReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

DonateNormalReq* DonateNormalReq::default_instance_ = NULL;

DonateNormalReq* DonateNormalReq::New() const {
  return new DonateNormalReq;
}

void DonateNormalReq::Clear() {
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DonateNormalReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.DonateNormalReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.DonateNormalReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.DonateNormalReq)
  return false;
#undef DO_
}

void DonateNormalReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.DonateNormalReq)
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.DonateNormalReq)
}

::google::protobuf::uint8* DonateNormalReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.DonateNormalReq)
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.DonateNormalReq)
  return target;
}

int DonateNormalReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DonateNormalReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DonateNormalReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DonateNormalReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DonateNormalReq::MergeFrom(const DonateNormalReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DonateNormalReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DonateNormalReq::CopyFrom(const DonateNormalReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DonateNormalReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DonateNormalReq::Swap(DonateNormalReq* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DonateNormalReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DonateNormalReq_descriptor_;
  metadata.reflection = DonateNormalReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

DonateKingdomReq::DonateKingdomReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.DonateKingdomReq)
}

void DonateKingdomReq::InitAsDefaultInstance() {
}

DonateKingdomReq::DonateKingdomReq(const DonateKingdomReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.DonateKingdomReq)
}

void DonateKingdomReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DonateKingdomReq::~DonateKingdomReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.DonateKingdomReq)
  SharedDtor();
}

void DonateKingdomReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DonateKingdomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DonateKingdomReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DonateKingdomReq_descriptor_;
}

const DonateKingdomReq& DonateKingdomReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

DonateKingdomReq* DonateKingdomReq::default_instance_ = NULL;

DonateKingdomReq* DonateKingdomReq::New() const {
  return new DonateKingdomReq;
}

void DonateKingdomReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DonateKingdomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.DonateKingdomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.DonateKingdomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.DonateKingdomReq)
  return false;
#undef DO_
}

void DonateKingdomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.DonateKingdomReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.DonateKingdomReq)
}

::google::protobuf::uint8* DonateKingdomReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.DonateKingdomReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.DonateKingdomReq)
  return target;
}

int DonateKingdomReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DonateKingdomReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DonateKingdomReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DonateKingdomReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DonateKingdomReq::MergeFrom(const DonateKingdomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DonateKingdomReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DonateKingdomReq::CopyFrom(const DonateKingdomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DonateKingdomReq::IsInitialized() const {

  return true;
}

void DonateKingdomReq::Swap(DonateKingdomReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DonateKingdomReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DonateKingdomReq_descriptor_;
  metadata.reflection = DonateKingdomReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DonateResp::kMineFieldNumber;
const int DonateResp::kAssetsFieldNumber;
const int DonateResp::kMineExpFieldNumber;
const int DonateResp::kMineLevelFieldNumber;
#endif  // !_MSC_VER

DonateResp::DonateResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.DonateResp)
}

void DonateResp::InitAsDefaultInstance() {
  mine_ = const_cast< ::ProtoMine::MineItem*>(&::ProtoMine::MineItem::default_instance());
  assets_ = const_cast< ::DataCommon::UserResourceCPP*>(&::DataCommon::UserResourceCPP::default_instance());
}

DonateResp::DonateResp(const DonateResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.DonateResp)
}

void DonateResp::SharedCtor() {
  _cached_size_ = 0;
  mine_ = NULL;
  assets_ = NULL;
  mine_exp_ = 0u;
  mine_level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DonateResp::~DonateResp() {
  // @@protoc_insertion_point(destructor:ProtoMine.DonateResp)
  SharedDtor();
}

void DonateResp::SharedDtor() {
  if (this != default_instance_) {
    delete mine_;
    delete assets_;
  }
}

void DonateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DonateResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DonateResp_descriptor_;
}

const DonateResp& DonateResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

DonateResp* DonateResp::default_instance_ = NULL;

DonateResp* DonateResp::New() const {
  return new DonateResp;
}

void DonateResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DonateResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(mine_exp_, mine_level_);
    if (has_mine()) {
      if (mine_ != NULL) mine_->::ProtoMine::MineItem::Clear();
    }
    if (has_assets()) {
      if (assets_ != NULL) assets_->::DataCommon::UserResourceCPP::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DonateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.DonateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoMine.MineItem mine = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mine()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_assets;
        break;
      }

      // required .DataCommon.UserResourceCPP assets = 2;
      case 2: {
        if (tag == 18) {
         parse_assets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assets()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mine_exp;
        break;
      }

      // required uint32 mine_exp = 3;
      case 3: {
        if (tag == 24) {
         parse_mine_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_exp_)));
          set_has_mine_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_mine_level;
        break;
      }

      // required uint32 mine_level = 4;
      case 4: {
        if (tag == 32) {
         parse_mine_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mine_level_)));
          set_has_mine_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.DonateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.DonateResp)
  return false;
#undef DO_
}

void DonateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.DonateResp)
  // required .ProtoMine.MineItem mine = 1;
  if (has_mine()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mine(), output);
  }

  // required .DataCommon.UserResourceCPP assets = 2;
  if (has_assets()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->assets(), output);
  }

  // required uint32 mine_exp = 3;
  if (has_mine_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->mine_exp(), output);
  }

  // required uint32 mine_level = 4;
  if (has_mine_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->mine_level(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.DonateResp)
}

::google::protobuf::uint8* DonateResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.DonateResp)
  // required .ProtoMine.MineItem mine = 1;
  if (has_mine()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mine(), target);
  }

  // required .DataCommon.UserResourceCPP assets = 2;
  if (has_assets()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->assets(), target);
  }

  // required uint32 mine_exp = 3;
  if (has_mine_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->mine_exp(), target);
  }

  // required uint32 mine_level = 4;
  if (has_mine_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->mine_level(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.DonateResp)
  return target;
}

int DonateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoMine.MineItem mine = 1;
    if (has_mine()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mine());
    }

    // required .DataCommon.UserResourceCPP assets = 2;
    if (has_assets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assets());
    }

    // required uint32 mine_exp = 3;
    if (has_mine_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_exp());
    }

    // required uint32 mine_level = 4;
    if (has_mine_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mine_level());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DonateResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DonateResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DonateResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DonateResp::MergeFrom(const DonateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mine()) {
      mutable_mine()->::ProtoMine::MineItem::MergeFrom(from.mine());
    }
    if (from.has_assets()) {
      mutable_assets()->::DataCommon::UserResourceCPP::MergeFrom(from.assets());
    }
    if (from.has_mine_exp()) {
      set_mine_exp(from.mine_exp());
    }
    if (from.has_mine_level()) {
      set_mine_level(from.mine_level());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DonateResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DonateResp::CopyFrom(const DonateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DonateResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_mine()) {
    if (!this->mine().IsInitialized()) return false;
  }
  if (has_assets()) {
    if (!this->assets().IsInitialized()) return false;
  }
  return true;
}

void DonateResp::Swap(DonateResp* other) {
  if (other != this) {
    std::swap(mine_, other->mine_);
    std::swap(assets_, other->assets_);
    std::swap(mine_exp_, other->mine_exp_);
    std::swap(mine_level_, other->mine_level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DonateResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DonateResp_descriptor_;
  metadata.reflection = DonateResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

MineKingdomRewardReq::MineKingdomRewardReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineKingdomRewardReq)
}

void MineKingdomRewardReq::InitAsDefaultInstance() {
}

MineKingdomRewardReq::MineKingdomRewardReq(const MineKingdomRewardReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineKingdomRewardReq)
}

void MineKingdomRewardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineKingdomRewardReq::~MineKingdomRewardReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineKingdomRewardReq)
  SharedDtor();
}

void MineKingdomRewardReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineKingdomRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineKingdomRewardReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineKingdomRewardReq_descriptor_;
}

const MineKingdomRewardReq& MineKingdomRewardReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineKingdomRewardReq* MineKingdomRewardReq::default_instance_ = NULL;

MineKingdomRewardReq* MineKingdomRewardReq::New() const {
  return new MineKingdomRewardReq;
}

void MineKingdomRewardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineKingdomRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineKingdomRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineKingdomRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineKingdomRewardReq)
  return false;
#undef DO_
}

void MineKingdomRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineKingdomRewardReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineKingdomRewardReq)
}

::google::protobuf::uint8* MineKingdomRewardReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineKingdomRewardReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineKingdomRewardReq)
  return target;
}

int MineKingdomRewardReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineKingdomRewardReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineKingdomRewardReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineKingdomRewardReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineKingdomRewardReq::MergeFrom(const MineKingdomRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineKingdomRewardReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineKingdomRewardReq::CopyFrom(const MineKingdomRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineKingdomRewardReq::IsInitialized() const {

  return true;
}

void MineKingdomRewardReq::Swap(MineKingdomRewardReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineKingdomRewardReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineKingdomRewardReq_descriptor_;
  metadata.reflection = MineKingdomRewardReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineKingdomRewardResp::kOpTsFieldNumber;
const int MineKingdomRewardResp::kAssetsFieldNumber;
#endif  // !_MSC_VER

MineKingdomRewardResp::MineKingdomRewardResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineKingdomRewardResp)
}

void MineKingdomRewardResp::InitAsDefaultInstance() {
  assets_ = const_cast< ::DataCommon::UserResourceCPP*>(&::DataCommon::UserResourceCPP::default_instance());
}

MineKingdomRewardResp::MineKingdomRewardResp(const MineKingdomRewardResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineKingdomRewardResp)
}

void MineKingdomRewardResp::SharedCtor() {
  _cached_size_ = 0;
  op_ts_ = 0u;
  assets_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineKingdomRewardResp::~MineKingdomRewardResp() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineKingdomRewardResp)
  SharedDtor();
}

void MineKingdomRewardResp::SharedDtor() {
  if (this != default_instance_) {
    delete assets_;
  }
}

void MineKingdomRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineKingdomRewardResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineKingdomRewardResp_descriptor_;
}

const MineKingdomRewardResp& MineKingdomRewardResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineKingdomRewardResp* MineKingdomRewardResp::default_instance_ = NULL;

MineKingdomRewardResp* MineKingdomRewardResp::New() const {
  return new MineKingdomRewardResp;
}

void MineKingdomRewardResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    op_ts_ = 0u;
    if (has_assets()) {
      if (assets_ != NULL) assets_->::DataCommon::UserResourceCPP::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineKingdomRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineKingdomRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 op_ts = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &op_ts_)));
          set_has_op_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_assets;
        break;
      }

      // required .DataCommon.UserResourceCPP assets = 2;
      case 2: {
        if (tag == 18) {
         parse_assets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assets()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineKingdomRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineKingdomRewardResp)
  return false;
#undef DO_
}

void MineKingdomRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineKingdomRewardResp)
  // required uint32 op_ts = 1;
  if (has_op_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->op_ts(), output);
  }

  // required .DataCommon.UserResourceCPP assets = 2;
  if (has_assets()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->assets(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineKingdomRewardResp)
}

::google::protobuf::uint8* MineKingdomRewardResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineKingdomRewardResp)
  // required uint32 op_ts = 1;
  if (has_op_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->op_ts(), target);
  }

  // required .DataCommon.UserResourceCPP assets = 2;
  if (has_assets()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->assets(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineKingdomRewardResp)
  return target;
}

int MineKingdomRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 op_ts = 1;
    if (has_op_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->op_ts());
    }

    // required .DataCommon.UserResourceCPP assets = 2;
    if (has_assets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assets());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineKingdomRewardResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineKingdomRewardResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineKingdomRewardResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineKingdomRewardResp::MergeFrom(const MineKingdomRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_op_ts()) {
      set_op_ts(from.op_ts());
    }
    if (from.has_assets()) {
      mutable_assets()->::DataCommon::UserResourceCPP::MergeFrom(from.assets());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineKingdomRewardResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineKingdomRewardResp::CopyFrom(const MineKingdomRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineKingdomRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_assets()) {
    if (!this->assets().IsInitialized()) return false;
  }
  return true;
}

void MineKingdomRewardResp::Swap(MineKingdomRewardResp* other) {
  if (other != this) {
    std::swap(op_ts_, other->op_ts_);
    std::swap(assets_, other->assets_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineKingdomRewardResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineKingdomRewardResp_descriptor_;
  metadata.reflection = MineKingdomRewardResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

MineKingdomMinerRewardReq::MineKingdomMinerRewardReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineKingdomMinerRewardReq)
}

void MineKingdomMinerRewardReq::InitAsDefaultInstance() {
}

MineKingdomMinerRewardReq::MineKingdomMinerRewardReq(const MineKingdomMinerRewardReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineKingdomMinerRewardReq)
}

void MineKingdomMinerRewardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineKingdomMinerRewardReq::~MineKingdomMinerRewardReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineKingdomMinerRewardReq)
  SharedDtor();
}

void MineKingdomMinerRewardReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineKingdomMinerRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineKingdomMinerRewardReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineKingdomMinerRewardReq_descriptor_;
}

const MineKingdomMinerRewardReq& MineKingdomMinerRewardReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineKingdomMinerRewardReq* MineKingdomMinerRewardReq::default_instance_ = NULL;

MineKingdomMinerRewardReq* MineKingdomMinerRewardReq::New() const {
  return new MineKingdomMinerRewardReq;
}

void MineKingdomMinerRewardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineKingdomMinerRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineKingdomMinerRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineKingdomMinerRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineKingdomMinerRewardReq)
  return false;
#undef DO_
}

void MineKingdomMinerRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineKingdomMinerRewardReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineKingdomMinerRewardReq)
}

::google::protobuf::uint8* MineKingdomMinerRewardReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineKingdomMinerRewardReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineKingdomMinerRewardReq)
  return target;
}

int MineKingdomMinerRewardReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineKingdomMinerRewardReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineKingdomMinerRewardReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineKingdomMinerRewardReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineKingdomMinerRewardReq::MergeFrom(const MineKingdomMinerRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineKingdomMinerRewardReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineKingdomMinerRewardReq::CopyFrom(const MineKingdomMinerRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineKingdomMinerRewardReq::IsInitialized() const {

  return true;
}

void MineKingdomMinerRewardReq::Swap(MineKingdomMinerRewardReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineKingdomMinerRewardReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineKingdomMinerRewardReq_descriptor_;
  metadata.reflection = MineKingdomMinerRewardReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineKingdomMinerRewardResp::kOpTsFieldNumber;
const int MineKingdomMinerRewardResp::kExpFieldNumber;
#endif  // !_MSC_VER

MineKingdomMinerRewardResp::MineKingdomMinerRewardResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineKingdomMinerRewardResp)
}

void MineKingdomMinerRewardResp::InitAsDefaultInstance() {
  exp_ = const_cast< ::DataCommon::RewardItemCPP*>(&::DataCommon::RewardItemCPP::default_instance());
}

MineKingdomMinerRewardResp::MineKingdomMinerRewardResp(const MineKingdomMinerRewardResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineKingdomMinerRewardResp)
}

void MineKingdomMinerRewardResp::SharedCtor() {
  _cached_size_ = 0;
  op_ts_ = 0u;
  exp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineKingdomMinerRewardResp::~MineKingdomMinerRewardResp() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineKingdomMinerRewardResp)
  SharedDtor();
}

void MineKingdomMinerRewardResp::SharedDtor() {
  if (this != default_instance_) {
    delete exp_;
  }
}

void MineKingdomMinerRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineKingdomMinerRewardResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineKingdomMinerRewardResp_descriptor_;
}

const MineKingdomMinerRewardResp& MineKingdomMinerRewardResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineKingdomMinerRewardResp* MineKingdomMinerRewardResp::default_instance_ = NULL;

MineKingdomMinerRewardResp* MineKingdomMinerRewardResp::New() const {
  return new MineKingdomMinerRewardResp;
}

void MineKingdomMinerRewardResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    op_ts_ = 0u;
    if (has_exp()) {
      if (exp_ != NULL) exp_->::DataCommon::RewardItemCPP::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineKingdomMinerRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineKingdomMinerRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 op_ts = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &op_ts_)));
          set_has_op_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_exp;
        break;
      }

      // required .DataCommon.RewardItemCPP exp = 2;
      case 2: {
        if (tag == 18) {
         parse_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineKingdomMinerRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineKingdomMinerRewardResp)
  return false;
#undef DO_
}

void MineKingdomMinerRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineKingdomMinerRewardResp)
  // required uint32 op_ts = 1;
  if (has_op_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->op_ts(), output);
  }

  // required .DataCommon.RewardItemCPP exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->exp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineKingdomMinerRewardResp)
}

::google::protobuf::uint8* MineKingdomMinerRewardResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineKingdomMinerRewardResp)
  // required uint32 op_ts = 1;
  if (has_op_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->op_ts(), target);
  }

  // required .DataCommon.RewardItemCPP exp = 2;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->exp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineKingdomMinerRewardResp)
  return target;
}

int MineKingdomMinerRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 op_ts = 1;
    if (has_op_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->op_ts());
    }

    // required .DataCommon.RewardItemCPP exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineKingdomMinerRewardResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineKingdomMinerRewardResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineKingdomMinerRewardResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineKingdomMinerRewardResp::MergeFrom(const MineKingdomMinerRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_op_ts()) {
      set_op_ts(from.op_ts());
    }
    if (from.has_exp()) {
      mutable_exp()->::DataCommon::RewardItemCPP::MergeFrom(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineKingdomMinerRewardResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineKingdomMinerRewardResp::CopyFrom(const MineKingdomMinerRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineKingdomMinerRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_exp()) {
    if (!this->exp().IsInitialized()) return false;
  }
  return true;
}

void MineKingdomMinerRewardResp::Swap(MineKingdomMinerRewardResp* other) {
  if (other != this) {
    std::swap(op_ts_, other->op_ts_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineKingdomMinerRewardResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineKingdomMinerRewardResp_descriptor_;
  metadata.reflection = MineKingdomMinerRewardResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

MineRecordReq::MineRecordReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineRecordReq)
}

void MineRecordReq::InitAsDefaultInstance() {
}

MineRecordReq::MineRecordReq(const MineRecordReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineRecordReq)
}

void MineRecordReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineRecordReq::~MineRecordReq() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineRecordReq)
  SharedDtor();
}

void MineRecordReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineRecordReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineRecordReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineRecordReq_descriptor_;
}

const MineRecordReq& MineRecordReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineRecordReq* MineRecordReq::default_instance_ = NULL;

MineRecordReq* MineRecordReq::New() const {
  return new MineRecordReq;
}

void MineRecordReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineRecordReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineRecordReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineRecordReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineRecordReq)
  return false;
#undef DO_
}

void MineRecordReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineRecordReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineRecordReq)
}

::google::protobuf::uint8* MineRecordReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineRecordReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineRecordReq)
  return target;
}

int MineRecordReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineRecordReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineRecordReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineRecordReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineRecordReq::MergeFrom(const MineRecordReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineRecordReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineRecordReq::CopyFrom(const MineRecordReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineRecordReq::IsInitialized() const {

  return true;
}

void MineRecordReq::Swap(MineRecordReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineRecordReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineRecordReq_descriptor_;
  metadata.reflection = MineRecordReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineRecordResp::kRecordsFieldNumber;
#endif  // !_MSC_VER

MineRecordResp::MineRecordResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.MineRecordResp)
}

void MineRecordResp::InitAsDefaultInstance() {
}

MineRecordResp::MineRecordResp(const MineRecordResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.MineRecordResp)
}

void MineRecordResp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineRecordResp::~MineRecordResp() {
  // @@protoc_insertion_point(destructor:ProtoMine.MineRecordResp)
  SharedDtor();
}

void MineRecordResp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineRecordResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineRecordResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineRecordResp_descriptor_;
}

const MineRecordResp& MineRecordResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

MineRecordResp* MineRecordResp::default_instance_ = NULL;

MineRecordResp* MineRecordResp::New() const {
  return new MineRecordResp;
}

void MineRecordResp::Clear() {
  records_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineRecordResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.MineRecordResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtoMine.MineRecord records = 1;
      case 1: {
        if (tag == 10) {
         parse_records:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_records()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_records;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.MineRecordResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.MineRecordResp)
  return false;
#undef DO_
}

void MineRecordResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.MineRecordResp)
  // repeated .ProtoMine.MineRecord records = 1;
  for (int i = 0; i < this->records_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->records(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.MineRecordResp)
}

::google::protobuf::uint8* MineRecordResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.MineRecordResp)
  // repeated .ProtoMine.MineRecord records = 1;
  for (int i = 0; i < this->records_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->records(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.MineRecordResp)
  return target;
}

int MineRecordResp::ByteSize() const {
  int total_size = 0;

  // repeated .ProtoMine.MineRecord records = 1;
  total_size += 1 * this->records_size();
  for (int i = 0; i < this->records_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->records(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineRecordResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineRecordResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineRecordResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineRecordResp::MergeFrom(const MineRecordResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  records_.MergeFrom(from.records_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineRecordResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineRecordResp::CopyFrom(const MineRecordResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineRecordResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->records())) return false;
  return true;
}

void MineRecordResp::Swap(MineRecordResp* other) {
  if (other != this) {
    records_.Swap(&other->records_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineRecordResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineRecordResp_descriptor_;
  metadata.reflection = MineRecordResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SyncUserBaseInfo::kInfoFieldNumber;
const int SyncUserBaseInfo::kLevelFieldNumber;
#endif  // !_MSC_VER

SyncUserBaseInfo::SyncUserBaseInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoMine.SyncUserBaseInfo)
}

void SyncUserBaseInfo::InitAsDefaultInstance() {
  info_ = const_cast< ::DataCommon::CommonBaseRewardCPP*>(&::DataCommon::CommonBaseRewardCPP::default_instance());
}

SyncUserBaseInfo::SyncUserBaseInfo(const SyncUserBaseInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoMine.SyncUserBaseInfo)
}

void SyncUserBaseInfo::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  level_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SyncUserBaseInfo::~SyncUserBaseInfo() {
  // @@protoc_insertion_point(destructor:ProtoMine.SyncUserBaseInfo)
  SharedDtor();
}

void SyncUserBaseInfo::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void SyncUserBaseInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SyncUserBaseInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SyncUserBaseInfo_descriptor_;
}

const SyncUserBaseInfo& SyncUserBaseInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMine_2eproto();
  return *default_instance_;
}

SyncUserBaseInfo* SyncUserBaseInfo::default_instance_ = NULL;

SyncUserBaseInfo* SyncUserBaseInfo::New() const {
  return new SyncUserBaseInfo;
}

void SyncUserBaseInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_info()) {
      if (info_ != NULL) info_->::DataCommon::CommonBaseRewardCPP::Clear();
    }
    level_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SyncUserBaseInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoMine.SyncUserBaseInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DataCommon.CommonBaseRewardCPP info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // required uint32 level = 2;
      case 2: {
        if (tag == 16) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoMine.SyncUserBaseInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoMine.SyncUserBaseInfo)
  return false;
#undef DO_
}

void SyncUserBaseInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoMine.SyncUserBaseInfo)
  // required .DataCommon.CommonBaseRewardCPP info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }

  // required uint32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->level(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoMine.SyncUserBaseInfo)
}

::google::protobuf::uint8* SyncUserBaseInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoMine.SyncUserBaseInfo)
  // required .DataCommon.CommonBaseRewardCPP info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }

  // required uint32 level = 2;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->level(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoMine.SyncUserBaseInfo)
  return target;
}

int SyncUserBaseInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .DataCommon.CommonBaseRewardCPP info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

    // required uint32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SyncUserBaseInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SyncUserBaseInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SyncUserBaseInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SyncUserBaseInfo::MergeFrom(const SyncUserBaseInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::DataCommon::CommonBaseRewardCPP::MergeFrom(from.info());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SyncUserBaseInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SyncUserBaseInfo::CopyFrom(const SyncUserBaseInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SyncUserBaseInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void SyncUserBaseInfo::Swap(SyncUserBaseInfo* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SyncUserBaseInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SyncUserBaseInfo_descriptor_;
  metadata.reflection = SyncUserBaseInfo_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoMine

// @@protoc_insertion_point(global_scope)
