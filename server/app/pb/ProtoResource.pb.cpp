// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoResource.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoResource.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ProtoResource {

namespace {

const ::google::protobuf::Descriptor* FlamenReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FlamenReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* FlamemResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FlamemResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* CutBlackMarketCDReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CutBlackMarketCDReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* CutBlackMarketCDResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CutBlackMarketCDResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* BMarketExchangeReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BMarketExchangeReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* BMarketExchangeResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BMarketExchangeResp_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ProtoResource_2eproto() {
  protobuf_AddDesc_ProtoResource_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ProtoResource.proto");
  GOOGLE_CHECK(file != NULL);
  FlamenReq_descriptor_ = file->message_type(0);
  static const int FlamenReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamenReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamenReq, isonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamenReq, isfree_),
  };
  FlamenReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FlamenReq_descriptor_,
      FlamenReq::default_instance_,
      FlamenReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamenReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamenReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FlamenReq));
  FlamemResp_descriptor_ = file->message_type(1);
  static const int FlamemResp_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, multiple_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, free_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, buy_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, cash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, rewards_),
  };
  FlamemResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FlamemResp_descriptor_,
      FlamemResp::default_instance_,
      FlamemResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlamemResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FlamemResp));
  CutBlackMarketCDReq_descriptor_ = file->message_type(2);
  static const int CutBlackMarketCDReq_offsets_[1] = {
  };
  CutBlackMarketCDReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CutBlackMarketCDReq_descriptor_,
      CutBlackMarketCDReq::default_instance_,
      CutBlackMarketCDReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CutBlackMarketCDReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CutBlackMarketCDReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CutBlackMarketCDReq));
  CutBlackMarketCDResp_descriptor_ = file->message_type(3);
  static const int CutBlackMarketCDResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CutBlackMarketCDResp, bmarketcd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CutBlackMarketCDResp, cash_),
  };
  CutBlackMarketCDResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CutBlackMarketCDResp_descriptor_,
      CutBlackMarketCDResp::default_instance_,
      CutBlackMarketCDResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CutBlackMarketCDResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CutBlackMarketCDResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CutBlackMarketCDResp));
  BMarketExchangeReq_descriptor_ = file->message_type(4);
  static const int BMarketExchangeReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeReq, usedtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeReq, gaintype_),
  };
  BMarketExchangeReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BMarketExchangeReq_descriptor_,
      BMarketExchangeReq::default_instance_,
      BMarketExchangeReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BMarketExchangeReq));
  BMarketExchangeResp_descriptor_ = file->message_type(5);
  static const int BMarketExchangeResp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeResp, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeResp, wood_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeResp, food_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeResp, bmarketcd_),
  };
  BMarketExchangeResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BMarketExchangeResp_descriptor_,
      BMarketExchangeResp::default_instance_,
      BMarketExchangeResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BMarketExchangeResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BMarketExchangeResp));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ProtoResource_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FlamenReq_descriptor_, &FlamenReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FlamemResp_descriptor_, &FlamemResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CutBlackMarketCDReq_descriptor_, &CutBlackMarketCDReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CutBlackMarketCDResp_descriptor_, &CutBlackMarketCDResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BMarketExchangeReq_descriptor_, &BMarketExchangeReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BMarketExchangeResp_descriptor_, &BMarketExchangeResp::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ProtoResource_2eproto() {
  delete FlamenReq::default_instance_;
  delete FlamenReq_reflection_;
  delete FlamemResp::default_instance_;
  delete FlamemResp_reflection_;
  delete CutBlackMarketCDReq::default_instance_;
  delete CutBlackMarketCDReq_reflection_;
  delete CutBlackMarketCDResp::default_instance_;
  delete CutBlackMarketCDResp_reflection_;
  delete BMarketExchangeReq::default_instance_;
  delete BMarketExchangeReq_reflection_;
  delete BMarketExchangeResp::default_instance_;
  delete BMarketExchangeResp_reflection_;
}

void protobuf_AddDesc_ProtoResource_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023ProtoResource.proto\022\rProtoResource\"9\n\t"
    "FlamenReq\022\014\n\004type\030\001 \002(\r\022\016\n\006isOnce\030\002 \002(\010\022"
    "\016\n\006isFree\030\003 \002(\010\"}\n\nFlamemResp\022\014\n\004type\030\001 "
    "\002(\r\022\020\n\010multiple\030\002 \003(\r\022\r\n\005value\030\003 \002(\004\022\020\n\010"
    "free_cnt\030\004 \002(\r\022\017\n\007buy_cnt\030\005 \002(\r\022\014\n\004cash\030"
    "\006 \002(\r\022\017\n\007rewards\030\007 \003(\r\"\025\n\023CutBlackMarket"
    "CDReq\"7\n\024CutBlackMarketCDResp\022\021\n\tbmarket"
    "cd\030\001 \002(\r\022\014\n\004cash\030\002 \002(\r\"8\n\022BMarketExchang"
    "eReq\022\020\n\010usedtype\030\001 \002(\r\022\020\n\010gaintype\030\002 \002(\r"
    "\"R\n\023BMarketExchangeResp\022\014\n\004coin\030\001 \002(\r\022\014\n"
    "\004wood\030\002 \002(\r\022\014\n\004food\030\003 \002(\r\022\021\n\tbmarketcd\030\004"
    " \002(\r", 444);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ProtoResource.proto", &protobuf_RegisterTypes);
  FlamenReq::default_instance_ = new FlamenReq();
  FlamemResp::default_instance_ = new FlamemResp();
  CutBlackMarketCDReq::default_instance_ = new CutBlackMarketCDReq();
  CutBlackMarketCDResp::default_instance_ = new CutBlackMarketCDResp();
  BMarketExchangeReq::default_instance_ = new BMarketExchangeReq();
  BMarketExchangeResp::default_instance_ = new BMarketExchangeResp();
  FlamenReq::default_instance_->InitAsDefaultInstance();
  FlamemResp::default_instance_->InitAsDefaultInstance();
  CutBlackMarketCDReq::default_instance_->InitAsDefaultInstance();
  CutBlackMarketCDResp::default_instance_->InitAsDefaultInstance();
  BMarketExchangeReq::default_instance_->InitAsDefaultInstance();
  BMarketExchangeResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoResource_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoResource_2eproto {
  StaticDescriptorInitializer_ProtoResource_2eproto() {
    protobuf_AddDesc_ProtoResource_2eproto();
  }
} static_descriptor_initializer_ProtoResource_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int FlamenReq::kTypeFieldNumber;
const int FlamenReq::kIsOnceFieldNumber;
const int FlamenReq::kIsFreeFieldNumber;
#endif  // !_MSC_VER

FlamenReq::FlamenReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoResource.FlamenReq)
}

void FlamenReq::InitAsDefaultInstance() {
}

FlamenReq::FlamenReq(const FlamenReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoResource.FlamenReq)
}

void FlamenReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  isonce_ = false;
  isfree_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FlamenReq::~FlamenReq() {
  // @@protoc_insertion_point(destructor:ProtoResource.FlamenReq)
  SharedDtor();
}

void FlamenReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FlamenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FlamenReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FlamenReq_descriptor_;
}

const FlamenReq& FlamenReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoResource_2eproto();
  return *default_instance_;
}

FlamenReq* FlamenReq::default_instance_ = NULL;

FlamenReq* FlamenReq::New() const {
  return new FlamenReq;
}

void FlamenReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FlamenReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, isfree_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FlamenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoResource.FlamenReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_isOnce;
        break;
      }

      // required bool isOnce = 2;
      case 2: {
        if (tag == 16) {
         parse_isOnce:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isonce_)));
          set_has_isonce();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_isFree;
        break;
      }

      // required bool isFree = 3;
      case 3: {
        if (tag == 24) {
         parse_isFree:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isfree_)));
          set_has_isfree();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoResource.FlamenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoResource.FlamenReq)
  return false;
#undef DO_
}

void FlamenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoResource.FlamenReq)
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required bool isOnce = 2;
  if (has_isonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isonce(), output);
  }

  // required bool isFree = 3;
  if (has_isfree()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isfree(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoResource.FlamenReq)
}

::google::protobuf::uint8* FlamenReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoResource.FlamenReq)
  // required uint32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->type(), target);
  }

  // required bool isOnce = 2;
  if (has_isonce()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isonce(), target);
  }

  // required bool isFree = 3;
  if (has_isfree()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->isfree(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoResource.FlamenReq)
  return target;
}

int FlamenReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required bool isOnce = 2;
    if (has_isonce()) {
      total_size += 1 + 1;
    }

    // required bool isFree = 3;
    if (has_isfree()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FlamenReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FlamenReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FlamenReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FlamenReq::MergeFrom(const FlamenReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_isonce()) {
      set_isonce(from.isonce());
    }
    if (from.has_isfree()) {
      set_isfree(from.isfree());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FlamenReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FlamenReq::CopyFrom(const FlamenReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlamenReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void FlamenReq::Swap(FlamenReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(isonce_, other->isonce_);
    std::swap(isfree_, other->isfree_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FlamenReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FlamenReq_descriptor_;
  metadata.reflection = FlamenReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FlamemResp::kTypeFieldNumber;
const int FlamemResp::kMultipleFieldNumber;
const int FlamemResp::kValueFieldNumber;
const int FlamemResp::kFreeCntFieldNumber;
const int FlamemResp::kBuyCntFieldNumber;
const int FlamemResp::kCashFieldNumber;
const int FlamemResp::kRewardsFieldNumber;
#endif  // !_MSC_VER

FlamemResp::FlamemResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoResource.FlamemResp)
}

void FlamemResp::InitAsDefaultInstance() {
}

FlamemResp::FlamemResp(const FlamemResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoResource.FlamemResp)
}

void FlamemResp::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  value_ = GOOGLE_ULONGLONG(0);
  free_cnt_ = 0u;
  buy_cnt_ = 0u;
  cash_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FlamemResp::~FlamemResp() {
  // @@protoc_insertion_point(destructor:ProtoResource.FlamemResp)
  SharedDtor();
}

void FlamemResp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FlamemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FlamemResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FlamemResp_descriptor_;
}

const FlamemResp& FlamemResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoResource_2eproto();
  return *default_instance_;
}

FlamemResp* FlamemResp::default_instance_ = NULL;

FlamemResp* FlamemResp::New() const {
  return new FlamemResp;
}

void FlamemResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FlamemResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 61) {
    ZR_(type_, cash_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  multiple_.Clear();
  rewards_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FlamemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoResource.FlamemResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_multiple;
        break;
      }

      // repeated uint32 multiple = 2;
      case 2: {
        if (tag == 16) {
         parse_multiple:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_multiple())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_multiple())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_multiple;
        if (input->ExpectTag(24)) goto parse_value;
        break;
      }

      // required uint64 value = 3;
      case 3: {
        if (tag == 24) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_free_cnt;
        break;
      }

      // required uint32 free_cnt = 4;
      case 4: {
        if (tag == 32) {
         parse_free_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &free_cnt_)));
          set_has_free_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_buy_cnt;
        break;
      }

      // required uint32 buy_cnt = 5;
      case 5: {
        if (tag == 40) {
         parse_buy_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buy_cnt_)));
          set_has_buy_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_cash;
        break;
      }

      // required uint32 cash = 6;
      case 6: {
        if (tag == 48) {
         parse_cash:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cash_)));
          set_has_cash();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_rewards;
        break;
      }

      // repeated uint32 rewards = 7;
      case 7: {
        if (tag == 56) {
         parse_rewards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_rewards())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_rewards())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_rewards;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoResource.FlamemResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoResource.FlamemResp)
  return false;
#undef DO_
}

void FlamemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoResource.FlamemResp)
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // repeated uint32 multiple = 2;
  for (int i = 0; i < this->multiple_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->multiple(i), output);
  }

  // required uint64 value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->value(), output);
  }

  // required uint32 free_cnt = 4;
  if (has_free_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->free_cnt(), output);
  }

  // required uint32 buy_cnt = 5;
  if (has_buy_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->buy_cnt(), output);
  }

  // required uint32 cash = 6;
  if (has_cash()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->cash(), output);
  }

  // repeated uint32 rewards = 7;
  for (int i = 0; i < this->rewards_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->rewards(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoResource.FlamemResp)
}

::google::protobuf::uint8* FlamemResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoResource.FlamemResp)
  // required uint32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->type(), target);
  }

  // repeated uint32 multiple = 2;
  for (int i = 0; i < this->multiple_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->multiple(i), target);
  }

  // required uint64 value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->value(), target);
  }

  // required uint32 free_cnt = 4;
  if (has_free_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->free_cnt(), target);
  }

  // required uint32 buy_cnt = 5;
  if (has_buy_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->buy_cnt(), target);
  }

  // required uint32 cash = 6;
  if (has_cash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->cash(), target);
  }

  // repeated uint32 rewards = 7;
  for (int i = 0; i < this->rewards_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(7, this->rewards(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoResource.FlamemResp)
  return target;
}

int FlamemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint64 value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->value());
    }

    // required uint32 free_cnt = 4;
    if (has_free_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->free_cnt());
    }

    // required uint32 buy_cnt = 5;
    if (has_buy_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buy_cnt());
    }

    // required uint32 cash = 6;
    if (has_cash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cash());
    }

  }
  // repeated uint32 multiple = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->multiple_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->multiple(i));
    }
    total_size += 1 * this->multiple_size() + data_size;
  }

  // repeated uint32 rewards = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->rewards_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->rewards(i));
    }
    total_size += 1 * this->rewards_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FlamemResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FlamemResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FlamemResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FlamemResp::MergeFrom(const FlamemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  multiple_.MergeFrom(from.multiple_);
  rewards_.MergeFrom(from.rewards_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_free_cnt()) {
      set_free_cnt(from.free_cnt());
    }
    if (from.has_buy_cnt()) {
      set_buy_cnt(from.buy_cnt());
    }
    if (from.has_cash()) {
      set_cash(from.cash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FlamemResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FlamemResp::CopyFrom(const FlamemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlamemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003d) != 0x0000003d) return false;

  return true;
}

void FlamemResp::Swap(FlamemResp* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    multiple_.Swap(&other->multiple_);
    std::swap(value_, other->value_);
    std::swap(free_cnt_, other->free_cnt_);
    std::swap(buy_cnt_, other->buy_cnt_);
    std::swap(cash_, other->cash_);
    rewards_.Swap(&other->rewards_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FlamemResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FlamemResp_descriptor_;
  metadata.reflection = FlamemResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CutBlackMarketCDReq::CutBlackMarketCDReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoResource.CutBlackMarketCDReq)
}

void CutBlackMarketCDReq::InitAsDefaultInstance() {
}

CutBlackMarketCDReq::CutBlackMarketCDReq(const CutBlackMarketCDReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoResource.CutBlackMarketCDReq)
}

void CutBlackMarketCDReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CutBlackMarketCDReq::~CutBlackMarketCDReq() {
  // @@protoc_insertion_point(destructor:ProtoResource.CutBlackMarketCDReq)
  SharedDtor();
}

void CutBlackMarketCDReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CutBlackMarketCDReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CutBlackMarketCDReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CutBlackMarketCDReq_descriptor_;
}

const CutBlackMarketCDReq& CutBlackMarketCDReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoResource_2eproto();
  return *default_instance_;
}

CutBlackMarketCDReq* CutBlackMarketCDReq::default_instance_ = NULL;

CutBlackMarketCDReq* CutBlackMarketCDReq::New() const {
  return new CutBlackMarketCDReq;
}

void CutBlackMarketCDReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CutBlackMarketCDReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoResource.CutBlackMarketCDReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoResource.CutBlackMarketCDReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoResource.CutBlackMarketCDReq)
  return false;
#undef DO_
}

void CutBlackMarketCDReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoResource.CutBlackMarketCDReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoResource.CutBlackMarketCDReq)
}

::google::protobuf::uint8* CutBlackMarketCDReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoResource.CutBlackMarketCDReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoResource.CutBlackMarketCDReq)
  return target;
}

int CutBlackMarketCDReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CutBlackMarketCDReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CutBlackMarketCDReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CutBlackMarketCDReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CutBlackMarketCDReq::MergeFrom(const CutBlackMarketCDReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CutBlackMarketCDReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CutBlackMarketCDReq::CopyFrom(const CutBlackMarketCDReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CutBlackMarketCDReq::IsInitialized() const {

  return true;
}

void CutBlackMarketCDReq::Swap(CutBlackMarketCDReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CutBlackMarketCDReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CutBlackMarketCDReq_descriptor_;
  metadata.reflection = CutBlackMarketCDReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CutBlackMarketCDResp::kBmarketcdFieldNumber;
const int CutBlackMarketCDResp::kCashFieldNumber;
#endif  // !_MSC_VER

CutBlackMarketCDResp::CutBlackMarketCDResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoResource.CutBlackMarketCDResp)
}

void CutBlackMarketCDResp::InitAsDefaultInstance() {
}

CutBlackMarketCDResp::CutBlackMarketCDResp(const CutBlackMarketCDResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoResource.CutBlackMarketCDResp)
}

void CutBlackMarketCDResp::SharedCtor() {
  _cached_size_ = 0;
  bmarketcd_ = 0u;
  cash_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CutBlackMarketCDResp::~CutBlackMarketCDResp() {
  // @@protoc_insertion_point(destructor:ProtoResource.CutBlackMarketCDResp)
  SharedDtor();
}

void CutBlackMarketCDResp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CutBlackMarketCDResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CutBlackMarketCDResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CutBlackMarketCDResp_descriptor_;
}

const CutBlackMarketCDResp& CutBlackMarketCDResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoResource_2eproto();
  return *default_instance_;
}

CutBlackMarketCDResp* CutBlackMarketCDResp::default_instance_ = NULL;

CutBlackMarketCDResp* CutBlackMarketCDResp::New() const {
  return new CutBlackMarketCDResp;
}

void CutBlackMarketCDResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CutBlackMarketCDResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(bmarketcd_, cash_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CutBlackMarketCDResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoResource.CutBlackMarketCDResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 bmarketcd = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bmarketcd_)));
          set_has_bmarketcd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cash;
        break;
      }

      // required uint32 cash = 2;
      case 2: {
        if (tag == 16) {
         parse_cash:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cash_)));
          set_has_cash();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoResource.CutBlackMarketCDResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoResource.CutBlackMarketCDResp)
  return false;
#undef DO_
}

void CutBlackMarketCDResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoResource.CutBlackMarketCDResp)
  // required uint32 bmarketcd = 1;
  if (has_bmarketcd()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bmarketcd(), output);
  }

  // required uint32 cash = 2;
  if (has_cash()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoResource.CutBlackMarketCDResp)
}

::google::protobuf::uint8* CutBlackMarketCDResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoResource.CutBlackMarketCDResp)
  // required uint32 bmarketcd = 1;
  if (has_bmarketcd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->bmarketcd(), target);
  }

  // required uint32 cash = 2;
  if (has_cash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoResource.CutBlackMarketCDResp)
  return target;
}

int CutBlackMarketCDResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 bmarketcd = 1;
    if (has_bmarketcd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bmarketcd());
    }

    // required uint32 cash = 2;
    if (has_cash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CutBlackMarketCDResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CutBlackMarketCDResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CutBlackMarketCDResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CutBlackMarketCDResp::MergeFrom(const CutBlackMarketCDResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bmarketcd()) {
      set_bmarketcd(from.bmarketcd());
    }
    if (from.has_cash()) {
      set_cash(from.cash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CutBlackMarketCDResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CutBlackMarketCDResp::CopyFrom(const CutBlackMarketCDResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CutBlackMarketCDResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CutBlackMarketCDResp::Swap(CutBlackMarketCDResp* other) {
  if (other != this) {
    std::swap(bmarketcd_, other->bmarketcd_);
    std::swap(cash_, other->cash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CutBlackMarketCDResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CutBlackMarketCDResp_descriptor_;
  metadata.reflection = CutBlackMarketCDResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BMarketExchangeReq::kUsedtypeFieldNumber;
const int BMarketExchangeReq::kGaintypeFieldNumber;
#endif  // !_MSC_VER

BMarketExchangeReq::BMarketExchangeReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoResource.BMarketExchangeReq)
}

void BMarketExchangeReq::InitAsDefaultInstance() {
}

BMarketExchangeReq::BMarketExchangeReq(const BMarketExchangeReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoResource.BMarketExchangeReq)
}

void BMarketExchangeReq::SharedCtor() {
  _cached_size_ = 0;
  usedtype_ = 0u;
  gaintype_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BMarketExchangeReq::~BMarketExchangeReq() {
  // @@protoc_insertion_point(destructor:ProtoResource.BMarketExchangeReq)
  SharedDtor();
}

void BMarketExchangeReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BMarketExchangeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BMarketExchangeReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BMarketExchangeReq_descriptor_;
}

const BMarketExchangeReq& BMarketExchangeReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoResource_2eproto();
  return *default_instance_;
}

BMarketExchangeReq* BMarketExchangeReq::default_instance_ = NULL;

BMarketExchangeReq* BMarketExchangeReq::New() const {
  return new BMarketExchangeReq;
}

void BMarketExchangeReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BMarketExchangeReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(usedtype_, gaintype_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BMarketExchangeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoResource.BMarketExchangeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 usedtype = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &usedtype_)));
          set_has_usedtype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_gaintype;
        break;
      }

      // required uint32 gaintype = 2;
      case 2: {
        if (tag == 16) {
         parse_gaintype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gaintype_)));
          set_has_gaintype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoResource.BMarketExchangeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoResource.BMarketExchangeReq)
  return false;
#undef DO_
}

void BMarketExchangeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoResource.BMarketExchangeReq)
  // required uint32 usedtype = 1;
  if (has_usedtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->usedtype(), output);
  }

  // required uint32 gaintype = 2;
  if (has_gaintype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gaintype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoResource.BMarketExchangeReq)
}

::google::protobuf::uint8* BMarketExchangeReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoResource.BMarketExchangeReq)
  // required uint32 usedtype = 1;
  if (has_usedtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->usedtype(), target);
  }

  // required uint32 gaintype = 2;
  if (has_gaintype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->gaintype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoResource.BMarketExchangeReq)
  return target;
}

int BMarketExchangeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 usedtype = 1;
    if (has_usedtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->usedtype());
    }

    // required uint32 gaintype = 2;
    if (has_gaintype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gaintype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BMarketExchangeReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BMarketExchangeReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BMarketExchangeReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BMarketExchangeReq::MergeFrom(const BMarketExchangeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_usedtype()) {
      set_usedtype(from.usedtype());
    }
    if (from.has_gaintype()) {
      set_gaintype(from.gaintype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BMarketExchangeReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BMarketExchangeReq::CopyFrom(const BMarketExchangeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BMarketExchangeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BMarketExchangeReq::Swap(BMarketExchangeReq* other) {
  if (other != this) {
    std::swap(usedtype_, other->usedtype_);
    std::swap(gaintype_, other->gaintype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BMarketExchangeReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BMarketExchangeReq_descriptor_;
  metadata.reflection = BMarketExchangeReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BMarketExchangeResp::kCoinFieldNumber;
const int BMarketExchangeResp::kWoodFieldNumber;
const int BMarketExchangeResp::kFoodFieldNumber;
const int BMarketExchangeResp::kBmarketcdFieldNumber;
#endif  // !_MSC_VER

BMarketExchangeResp::BMarketExchangeResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoResource.BMarketExchangeResp)
}

void BMarketExchangeResp::InitAsDefaultInstance() {
}

BMarketExchangeResp::BMarketExchangeResp(const BMarketExchangeResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoResource.BMarketExchangeResp)
}

void BMarketExchangeResp::SharedCtor() {
  _cached_size_ = 0;
  coin_ = 0u;
  wood_ = 0u;
  food_ = 0u;
  bmarketcd_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BMarketExchangeResp::~BMarketExchangeResp() {
  // @@protoc_insertion_point(destructor:ProtoResource.BMarketExchangeResp)
  SharedDtor();
}

void BMarketExchangeResp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BMarketExchangeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BMarketExchangeResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BMarketExchangeResp_descriptor_;
}

const BMarketExchangeResp& BMarketExchangeResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoResource_2eproto();
  return *default_instance_;
}

BMarketExchangeResp* BMarketExchangeResp::default_instance_ = NULL;

BMarketExchangeResp* BMarketExchangeResp::New() const {
  return new BMarketExchangeResp;
}

void BMarketExchangeResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BMarketExchangeResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(coin_, bmarketcd_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BMarketExchangeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoResource.BMarketExchangeResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 coin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_wood;
        break;
      }

      // required uint32 wood = 2;
      case 2: {
        if (tag == 16) {
         parse_wood:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wood_)));
          set_has_wood();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_food;
        break;
      }

      // required uint32 food = 3;
      case 3: {
        if (tag == 24) {
         parse_food:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &food_)));
          set_has_food();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_bmarketcd;
        break;
      }

      // required uint32 bmarketcd = 4;
      case 4: {
        if (tag == 32) {
         parse_bmarketcd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bmarketcd_)));
          set_has_bmarketcd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoResource.BMarketExchangeResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoResource.BMarketExchangeResp)
  return false;
#undef DO_
}

void BMarketExchangeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoResource.BMarketExchangeResp)
  // required uint32 coin = 1;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->coin(), output);
  }

  // required uint32 wood = 2;
  if (has_wood()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->wood(), output);
  }

  // required uint32 food = 3;
  if (has_food()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->food(), output);
  }

  // required uint32 bmarketcd = 4;
  if (has_bmarketcd()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->bmarketcd(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoResource.BMarketExchangeResp)
}

::google::protobuf::uint8* BMarketExchangeResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoResource.BMarketExchangeResp)
  // required uint32 coin = 1;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->coin(), target);
  }

  // required uint32 wood = 2;
  if (has_wood()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->wood(), target);
  }

  // required uint32 food = 3;
  if (has_food()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->food(), target);
  }

  // required uint32 bmarketcd = 4;
  if (has_bmarketcd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->bmarketcd(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoResource.BMarketExchangeResp)
  return target;
}

int BMarketExchangeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 coin = 1;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->coin());
    }

    // required uint32 wood = 2;
    if (has_wood()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->wood());
    }

    // required uint32 food = 3;
    if (has_food()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->food());
    }

    // required uint32 bmarketcd = 4;
    if (has_bmarketcd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bmarketcd());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BMarketExchangeResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BMarketExchangeResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BMarketExchangeResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BMarketExchangeResp::MergeFrom(const BMarketExchangeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_wood()) {
      set_wood(from.wood());
    }
    if (from.has_food()) {
      set_food(from.food());
    }
    if (from.has_bmarketcd()) {
      set_bmarketcd(from.bmarketcd());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BMarketExchangeResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BMarketExchangeResp::CopyFrom(const BMarketExchangeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BMarketExchangeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void BMarketExchangeResp::Swap(BMarketExchangeResp* other) {
  if (other != this) {
    std::swap(coin_, other->coin_);
    std::swap(wood_, other->wood_);
    std::swap(food_, other->food_);
    std::swap(bmarketcd_, other->bmarketcd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BMarketExchangeResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BMarketExchangeResp_descriptor_;
  metadata.reflection = BMarketExchangeResp_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoResource

// @@protoc_insertion_point(global_scope)
