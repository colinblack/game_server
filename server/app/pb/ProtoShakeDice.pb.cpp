// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoShakeDice.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoShakeDice.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ProtoShakeDice {

namespace {

const ::google::protobuf::Descriptor* ShakeDiceCPP_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShakeDiceCPP_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpenShakeDiceWindowReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpenShakeDiceWindowReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpenShakeDiceWindowResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpenShakeDiceWindowResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* RollDiceReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RollDiceReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* RollDiceResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RollDiceResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResetMapReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResetMapReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResetMapResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResetMapResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* EnterMapReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EnterMapReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* EnterMapResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EnterMapResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnlockMapReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnlockMapReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnlockMapResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnlockMapResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* PositionRewardReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PositionRewardReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* PositionRewardResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PositionRewardResp_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReceiveExtraRewardReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReceiveExtraRewardReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReceiveExtraRewardResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReceiveExtraRewardResp_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ProtoShakeDice_2eproto() {
  protobuf_AddDesc_ProtoShakeDice_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ProtoShakeDice.proto");
  GOOGLE_CHECK(file != NULL);
  ShakeDiceCPP_descriptor_ = file->message_type(0);
  static const int ShakeDiceCPP_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, curmap_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, map1_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, map2_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, map3_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, dice_times_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, reset_times_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, steps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, operate_ts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, extra_reward_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, map1_rewards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, map2_rewards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, map3_rewards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, curpos_),
  };
  ShakeDiceCPP_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShakeDiceCPP_descriptor_,
      ShakeDiceCPP::default_instance_,
      ShakeDiceCPP_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShakeDiceCPP, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShakeDiceCPP));
  OpenShakeDiceWindowReq_descriptor_ = file->message_type(1);
  static const int OpenShakeDiceWindowReq_offsets_[1] = {
  };
  OpenShakeDiceWindowReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OpenShakeDiceWindowReq_descriptor_,
      OpenShakeDiceWindowReq::default_instance_,
      OpenShakeDiceWindowReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenShakeDiceWindowReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenShakeDiceWindowReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OpenShakeDiceWindowReq));
  OpenShakeDiceWindowResp_descriptor_ = file->message_type(2);
  static const int OpenShakeDiceWindowResp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenShakeDiceWindowResp, dice_),
  };
  OpenShakeDiceWindowResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OpenShakeDiceWindowResp_descriptor_,
      OpenShakeDiceWindowResp::default_instance_,
      OpenShakeDiceWindowResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenShakeDiceWindowResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenShakeDiceWindowResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OpenShakeDiceWindowResp));
  RollDiceReq_descriptor_ = file->message_type(3);
  static const int RollDiceReq_offsets_[1] = {
  };
  RollDiceReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RollDiceReq_descriptor_,
      RollDiceReq::default_instance_,
      RollDiceReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RollDiceReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RollDiceReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RollDiceReq));
  RollDiceResp_descriptor_ = file->message_type(4);
  static const int RollDiceResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RollDiceResp, dice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RollDiceResp, cash_),
  };
  RollDiceResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RollDiceResp_descriptor_,
      RollDiceResp::default_instance_,
      RollDiceResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RollDiceResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RollDiceResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RollDiceResp));
  ResetMapReq_descriptor_ = file->message_type(5);
  static const int ResetMapReq_offsets_[1] = {
  };
  ResetMapReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResetMapReq_descriptor_,
      ResetMapReq::default_instance_,
      ResetMapReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetMapReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetMapReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResetMapReq));
  ResetMapResp_descriptor_ = file->message_type(6);
  static const int ResetMapResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetMapResp, dice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetMapResp, cash_),
  };
  ResetMapResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResetMapResp_descriptor_,
      ResetMapResp::default_instance_,
      ResetMapResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetMapResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetMapResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResetMapResp));
  EnterMapReq_descriptor_ = file->message_type(7);
  static const int EnterMapReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnterMapReq, mapid_),
  };
  EnterMapReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EnterMapReq_descriptor_,
      EnterMapReq::default_instance_,
      EnterMapReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnterMapReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnterMapReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EnterMapReq));
  EnterMapResp_descriptor_ = file->message_type(8);
  static const int EnterMapResp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnterMapResp, dice_),
  };
  EnterMapResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EnterMapResp_descriptor_,
      EnterMapResp::default_instance_,
      EnterMapResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnterMapResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EnterMapResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EnterMapResp));
  UnlockMapReq_descriptor_ = file->message_type(9);
  static const int UnlockMapReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnlockMapReq, mapid_),
  };
  UnlockMapReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnlockMapReq_descriptor_,
      UnlockMapReq::default_instance_,
      UnlockMapReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnlockMapReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnlockMapReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnlockMapReq));
  UnlockMapResp_descriptor_ = file->message_type(10);
  static const int UnlockMapResp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnlockMapResp, dice_),
  };
  UnlockMapResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnlockMapResp_descriptor_,
      UnlockMapResp::default_instance_,
      UnlockMapResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnlockMapResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnlockMapResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnlockMapResp));
  PositionRewardReq_descriptor_ = file->message_type(11);
  static const int PositionRewardReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardReq, pids_),
  };
  PositionRewardReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PositionRewardReq_descriptor_,
      PositionRewardReq::default_instance_,
      PositionRewardReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PositionRewardReq));
  PositionRewardResp_descriptor_ = file->message_type(12);
  static const int PositionRewardResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardResp, dice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardResp, reward_),
  };
  PositionRewardResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PositionRewardResp_descriptor_,
      PositionRewardResp::default_instance_,
      PositionRewardResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionRewardResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PositionRewardResp));
  ReceiveExtraRewardReq_descriptor_ = file->message_type(13);
  static const int ReceiveExtraRewardReq_offsets_[1] = {
  };
  ReceiveExtraRewardReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReceiveExtraRewardReq_descriptor_,
      ReceiveExtraRewardReq::default_instance_,
      ReceiveExtraRewardReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveExtraRewardReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveExtraRewardReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReceiveExtraRewardReq));
  ReceiveExtraRewardResp_descriptor_ = file->message_type(14);
  static const int ReceiveExtraRewardResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveExtraRewardResp, dice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveExtraRewardResp, reward_),
  };
  ReceiveExtraRewardResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReceiveExtraRewardResp_descriptor_,
      ReceiveExtraRewardResp::default_instance_,
      ReceiveExtraRewardResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveExtraRewardResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveExtraRewardResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReceiveExtraRewardResp));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ProtoShakeDice_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShakeDiceCPP_descriptor_, &ShakeDiceCPP::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OpenShakeDiceWindowReq_descriptor_, &OpenShakeDiceWindowReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OpenShakeDiceWindowResp_descriptor_, &OpenShakeDiceWindowResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RollDiceReq_descriptor_, &RollDiceReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RollDiceResp_descriptor_, &RollDiceResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResetMapReq_descriptor_, &ResetMapReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResetMapResp_descriptor_, &ResetMapResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EnterMapReq_descriptor_, &EnterMapReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EnterMapResp_descriptor_, &EnterMapResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnlockMapReq_descriptor_, &UnlockMapReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnlockMapResp_descriptor_, &UnlockMapResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PositionRewardReq_descriptor_, &PositionRewardReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PositionRewardResp_descriptor_, &PositionRewardResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReceiveExtraRewardReq_descriptor_, &ReceiveExtraRewardReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReceiveExtraRewardResp_descriptor_, &ReceiveExtraRewardResp::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ProtoShakeDice_2eproto() {
  delete ShakeDiceCPP::default_instance_;
  delete ShakeDiceCPP_reflection_;
  delete OpenShakeDiceWindowReq::default_instance_;
  delete OpenShakeDiceWindowReq_reflection_;
  delete OpenShakeDiceWindowResp::default_instance_;
  delete OpenShakeDiceWindowResp_reflection_;
  delete RollDiceReq::default_instance_;
  delete RollDiceReq_reflection_;
  delete RollDiceResp::default_instance_;
  delete RollDiceResp_reflection_;
  delete ResetMapReq::default_instance_;
  delete ResetMapReq_reflection_;
  delete ResetMapResp::default_instance_;
  delete ResetMapResp_reflection_;
  delete EnterMapReq::default_instance_;
  delete EnterMapReq_reflection_;
  delete EnterMapResp::default_instance_;
  delete EnterMapResp_reflection_;
  delete UnlockMapReq::default_instance_;
  delete UnlockMapReq_reflection_;
  delete UnlockMapResp::default_instance_;
  delete UnlockMapResp_reflection_;
  delete PositionRewardReq::default_instance_;
  delete PositionRewardReq_reflection_;
  delete PositionRewardResp::default_instance_;
  delete PositionRewardResp_reflection_;
  delete ReceiveExtraRewardReq::default_instance_;
  delete ReceiveExtraRewardReq_reflection_;
  delete ReceiveExtraRewardResp::default_instance_;
  delete ReceiveExtraRewardResp_reflection_;
}

void protobuf_AddDesc_ProtoShakeDice_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::User::protobuf_AddDesc_User_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024ProtoShakeDice.proto\022\016ProtoShakeDice\032\n"
    "User.proto\"\251\002\n\014ShakeDiceCPP\022\017\n\007version\030\001"
    " \002(\r\022\016\n\006curmap\030\002 \002(\r\022\023\n\013map1_status\030\003 \002("
    "\r\022\023\n\013map2_status\030\004 \002(\r\022\023\n\013map3_status\030\005 "
    "\002(\r\022\022\n\ndice_times\030\006 \002(\r\022\023\n\013reset_times\030\007"
    " \002(\r\022\r\n\005steps\030\010 \002(\r\022\022\n\noperate_ts\030\t \002(\r\022"
    "\033\n\023extra_reward_status\030\n \002(\r\022\024\n\014map1_rew"
    "ards\030\013 \002(\r\022\024\n\014map2_rewards\030\014 \002(\r\022\024\n\014map3"
    "_rewards\030\r \002(\r\022\016\n\006curpos\030\016 \002(\r\"\030\n\026OpenSh"
    "akeDiceWindowReq\"E\n\027OpenShakeDiceWindowR"
    "esp\022*\n\004dice\030\001 \002(\0132\034.ProtoShakeDice.Shake"
    "DiceCPP\"\r\n\013RollDiceReq\"H\n\014RollDiceResp\022*"
    "\n\004dice\030\001 \002(\0132\034.ProtoShakeDice.ShakeDiceC"
    "PP\022\014\n\004cash\030\002 \002(\r\"\r\n\013ResetMapReq\"H\n\014Reset"
    "MapResp\022*\n\004dice\030\001 \002(\0132\034.ProtoShakeDice.S"
    "hakeDiceCPP\022\014\n\004cash\030\002 \002(\r\"\034\n\013EnterMapReq"
    "\022\r\n\005mapid\030\001 \002(\r\":\n\014EnterMapResp\022*\n\004dice\030"
    "\001 \002(\0132\034.ProtoShakeDice.ShakeDiceCPP\"\035\n\014U"
    "nlockMapReq\022\r\n\005mapid\030\001 \002(\r\";\n\rUnlockMapR"
    "esp\022*\n\004dice\030\001 \002(\0132\034.ProtoShakeDice.Shake"
    "DiceCPP\"!\n\021PositionRewardReq\022\014\n\004pids\030\001 \003"
    "(\r\"e\n\022PositionRewardResp\022*\n\004dice\030\001 \002(\0132\034"
    ".ProtoShakeDice.ShakeDiceCPP\022#\n\006reward\030\002"
    " \002(\0132\023.User.RewardBagInfo\"\027\n\025ReceiveExtr"
    "aRewardReq\"i\n\026ReceiveExtraRewardResp\022*\n\004"
    "dice\030\001 \002(\0132\034.ProtoShakeDice.ShakeDiceCPP"
    "\022#\n\006reward\030\002 \002(\0132\023.User.RewardBagInfo", 1077);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ProtoShakeDice.proto", &protobuf_RegisterTypes);
  ShakeDiceCPP::default_instance_ = new ShakeDiceCPP();
  OpenShakeDiceWindowReq::default_instance_ = new OpenShakeDiceWindowReq();
  OpenShakeDiceWindowResp::default_instance_ = new OpenShakeDiceWindowResp();
  RollDiceReq::default_instance_ = new RollDiceReq();
  RollDiceResp::default_instance_ = new RollDiceResp();
  ResetMapReq::default_instance_ = new ResetMapReq();
  ResetMapResp::default_instance_ = new ResetMapResp();
  EnterMapReq::default_instance_ = new EnterMapReq();
  EnterMapResp::default_instance_ = new EnterMapResp();
  UnlockMapReq::default_instance_ = new UnlockMapReq();
  UnlockMapResp::default_instance_ = new UnlockMapResp();
  PositionRewardReq::default_instance_ = new PositionRewardReq();
  PositionRewardResp::default_instance_ = new PositionRewardResp();
  ReceiveExtraRewardReq::default_instance_ = new ReceiveExtraRewardReq();
  ReceiveExtraRewardResp::default_instance_ = new ReceiveExtraRewardResp();
  ShakeDiceCPP::default_instance_->InitAsDefaultInstance();
  OpenShakeDiceWindowReq::default_instance_->InitAsDefaultInstance();
  OpenShakeDiceWindowResp::default_instance_->InitAsDefaultInstance();
  RollDiceReq::default_instance_->InitAsDefaultInstance();
  RollDiceResp::default_instance_->InitAsDefaultInstance();
  ResetMapReq::default_instance_->InitAsDefaultInstance();
  ResetMapResp::default_instance_->InitAsDefaultInstance();
  EnterMapReq::default_instance_->InitAsDefaultInstance();
  EnterMapResp::default_instance_->InitAsDefaultInstance();
  UnlockMapReq::default_instance_->InitAsDefaultInstance();
  UnlockMapResp::default_instance_->InitAsDefaultInstance();
  PositionRewardReq::default_instance_->InitAsDefaultInstance();
  PositionRewardResp::default_instance_->InitAsDefaultInstance();
  ReceiveExtraRewardReq::default_instance_->InitAsDefaultInstance();
  ReceiveExtraRewardResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoShakeDice_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoShakeDice_2eproto {
  StaticDescriptorInitializer_ProtoShakeDice_2eproto() {
    protobuf_AddDesc_ProtoShakeDice_2eproto();
  }
} static_descriptor_initializer_ProtoShakeDice_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int ShakeDiceCPP::kVersionFieldNumber;
const int ShakeDiceCPP::kCurmapFieldNumber;
const int ShakeDiceCPP::kMap1StatusFieldNumber;
const int ShakeDiceCPP::kMap2StatusFieldNumber;
const int ShakeDiceCPP::kMap3StatusFieldNumber;
const int ShakeDiceCPP::kDiceTimesFieldNumber;
const int ShakeDiceCPP::kResetTimesFieldNumber;
const int ShakeDiceCPP::kStepsFieldNumber;
const int ShakeDiceCPP::kOperateTsFieldNumber;
const int ShakeDiceCPP::kExtraRewardStatusFieldNumber;
const int ShakeDiceCPP::kMap1RewardsFieldNumber;
const int ShakeDiceCPP::kMap2RewardsFieldNumber;
const int ShakeDiceCPP::kMap3RewardsFieldNumber;
const int ShakeDiceCPP::kCurposFieldNumber;
#endif  // !_MSC_VER

ShakeDiceCPP::ShakeDiceCPP()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.ShakeDiceCPP)
}

void ShakeDiceCPP::InitAsDefaultInstance() {
}

ShakeDiceCPP::ShakeDiceCPP(const ShakeDiceCPP& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.ShakeDiceCPP)
}

void ShakeDiceCPP::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  curmap_ = 0u;
  map1_status_ = 0u;
  map2_status_ = 0u;
  map3_status_ = 0u;
  dice_times_ = 0u;
  reset_times_ = 0u;
  steps_ = 0u;
  operate_ts_ = 0u;
  extra_reward_status_ = 0u;
  map1_rewards_ = 0u;
  map2_rewards_ = 0u;
  map3_rewards_ = 0u;
  curpos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShakeDiceCPP::~ShakeDiceCPP() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.ShakeDiceCPP)
  SharedDtor();
}

void ShakeDiceCPP::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShakeDiceCPP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShakeDiceCPP::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShakeDiceCPP_descriptor_;
}

const ShakeDiceCPP& ShakeDiceCPP::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

ShakeDiceCPP* ShakeDiceCPP::default_instance_ = NULL;

ShakeDiceCPP* ShakeDiceCPP::New() const {
  return new ShakeDiceCPP;
}

void ShakeDiceCPP::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ShakeDiceCPP*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(version_, steps_);
  }
  if (_has_bits_[8 / 32] & 16128) {
    ZR_(operate_ts_, curpos_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShakeDiceCPP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.ShakeDiceCPP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_curmap;
        break;
      }

      // required uint32 curmap = 2;
      case 2: {
        if (tag == 16) {
         parse_curmap:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curmap_)));
          set_has_curmap();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_map1_status;
        break;
      }

      // required uint32 map1_status = 3;
      case 3: {
        if (tag == 24) {
         parse_map1_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map1_status_)));
          set_has_map1_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_map2_status;
        break;
      }

      // required uint32 map2_status = 4;
      case 4: {
        if (tag == 32) {
         parse_map2_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map2_status_)));
          set_has_map2_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_map3_status;
        break;
      }

      // required uint32 map3_status = 5;
      case 5: {
        if (tag == 40) {
         parse_map3_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map3_status_)));
          set_has_map3_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_dice_times;
        break;
      }

      // required uint32 dice_times = 6;
      case 6: {
        if (tag == 48) {
         parse_dice_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dice_times_)));
          set_has_dice_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_reset_times;
        break;
      }

      // required uint32 reset_times = 7;
      case 7: {
        if (tag == 56) {
         parse_reset_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reset_times_)));
          set_has_reset_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_steps;
        break;
      }

      // required uint32 steps = 8;
      case 8: {
        if (tag == 64) {
         parse_steps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steps_)));
          set_has_steps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_operate_ts;
        break;
      }

      // required uint32 operate_ts = 9;
      case 9: {
        if (tag == 72) {
         parse_operate_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &operate_ts_)));
          set_has_operate_ts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_extra_reward_status;
        break;
      }

      // required uint32 extra_reward_status = 10;
      case 10: {
        if (tag == 80) {
         parse_extra_reward_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_reward_status_)));
          set_has_extra_reward_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_map1_rewards;
        break;
      }

      // required uint32 map1_rewards = 11;
      case 11: {
        if (tag == 88) {
         parse_map1_rewards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map1_rewards_)));
          set_has_map1_rewards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_map2_rewards;
        break;
      }

      // required uint32 map2_rewards = 12;
      case 12: {
        if (tag == 96) {
         parse_map2_rewards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map2_rewards_)));
          set_has_map2_rewards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_map3_rewards;
        break;
      }

      // required uint32 map3_rewards = 13;
      case 13: {
        if (tag == 104) {
         parse_map3_rewards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &map3_rewards_)));
          set_has_map3_rewards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_curpos;
        break;
      }

      // required uint32 curpos = 14;
      case 14: {
        if (tag == 112) {
         parse_curpos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curpos_)));
          set_has_curpos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.ShakeDiceCPP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.ShakeDiceCPP)
  return false;
#undef DO_
}

void ShakeDiceCPP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.ShakeDiceCPP)
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required uint32 curmap = 2;
  if (has_curmap()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->curmap(), output);
  }

  // required uint32 map1_status = 3;
  if (has_map1_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->map1_status(), output);
  }

  // required uint32 map2_status = 4;
  if (has_map2_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->map2_status(), output);
  }

  // required uint32 map3_status = 5;
  if (has_map3_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->map3_status(), output);
  }

  // required uint32 dice_times = 6;
  if (has_dice_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->dice_times(), output);
  }

  // required uint32 reset_times = 7;
  if (has_reset_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->reset_times(), output);
  }

  // required uint32 steps = 8;
  if (has_steps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->steps(), output);
  }

  // required uint32 operate_ts = 9;
  if (has_operate_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->operate_ts(), output);
  }

  // required uint32 extra_reward_status = 10;
  if (has_extra_reward_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->extra_reward_status(), output);
  }

  // required uint32 map1_rewards = 11;
  if (has_map1_rewards()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->map1_rewards(), output);
  }

  // required uint32 map2_rewards = 12;
  if (has_map2_rewards()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->map2_rewards(), output);
  }

  // required uint32 map3_rewards = 13;
  if (has_map3_rewards()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->map3_rewards(), output);
  }

  // required uint32 curpos = 14;
  if (has_curpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->curpos(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.ShakeDiceCPP)
}

::google::protobuf::uint8* ShakeDiceCPP::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.ShakeDiceCPP)
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required uint32 curmap = 2;
  if (has_curmap()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->curmap(), target);
  }

  // required uint32 map1_status = 3;
  if (has_map1_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->map1_status(), target);
  }

  // required uint32 map2_status = 4;
  if (has_map2_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->map2_status(), target);
  }

  // required uint32 map3_status = 5;
  if (has_map3_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->map3_status(), target);
  }

  // required uint32 dice_times = 6;
  if (has_dice_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->dice_times(), target);
  }

  // required uint32 reset_times = 7;
  if (has_reset_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->reset_times(), target);
  }

  // required uint32 steps = 8;
  if (has_steps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->steps(), target);
  }

  // required uint32 operate_ts = 9;
  if (has_operate_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->operate_ts(), target);
  }

  // required uint32 extra_reward_status = 10;
  if (has_extra_reward_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->extra_reward_status(), target);
  }

  // required uint32 map1_rewards = 11;
  if (has_map1_rewards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->map1_rewards(), target);
  }

  // required uint32 map2_rewards = 12;
  if (has_map2_rewards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->map2_rewards(), target);
  }

  // required uint32 map3_rewards = 13;
  if (has_map3_rewards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->map3_rewards(), target);
  }

  // required uint32 curpos = 14;
  if (has_curpos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->curpos(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.ShakeDiceCPP)
  return target;
}

int ShakeDiceCPP::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint32 curmap = 2;
    if (has_curmap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->curmap());
    }

    // required uint32 map1_status = 3;
    if (has_map1_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map1_status());
    }

    // required uint32 map2_status = 4;
    if (has_map2_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map2_status());
    }

    // required uint32 map3_status = 5;
    if (has_map3_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map3_status());
    }

    // required uint32 dice_times = 6;
    if (has_dice_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dice_times());
    }

    // required uint32 reset_times = 7;
    if (has_reset_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reset_times());
    }

    // required uint32 steps = 8;
    if (has_steps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steps());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 operate_ts = 9;
    if (has_operate_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->operate_ts());
    }

    // required uint32 extra_reward_status = 10;
    if (has_extra_reward_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_reward_status());
    }

    // required uint32 map1_rewards = 11;
    if (has_map1_rewards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map1_rewards());
    }

    // required uint32 map2_rewards = 12;
    if (has_map2_rewards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map2_rewards());
    }

    // required uint32 map3_rewards = 13;
    if (has_map3_rewards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->map3_rewards());
    }

    // required uint32 curpos = 14;
    if (has_curpos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->curpos());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShakeDiceCPP::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShakeDiceCPP* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShakeDiceCPP*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShakeDiceCPP::MergeFrom(const ShakeDiceCPP& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_curmap()) {
      set_curmap(from.curmap());
    }
    if (from.has_map1_status()) {
      set_map1_status(from.map1_status());
    }
    if (from.has_map2_status()) {
      set_map2_status(from.map2_status());
    }
    if (from.has_map3_status()) {
      set_map3_status(from.map3_status());
    }
    if (from.has_dice_times()) {
      set_dice_times(from.dice_times());
    }
    if (from.has_reset_times()) {
      set_reset_times(from.reset_times());
    }
    if (from.has_steps()) {
      set_steps(from.steps());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_operate_ts()) {
      set_operate_ts(from.operate_ts());
    }
    if (from.has_extra_reward_status()) {
      set_extra_reward_status(from.extra_reward_status());
    }
    if (from.has_map1_rewards()) {
      set_map1_rewards(from.map1_rewards());
    }
    if (from.has_map2_rewards()) {
      set_map2_rewards(from.map2_rewards());
    }
    if (from.has_map3_rewards()) {
      set_map3_rewards(from.map3_rewards());
    }
    if (from.has_curpos()) {
      set_curpos(from.curpos());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShakeDiceCPP::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShakeDiceCPP::CopyFrom(const ShakeDiceCPP& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShakeDiceCPP::IsInitialized() const {
  if ((_has_bits_[0] & 0x00003fff) != 0x00003fff) return false;

  return true;
}

void ShakeDiceCPP::Swap(ShakeDiceCPP* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(curmap_, other->curmap_);
    std::swap(map1_status_, other->map1_status_);
    std::swap(map2_status_, other->map2_status_);
    std::swap(map3_status_, other->map3_status_);
    std::swap(dice_times_, other->dice_times_);
    std::swap(reset_times_, other->reset_times_);
    std::swap(steps_, other->steps_);
    std::swap(operate_ts_, other->operate_ts_);
    std::swap(extra_reward_status_, other->extra_reward_status_);
    std::swap(map1_rewards_, other->map1_rewards_);
    std::swap(map2_rewards_, other->map2_rewards_);
    std::swap(map3_rewards_, other->map3_rewards_);
    std::swap(curpos_, other->curpos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShakeDiceCPP::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShakeDiceCPP_descriptor_;
  metadata.reflection = ShakeDiceCPP_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

OpenShakeDiceWindowReq::OpenShakeDiceWindowReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.OpenShakeDiceWindowReq)
}

void OpenShakeDiceWindowReq::InitAsDefaultInstance() {
}

OpenShakeDiceWindowReq::OpenShakeDiceWindowReq(const OpenShakeDiceWindowReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.OpenShakeDiceWindowReq)
}

void OpenShakeDiceWindowReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenShakeDiceWindowReq::~OpenShakeDiceWindowReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.OpenShakeDiceWindowReq)
  SharedDtor();
}

void OpenShakeDiceWindowReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OpenShakeDiceWindowReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpenShakeDiceWindowReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpenShakeDiceWindowReq_descriptor_;
}

const OpenShakeDiceWindowReq& OpenShakeDiceWindowReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

OpenShakeDiceWindowReq* OpenShakeDiceWindowReq::default_instance_ = NULL;

OpenShakeDiceWindowReq* OpenShakeDiceWindowReq::New() const {
  return new OpenShakeDiceWindowReq;
}

void OpenShakeDiceWindowReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OpenShakeDiceWindowReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.OpenShakeDiceWindowReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.OpenShakeDiceWindowReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.OpenShakeDiceWindowReq)
  return false;
#undef DO_
}

void OpenShakeDiceWindowReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.OpenShakeDiceWindowReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.OpenShakeDiceWindowReq)
}

::google::protobuf::uint8* OpenShakeDiceWindowReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.OpenShakeDiceWindowReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.OpenShakeDiceWindowReq)
  return target;
}

int OpenShakeDiceWindowReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenShakeDiceWindowReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OpenShakeDiceWindowReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OpenShakeDiceWindowReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OpenShakeDiceWindowReq::MergeFrom(const OpenShakeDiceWindowReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OpenShakeDiceWindowReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpenShakeDiceWindowReq::CopyFrom(const OpenShakeDiceWindowReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenShakeDiceWindowReq::IsInitialized() const {

  return true;
}

void OpenShakeDiceWindowReq::Swap(OpenShakeDiceWindowReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OpenShakeDiceWindowReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpenShakeDiceWindowReq_descriptor_;
  metadata.reflection = OpenShakeDiceWindowReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OpenShakeDiceWindowResp::kDiceFieldNumber;
#endif  // !_MSC_VER

OpenShakeDiceWindowResp::OpenShakeDiceWindowResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.OpenShakeDiceWindowResp)
}

void OpenShakeDiceWindowResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
}

OpenShakeDiceWindowResp::OpenShakeDiceWindowResp(const OpenShakeDiceWindowResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.OpenShakeDiceWindowResp)
}

void OpenShakeDiceWindowResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenShakeDiceWindowResp::~OpenShakeDiceWindowResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.OpenShakeDiceWindowResp)
  SharedDtor();
}

void OpenShakeDiceWindowResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
  }
}

void OpenShakeDiceWindowResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpenShakeDiceWindowResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpenShakeDiceWindowResp_descriptor_;
}

const OpenShakeDiceWindowResp& OpenShakeDiceWindowResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

OpenShakeDiceWindowResp* OpenShakeDiceWindowResp::default_instance_ = NULL;

OpenShakeDiceWindowResp* OpenShakeDiceWindowResp::New() const {
  return new OpenShakeDiceWindowResp;
}

void OpenShakeDiceWindowResp::Clear() {
  if (has_dice()) {
    if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OpenShakeDiceWindowResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.OpenShakeDiceWindowResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.OpenShakeDiceWindowResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.OpenShakeDiceWindowResp)
  return false;
#undef DO_
}

void OpenShakeDiceWindowResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.OpenShakeDiceWindowResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.OpenShakeDiceWindowResp)
}

::google::protobuf::uint8* OpenShakeDiceWindowResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.OpenShakeDiceWindowResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.OpenShakeDiceWindowResp)
  return target;
}

int OpenShakeDiceWindowResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenShakeDiceWindowResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OpenShakeDiceWindowResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OpenShakeDiceWindowResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OpenShakeDiceWindowResp::MergeFrom(const OpenShakeDiceWindowResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OpenShakeDiceWindowResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpenShakeDiceWindowResp::CopyFrom(const OpenShakeDiceWindowResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenShakeDiceWindowResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  return true;
}

void OpenShakeDiceWindowResp::Swap(OpenShakeDiceWindowResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OpenShakeDiceWindowResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpenShakeDiceWindowResp_descriptor_;
  metadata.reflection = OpenShakeDiceWindowResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RollDiceReq::RollDiceReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.RollDiceReq)
}

void RollDiceReq::InitAsDefaultInstance() {
}

RollDiceReq::RollDiceReq(const RollDiceReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.RollDiceReq)
}

void RollDiceReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RollDiceReq::~RollDiceReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.RollDiceReq)
  SharedDtor();
}

void RollDiceReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RollDiceReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RollDiceReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RollDiceReq_descriptor_;
}

const RollDiceReq& RollDiceReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

RollDiceReq* RollDiceReq::default_instance_ = NULL;

RollDiceReq* RollDiceReq::New() const {
  return new RollDiceReq;
}

void RollDiceReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RollDiceReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.RollDiceReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.RollDiceReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.RollDiceReq)
  return false;
#undef DO_
}

void RollDiceReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.RollDiceReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.RollDiceReq)
}

::google::protobuf::uint8* RollDiceReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.RollDiceReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.RollDiceReq)
  return target;
}

int RollDiceReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RollDiceReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RollDiceReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RollDiceReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RollDiceReq::MergeFrom(const RollDiceReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RollDiceReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RollDiceReq::CopyFrom(const RollDiceReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RollDiceReq::IsInitialized() const {

  return true;
}

void RollDiceReq::Swap(RollDiceReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RollDiceReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RollDiceReq_descriptor_;
  metadata.reflection = RollDiceReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RollDiceResp::kDiceFieldNumber;
const int RollDiceResp::kCashFieldNumber;
#endif  // !_MSC_VER

RollDiceResp::RollDiceResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.RollDiceResp)
}

void RollDiceResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
}

RollDiceResp::RollDiceResp(const RollDiceResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.RollDiceResp)
}

void RollDiceResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  cash_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RollDiceResp::~RollDiceResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.RollDiceResp)
  SharedDtor();
}

void RollDiceResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
  }
}

void RollDiceResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RollDiceResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RollDiceResp_descriptor_;
}

const RollDiceResp& RollDiceResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

RollDiceResp* RollDiceResp::default_instance_ = NULL;

RollDiceResp* RollDiceResp::New() const {
  return new RollDiceResp;
}

void RollDiceResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_dice()) {
      if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
    }
    cash_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RollDiceResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.RollDiceResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cash;
        break;
      }

      // required uint32 cash = 2;
      case 2: {
        if (tag == 16) {
         parse_cash:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cash_)));
          set_has_cash();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.RollDiceResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.RollDiceResp)
  return false;
#undef DO_
}

void RollDiceResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.RollDiceResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  // required uint32 cash = 2;
  if (has_cash()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.RollDiceResp)
}

::google::protobuf::uint8* RollDiceResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.RollDiceResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  // required uint32 cash = 2;
  if (has_cash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.RollDiceResp)
  return target;
}

int RollDiceResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

    // required uint32 cash = 2;
    if (has_cash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RollDiceResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RollDiceResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RollDiceResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RollDiceResp::MergeFrom(const RollDiceResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
    if (from.has_cash()) {
      set_cash(from.cash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RollDiceResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RollDiceResp::CopyFrom(const RollDiceResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RollDiceResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  return true;
}

void RollDiceResp::Swap(RollDiceResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(cash_, other->cash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RollDiceResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RollDiceResp_descriptor_;
  metadata.reflection = RollDiceResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ResetMapReq::ResetMapReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.ResetMapReq)
}

void ResetMapReq::InitAsDefaultInstance() {
}

ResetMapReq::ResetMapReq(const ResetMapReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.ResetMapReq)
}

void ResetMapReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetMapReq::~ResetMapReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.ResetMapReq)
  SharedDtor();
}

void ResetMapReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResetMapReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetMapReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetMapReq_descriptor_;
}

const ResetMapReq& ResetMapReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

ResetMapReq* ResetMapReq::default_instance_ = NULL;

ResetMapReq* ResetMapReq::New() const {
  return new ResetMapReq;
}

void ResetMapReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResetMapReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.ResetMapReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.ResetMapReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.ResetMapReq)
  return false;
#undef DO_
}

void ResetMapReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.ResetMapReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.ResetMapReq)
}

::google::protobuf::uint8* ResetMapReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.ResetMapReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.ResetMapReq)
  return target;
}

int ResetMapReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetMapReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResetMapReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResetMapReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResetMapReq::MergeFrom(const ResetMapReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResetMapReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetMapReq::CopyFrom(const ResetMapReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetMapReq::IsInitialized() const {

  return true;
}

void ResetMapReq::Swap(ResetMapReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResetMapReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResetMapReq_descriptor_;
  metadata.reflection = ResetMapReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResetMapResp::kDiceFieldNumber;
const int ResetMapResp::kCashFieldNumber;
#endif  // !_MSC_VER

ResetMapResp::ResetMapResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.ResetMapResp)
}

void ResetMapResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
}

ResetMapResp::ResetMapResp(const ResetMapResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.ResetMapResp)
}

void ResetMapResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  cash_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetMapResp::~ResetMapResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.ResetMapResp)
  SharedDtor();
}

void ResetMapResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
  }
}

void ResetMapResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetMapResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetMapResp_descriptor_;
}

const ResetMapResp& ResetMapResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

ResetMapResp* ResetMapResp::default_instance_ = NULL;

ResetMapResp* ResetMapResp::New() const {
  return new ResetMapResp;
}

void ResetMapResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_dice()) {
      if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
    }
    cash_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResetMapResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.ResetMapResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cash;
        break;
      }

      // required uint32 cash = 2;
      case 2: {
        if (tag == 16) {
         parse_cash:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cash_)));
          set_has_cash();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.ResetMapResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.ResetMapResp)
  return false;
#undef DO_
}

void ResetMapResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.ResetMapResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  // required uint32 cash = 2;
  if (has_cash()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.ResetMapResp)
}

::google::protobuf::uint8* ResetMapResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.ResetMapResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  // required uint32 cash = 2;
  if (has_cash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.ResetMapResp)
  return target;
}

int ResetMapResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

    // required uint32 cash = 2;
    if (has_cash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetMapResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResetMapResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResetMapResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResetMapResp::MergeFrom(const ResetMapResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
    if (from.has_cash()) {
      set_cash(from.cash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResetMapResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetMapResp::CopyFrom(const ResetMapResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetMapResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  return true;
}

void ResetMapResp::Swap(ResetMapResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(cash_, other->cash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResetMapResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResetMapResp_descriptor_;
  metadata.reflection = ResetMapResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EnterMapReq::kMapidFieldNumber;
#endif  // !_MSC_VER

EnterMapReq::EnterMapReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.EnterMapReq)
}

void EnterMapReq::InitAsDefaultInstance() {
}

EnterMapReq::EnterMapReq(const EnterMapReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.EnterMapReq)
}

void EnterMapReq::SharedCtor() {
  _cached_size_ = 0;
  mapid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterMapReq::~EnterMapReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.EnterMapReq)
  SharedDtor();
}

void EnterMapReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EnterMapReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EnterMapReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EnterMapReq_descriptor_;
}

const EnterMapReq& EnterMapReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

EnterMapReq* EnterMapReq::default_instance_ = NULL;

EnterMapReq* EnterMapReq::New() const {
  return new EnterMapReq;
}

void EnterMapReq::Clear() {
  mapid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EnterMapReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.EnterMapReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 mapid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.EnterMapReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.EnterMapReq)
  return false;
#undef DO_
}

void EnterMapReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.EnterMapReq)
  // required uint32 mapid = 1;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mapid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.EnterMapReq)
}

::google::protobuf::uint8* EnterMapReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.EnterMapReq)
  // required uint32 mapid = 1;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->mapid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.EnterMapReq)
  return target;
}

int EnterMapReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 mapid = 1;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mapid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterMapReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EnterMapReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EnterMapReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EnterMapReq::MergeFrom(const EnterMapReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EnterMapReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EnterMapReq::CopyFrom(const EnterMapReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterMapReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EnterMapReq::Swap(EnterMapReq* other) {
  if (other != this) {
    std::swap(mapid_, other->mapid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EnterMapReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EnterMapReq_descriptor_;
  metadata.reflection = EnterMapReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EnterMapResp::kDiceFieldNumber;
#endif  // !_MSC_VER

EnterMapResp::EnterMapResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.EnterMapResp)
}

void EnterMapResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
}

EnterMapResp::EnterMapResp(const EnterMapResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.EnterMapResp)
}

void EnterMapResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterMapResp::~EnterMapResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.EnterMapResp)
  SharedDtor();
}

void EnterMapResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
  }
}

void EnterMapResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EnterMapResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EnterMapResp_descriptor_;
}

const EnterMapResp& EnterMapResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

EnterMapResp* EnterMapResp::default_instance_ = NULL;

EnterMapResp* EnterMapResp::New() const {
  return new EnterMapResp;
}

void EnterMapResp::Clear() {
  if (has_dice()) {
    if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EnterMapResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.EnterMapResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.EnterMapResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.EnterMapResp)
  return false;
#undef DO_
}

void EnterMapResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.EnterMapResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.EnterMapResp)
}

::google::protobuf::uint8* EnterMapResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.EnterMapResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.EnterMapResp)
  return target;
}

int EnterMapResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterMapResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EnterMapResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EnterMapResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EnterMapResp::MergeFrom(const EnterMapResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EnterMapResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EnterMapResp::CopyFrom(const EnterMapResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterMapResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  return true;
}

void EnterMapResp::Swap(EnterMapResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EnterMapResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EnterMapResp_descriptor_;
  metadata.reflection = EnterMapResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnlockMapReq::kMapidFieldNumber;
#endif  // !_MSC_VER

UnlockMapReq::UnlockMapReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.UnlockMapReq)
}

void UnlockMapReq::InitAsDefaultInstance() {
}

UnlockMapReq::UnlockMapReq(const UnlockMapReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.UnlockMapReq)
}

void UnlockMapReq::SharedCtor() {
  _cached_size_ = 0;
  mapid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnlockMapReq::~UnlockMapReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.UnlockMapReq)
  SharedDtor();
}

void UnlockMapReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UnlockMapReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnlockMapReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnlockMapReq_descriptor_;
}

const UnlockMapReq& UnlockMapReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

UnlockMapReq* UnlockMapReq::default_instance_ = NULL;

UnlockMapReq* UnlockMapReq::New() const {
  return new UnlockMapReq;
}

void UnlockMapReq::Clear() {
  mapid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnlockMapReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.UnlockMapReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 mapid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.UnlockMapReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.UnlockMapReq)
  return false;
#undef DO_
}

void UnlockMapReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.UnlockMapReq)
  // required uint32 mapid = 1;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mapid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.UnlockMapReq)
}

::google::protobuf::uint8* UnlockMapReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.UnlockMapReq)
  // required uint32 mapid = 1;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->mapid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.UnlockMapReq)
  return target;
}

int UnlockMapReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 mapid = 1;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mapid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnlockMapReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnlockMapReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnlockMapReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnlockMapReq::MergeFrom(const UnlockMapReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnlockMapReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnlockMapReq::CopyFrom(const UnlockMapReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnlockMapReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UnlockMapReq::Swap(UnlockMapReq* other) {
  if (other != this) {
    std::swap(mapid_, other->mapid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnlockMapReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnlockMapReq_descriptor_;
  metadata.reflection = UnlockMapReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnlockMapResp::kDiceFieldNumber;
#endif  // !_MSC_VER

UnlockMapResp::UnlockMapResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.UnlockMapResp)
}

void UnlockMapResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
}

UnlockMapResp::UnlockMapResp(const UnlockMapResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.UnlockMapResp)
}

void UnlockMapResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnlockMapResp::~UnlockMapResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.UnlockMapResp)
  SharedDtor();
}

void UnlockMapResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
  }
}

void UnlockMapResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnlockMapResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnlockMapResp_descriptor_;
}

const UnlockMapResp& UnlockMapResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

UnlockMapResp* UnlockMapResp::default_instance_ = NULL;

UnlockMapResp* UnlockMapResp::New() const {
  return new UnlockMapResp;
}

void UnlockMapResp::Clear() {
  if (has_dice()) {
    if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnlockMapResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.UnlockMapResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.UnlockMapResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.UnlockMapResp)
  return false;
#undef DO_
}

void UnlockMapResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.UnlockMapResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.UnlockMapResp)
}

::google::protobuf::uint8* UnlockMapResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.UnlockMapResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.UnlockMapResp)
  return target;
}

int UnlockMapResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnlockMapResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnlockMapResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnlockMapResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnlockMapResp::MergeFrom(const UnlockMapResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnlockMapResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnlockMapResp::CopyFrom(const UnlockMapResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnlockMapResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  return true;
}

void UnlockMapResp::Swap(UnlockMapResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnlockMapResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnlockMapResp_descriptor_;
  metadata.reflection = UnlockMapResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PositionRewardReq::kPidsFieldNumber;
#endif  // !_MSC_VER

PositionRewardReq::PositionRewardReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.PositionRewardReq)
}

void PositionRewardReq::InitAsDefaultInstance() {
}

PositionRewardReq::PositionRewardReq(const PositionRewardReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.PositionRewardReq)
}

void PositionRewardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PositionRewardReq::~PositionRewardReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.PositionRewardReq)
  SharedDtor();
}

void PositionRewardReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PositionRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PositionRewardReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PositionRewardReq_descriptor_;
}

const PositionRewardReq& PositionRewardReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

PositionRewardReq* PositionRewardReq::default_instance_ = NULL;

PositionRewardReq* PositionRewardReq::New() const {
  return new PositionRewardReq;
}

void PositionRewardReq::Clear() {
  pids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PositionRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.PositionRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 pids = 1;
      case 1: {
        if (tag == 8) {
         parse_pids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_pids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_pids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_pids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.PositionRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.PositionRewardReq)
  return false;
#undef DO_
}

void PositionRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.PositionRewardReq)
  // repeated uint32 pids = 1;
  for (int i = 0; i < this->pids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->pids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.PositionRewardReq)
}

::google::protobuf::uint8* PositionRewardReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.PositionRewardReq)
  // repeated uint32 pids = 1;
  for (int i = 0; i < this->pids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->pids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.PositionRewardReq)
  return target;
}

int PositionRewardReq::ByteSize() const {
  int total_size = 0;

  // repeated uint32 pids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->pids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->pids(i));
    }
    total_size += 1 * this->pids_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PositionRewardReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PositionRewardReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PositionRewardReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PositionRewardReq::MergeFrom(const PositionRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  pids_.MergeFrom(from.pids_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PositionRewardReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PositionRewardReq::CopyFrom(const PositionRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionRewardReq::IsInitialized() const {

  return true;
}

void PositionRewardReq::Swap(PositionRewardReq* other) {
  if (other != this) {
    pids_.Swap(&other->pids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PositionRewardReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PositionRewardReq_descriptor_;
  metadata.reflection = PositionRewardReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PositionRewardResp::kDiceFieldNumber;
const int PositionRewardResp::kRewardFieldNumber;
#endif  // !_MSC_VER

PositionRewardResp::PositionRewardResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.PositionRewardResp)
}

void PositionRewardResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
  reward_ = const_cast< ::User::RewardBagInfo*>(&::User::RewardBagInfo::default_instance());
}

PositionRewardResp::PositionRewardResp(const PositionRewardResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.PositionRewardResp)
}

void PositionRewardResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  reward_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PositionRewardResp::~PositionRewardResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.PositionRewardResp)
  SharedDtor();
}

void PositionRewardResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
    delete reward_;
  }
}

void PositionRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PositionRewardResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PositionRewardResp_descriptor_;
}

const PositionRewardResp& PositionRewardResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

PositionRewardResp* PositionRewardResp::default_instance_ = NULL;

PositionRewardResp* PositionRewardResp::New() const {
  return new PositionRewardResp;
}

void PositionRewardResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_dice()) {
      if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
    }
    if (has_reward()) {
      if (reward_ != NULL) reward_->::User::RewardBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PositionRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.PositionRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reward;
        break;
      }

      // required .User.RewardBagInfo reward = 2;
      case 2: {
        if (tag == 18) {
         parse_reward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reward()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.PositionRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.PositionRewardResp)
  return false;
#undef DO_
}

void PositionRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.PositionRewardResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  // required .User.RewardBagInfo reward = 2;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reward(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.PositionRewardResp)
}

::google::protobuf::uint8* PositionRewardResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.PositionRewardResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  // required .User.RewardBagInfo reward = 2;
  if (has_reward()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reward(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.PositionRewardResp)
  return target;
}

int PositionRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

    // required .User.RewardBagInfo reward = 2;
    if (has_reward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reward());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PositionRewardResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PositionRewardResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PositionRewardResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PositionRewardResp::MergeFrom(const PositionRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
    if (from.has_reward()) {
      mutable_reward()->::User::RewardBagInfo::MergeFrom(from.reward());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PositionRewardResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PositionRewardResp::CopyFrom(const PositionRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  if (has_reward()) {
    if (!this->reward().IsInitialized()) return false;
  }
  return true;
}

void PositionRewardResp::Swap(PositionRewardResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(reward_, other->reward_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PositionRewardResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PositionRewardResp_descriptor_;
  metadata.reflection = PositionRewardResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ReceiveExtraRewardReq::ReceiveExtraRewardReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.ReceiveExtraRewardReq)
}

void ReceiveExtraRewardReq::InitAsDefaultInstance() {
}

ReceiveExtraRewardReq::ReceiveExtraRewardReq(const ReceiveExtraRewardReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.ReceiveExtraRewardReq)
}

void ReceiveExtraRewardReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReceiveExtraRewardReq::~ReceiveExtraRewardReq() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.ReceiveExtraRewardReq)
  SharedDtor();
}

void ReceiveExtraRewardReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReceiveExtraRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReceiveExtraRewardReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReceiveExtraRewardReq_descriptor_;
}

const ReceiveExtraRewardReq& ReceiveExtraRewardReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

ReceiveExtraRewardReq* ReceiveExtraRewardReq::default_instance_ = NULL;

ReceiveExtraRewardReq* ReceiveExtraRewardReq::New() const {
  return new ReceiveExtraRewardReq;
}

void ReceiveExtraRewardReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReceiveExtraRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.ReceiveExtraRewardReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.ReceiveExtraRewardReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.ReceiveExtraRewardReq)
  return false;
#undef DO_
}

void ReceiveExtraRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.ReceiveExtraRewardReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.ReceiveExtraRewardReq)
}

::google::protobuf::uint8* ReceiveExtraRewardReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.ReceiveExtraRewardReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.ReceiveExtraRewardReq)
  return target;
}

int ReceiveExtraRewardReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReceiveExtraRewardReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReceiveExtraRewardReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReceiveExtraRewardReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReceiveExtraRewardReq::MergeFrom(const ReceiveExtraRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReceiveExtraRewardReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReceiveExtraRewardReq::CopyFrom(const ReceiveExtraRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiveExtraRewardReq::IsInitialized() const {

  return true;
}

void ReceiveExtraRewardReq::Swap(ReceiveExtraRewardReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReceiveExtraRewardReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReceiveExtraRewardReq_descriptor_;
  metadata.reflection = ReceiveExtraRewardReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReceiveExtraRewardResp::kDiceFieldNumber;
const int ReceiveExtraRewardResp::kRewardFieldNumber;
#endif  // !_MSC_VER

ReceiveExtraRewardResp::ReceiveExtraRewardResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoShakeDice.ReceiveExtraRewardResp)
}

void ReceiveExtraRewardResp::InitAsDefaultInstance() {
  dice_ = const_cast< ::ProtoShakeDice::ShakeDiceCPP*>(&::ProtoShakeDice::ShakeDiceCPP::default_instance());
  reward_ = const_cast< ::User::RewardBagInfo*>(&::User::RewardBagInfo::default_instance());
}

ReceiveExtraRewardResp::ReceiveExtraRewardResp(const ReceiveExtraRewardResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoShakeDice.ReceiveExtraRewardResp)
}

void ReceiveExtraRewardResp::SharedCtor() {
  _cached_size_ = 0;
  dice_ = NULL;
  reward_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReceiveExtraRewardResp::~ReceiveExtraRewardResp() {
  // @@protoc_insertion_point(destructor:ProtoShakeDice.ReceiveExtraRewardResp)
  SharedDtor();
}

void ReceiveExtraRewardResp::SharedDtor() {
  if (this != default_instance_) {
    delete dice_;
    delete reward_;
  }
}

void ReceiveExtraRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReceiveExtraRewardResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReceiveExtraRewardResp_descriptor_;
}

const ReceiveExtraRewardResp& ReceiveExtraRewardResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoShakeDice_2eproto();
  return *default_instance_;
}

ReceiveExtraRewardResp* ReceiveExtraRewardResp::default_instance_ = NULL;

ReceiveExtraRewardResp* ReceiveExtraRewardResp::New() const {
  return new ReceiveExtraRewardResp;
}

void ReceiveExtraRewardResp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_dice()) {
      if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
    }
    if (has_reward()) {
      if (reward_ != NULL) reward_->::User::RewardBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReceiveExtraRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoShakeDice.ReceiveExtraRewardResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reward;
        break;
      }

      // required .User.RewardBagInfo reward = 2;
      case 2: {
        if (tag == 18) {
         parse_reward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reward()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoShakeDice.ReceiveExtraRewardResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoShakeDice.ReceiveExtraRewardResp)
  return false;
#undef DO_
}

void ReceiveExtraRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoShakeDice.ReceiveExtraRewardResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dice(), output);
  }

  // required .User.RewardBagInfo reward = 2;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reward(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoShakeDice.ReceiveExtraRewardResp)
}

::google::protobuf::uint8* ReceiveExtraRewardResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoShakeDice.ReceiveExtraRewardResp)
  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  if (has_dice()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dice(), target);
  }

  // required .User.RewardBagInfo reward = 2;
  if (has_reward()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reward(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoShakeDice.ReceiveExtraRewardResp)
  return target;
}

int ReceiveExtraRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
    if (has_dice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dice());
    }

    // required .User.RewardBagInfo reward = 2;
    if (has_reward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reward());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReceiveExtraRewardResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReceiveExtraRewardResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReceiveExtraRewardResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReceiveExtraRewardResp::MergeFrom(const ReceiveExtraRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dice()) {
      mutable_dice()->::ProtoShakeDice::ShakeDiceCPP::MergeFrom(from.dice());
    }
    if (from.has_reward()) {
      mutable_reward()->::User::RewardBagInfo::MergeFrom(from.reward());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReceiveExtraRewardResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReceiveExtraRewardResp::CopyFrom(const ReceiveExtraRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiveExtraRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_dice()) {
    if (!this->dice().IsInitialized()) return false;
  }
  if (has_reward()) {
    if (!this->reward().IsInitialized()) return false;
  }
  return true;
}

void ReceiveExtraRewardResp::Swap(ReceiveExtraRewardResp* other) {
  if (other != this) {
    std::swap(dice_, other->dice_);
    std::swap(reward_, other->reward_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReceiveExtraRewardResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReceiveExtraRewardResp_descriptor_;
  metadata.reflection = ReceiveExtraRewardResp_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoShakeDice

// @@protoc_insertion_point(global_scope)
