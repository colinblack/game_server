// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DataCommon.proto

#ifndef PROTOBUF_DataCommon_2eproto__INCLUDED
#define PROTOBUF_DataCommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DataCommon {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DataCommon_2eproto();
void protobuf_AssignDesc_DataCommon_2eproto();
void protobuf_ShutdownFile_DataCommon_2eproto();

class EquipShopCPP;
class EquipSubsCPP;
class EquipmentCPP;
class EquipmentAllCPP;
class RewardItemCPP;
class CommonBaseRewardCPP;
class UserResourceCPP;
class CostItemCPP;

// ===================================================================

class EquipShopCPP : public ::google::protobuf::Message {
 public:
  EquipShopCPP();
  virtual ~EquipShopCPP();

  EquipShopCPP(const EquipShopCPP& from);

  inline EquipShopCPP& operator=(const EquipShopCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipShopCPP& default_instance();

  void Swap(EquipShopCPP* other);

  // implements Message ----------------------------------------------

  EquipShopCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipShopCPP& from);
  void MergeFrom(const EquipShopCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 eqid = 1;
  inline bool has_eqid() const;
  inline void clear_eqid();
  static const int kEqidFieldNumber = 1;
  inline ::google::protobuf::uint32 eqid() const;
  inline void set_eqid(::google::protobuf::uint32 value);

  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // repeated uint32 subs = 3;
  inline int subs_size() const;
  inline void clear_subs();
  static const int kSubsFieldNumber = 3;
  inline ::google::protobuf::uint32 subs(int index) const;
  inline void set_subs(int index, ::google::protobuf::uint32 value);
  inline void add_subs(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      subs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_subs();

  // @@protoc_insertion_point(class_scope:DataCommon.EquipShopCPP)
 private:
  inline void set_has_eqid();
  inline void clear_has_eqid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 eqid_;
  bool status_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > subs_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static EquipShopCPP* default_instance_;
};
// -------------------------------------------------------------------

class EquipSubsCPP : public ::google::protobuf::Message {
 public:
  EquipSubsCPP();
  virtual ~EquipSubsCPP();

  EquipSubsCPP(const EquipSubsCPP& from);

  inline EquipSubsCPP& operator=(const EquipSubsCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipSubsCPP& default_instance();

  void Swap(EquipSubsCPP* other);

  // implements Message ----------------------------------------------

  EquipSubsCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipSubsCPP& from);
  void MergeFrom(const EquipSubsCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DataCommon.EquipSubsCPP)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 level_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static EquipSubsCPP* default_instance_;
};
// -------------------------------------------------------------------

class EquipmentCPP : public ::google::protobuf::Message {
 public:
  EquipmentCPP();
  virtual ~EquipmentCPP();

  EquipmentCPP(const EquipmentCPP& from);

  inline EquipmentCPP& operator=(const EquipmentCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipmentCPP& default_instance();

  void Swap(EquipmentCPP* other);

  // implements Message ----------------------------------------------

  EquipmentCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipmentCPP& from);
  void MergeFrom(const EquipmentCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 equd = 1;
  inline bool has_equd() const;
  inline void clear_equd();
  static const int kEqudFieldNumber = 1;
  inline ::google::protobuf::uint32 equd() const;
  inline void set_equd(::google::protobuf::uint32 value);

  // required uint32 eqid = 2;
  inline bool has_eqid() const;
  inline void clear_eqid();
  static const int kEqidFieldNumber = 2;
  inline ::google::protobuf::uint32 eqid() const;
  inline void set_eqid(::google::protobuf::uint32 value);

  // required uint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // required uint32 deltime = 4;
  inline bool has_deltime() const;
  inline void clear_deltime();
  static const int kDeltimeFieldNumber = 4;
  inline ::google::protobuf::uint32 deltime() const;
  inline void set_deltime(::google::protobuf::uint32 value);

  // required uint32 heroid = 5;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroidFieldNumber = 5;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // required uint32 star = 7;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 7;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // required bool issold = 8;
  inline bool has_issold() const;
  inline void clear_issold();
  static const int kIssoldFieldNumber = 8;
  inline bool issold() const;
  inline void set_issold(bool value);

  // repeated uint32 bornval = 9;
  inline int bornval_size() const;
  inline void clear_bornval();
  static const int kBornvalFieldNumber = 9;
  inline ::google::protobuf::uint32 bornval(int index) const;
  inline void set_bornval(int index, ::google::protobuf::uint32 value);
  inline void add_bornval(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      bornval() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_bornval();

  // repeated .DataCommon.EquipSubsCPP subs = 10;
  inline int subs_size() const;
  inline void clear_subs();
  static const int kSubsFieldNumber = 10;
  inline const ::DataCommon::EquipSubsCPP& subs(int index) const;
  inline ::DataCommon::EquipSubsCPP* mutable_subs(int index);
  inline ::DataCommon::EquipSubsCPP* add_subs();
  inline const ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipSubsCPP >&
      subs() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipSubsCPP >*
      mutable_subs();

  // @@protoc_insertion_point(class_scope:DataCommon.EquipmentCPP)
 private:
  inline void set_has_equd();
  inline void clear_has_equd();
  inline void set_has_eqid();
  inline void clear_has_eqid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_deltime();
  inline void clear_has_deltime();
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_issold();
  inline void clear_has_issold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 equd_;
  ::google::protobuf::uint32 eqid_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 deltime_;
  ::google::protobuf::uint32 heroid_;
  ::google::protobuf::uint32 star_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > bornval_;
  ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipSubsCPP > subs_;
  bool issold_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static EquipmentCPP* default_instance_;
};
// -------------------------------------------------------------------

class EquipmentAllCPP : public ::google::protobuf::Message {
 public:
  EquipmentAllCPP();
  virtual ~EquipmentAllCPP();

  EquipmentAllCPP(const EquipmentAllCPP& from);

  inline EquipmentAllCPP& operator=(const EquipmentAllCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipmentAllCPP& default_instance();

  void Swap(EquipmentAllCPP* other);

  // implements Message ----------------------------------------------

  EquipmentAllCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipmentAllCPP& from);
  void MergeFrom(const EquipmentAllCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DataCommon.EquipmentCPP equips = 1;
  inline int equips_size() const;
  inline void clear_equips();
  static const int kEquipsFieldNumber = 1;
  inline const ::DataCommon::EquipmentCPP& equips(int index) const;
  inline ::DataCommon::EquipmentCPP* mutable_equips(int index);
  inline ::DataCommon::EquipmentCPP* add_equips();
  inline const ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipmentCPP >&
      equips() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipmentCPP >*
      mutable_equips();

  // @@protoc_insertion_point(class_scope:DataCommon.EquipmentAllCPP)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipmentCPP > equips_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static EquipmentAllCPP* default_instance_;
};
// -------------------------------------------------------------------

class RewardItemCPP : public ::google::protobuf::Message {
 public:
  RewardItemCPP();
  virtual ~RewardItemCPP();

  RewardItemCPP(const RewardItemCPP& from);

  inline RewardItemCPP& operator=(const RewardItemCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardItemCPP& default_instance();

  void Swap(RewardItemCPP* other);

  // implements Message ----------------------------------------------

  RewardItemCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RewardItemCPP& from);
  void MergeFrom(const RewardItemCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // required uint64 total_value = 2;
  inline bool has_total_value() const;
  inline void clear_total_value();
  static const int kTotalValueFieldNumber = 2;
  inline ::google::protobuf::uint64 total_value() const;
  inline void set_total_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DataCommon.RewardItemCPP)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_total_value();
  inline void clear_has_total_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 total_value_;
  ::google::protobuf::uint32 value_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static RewardItemCPP* default_instance_;
};
// -------------------------------------------------------------------

class CommonBaseRewardCPP : public ::google::protobuf::Message {
 public:
  CommonBaseRewardCPP();
  virtual ~CommonBaseRewardCPP();

  CommonBaseRewardCPP(const CommonBaseRewardCPP& from);

  inline CommonBaseRewardCPP& operator=(const CommonBaseRewardCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonBaseRewardCPP& default_instance();

  void Swap(CommonBaseRewardCPP* other);

  // implements Message ----------------------------------------------

  CommonBaseRewardCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonBaseRewardCPP& from);
  void MergeFrom(const CommonBaseRewardCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DataCommon.RewardItemCPP food = 1;
  inline bool has_food() const;
  inline void clear_food();
  static const int kFoodFieldNumber = 1;
  inline const ::DataCommon::RewardItemCPP& food() const;
  inline ::DataCommon::RewardItemCPP* mutable_food();
  inline ::DataCommon::RewardItemCPP* release_food();
  inline void set_allocated_food(::DataCommon::RewardItemCPP* food);

  // optional .DataCommon.RewardItemCPP iron = 2;
  inline bool has_iron() const;
  inline void clear_iron();
  static const int kIronFieldNumber = 2;
  inline const ::DataCommon::RewardItemCPP& iron() const;
  inline ::DataCommon::RewardItemCPP* mutable_iron();
  inline ::DataCommon::RewardItemCPP* release_iron();
  inline void set_allocated_iron(::DataCommon::RewardItemCPP* iron);

  // optional .DataCommon.RewardItemCPP order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline const ::DataCommon::RewardItemCPP& order() const;
  inline ::DataCommon::RewardItemCPP* mutable_order();
  inline ::DataCommon::RewardItemCPP* release_order();
  inline void set_allocated_order(::DataCommon::RewardItemCPP* order);

  // optional .DataCommon.RewardItemCPP exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline const ::DataCommon::RewardItemCPP& exp() const;
  inline ::DataCommon::RewardItemCPP* mutable_exp();
  inline ::DataCommon::RewardItemCPP* release_exp();
  inline void set_allocated_exp(::DataCommon::RewardItemCPP* exp);

  // optional .DataCommon.RewardItemCPP coin = 5;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 5;
  inline const ::DataCommon::RewardItemCPP& coin() const;
  inline ::DataCommon::RewardItemCPP* mutable_coin();
  inline ::DataCommon::RewardItemCPP* release_coin();
  inline void set_allocated_coin(::DataCommon::RewardItemCPP* coin);

  // optional .DataCommon.RewardItemCPP wood = 6;
  inline bool has_wood() const;
  inline void clear_wood();
  static const int kWoodFieldNumber = 6;
  inline const ::DataCommon::RewardItemCPP& wood() const;
  inline ::DataCommon::RewardItemCPP* mutable_wood();
  inline ::DataCommon::RewardItemCPP* release_wood();
  inline void set_allocated_wood(::DataCommon::RewardItemCPP* wood);

  // optional .DataCommon.RewardItemCPP hammer = 7;
  inline bool has_hammer() const;
  inline void clear_hammer();
  static const int kHammerFieldNumber = 7;
  inline const ::DataCommon::RewardItemCPP& hammer() const;
  inline ::DataCommon::RewardItemCPP* mutable_hammer();
  inline ::DataCommon::RewardItemCPP* release_hammer();
  inline void set_allocated_hammer(::DataCommon::RewardItemCPP* hammer);

  // optional .DataCommon.RewardItemCPP cash = 8;
  inline bool has_cash() const;
  inline void clear_cash();
  static const int kCashFieldNumber = 8;
  inline const ::DataCommon::RewardItemCPP& cash() const;
  inline ::DataCommon::RewardItemCPP* mutable_cash();
  inline ::DataCommon::RewardItemCPP* release_cash();
  inline void set_allocated_cash(::DataCommon::RewardItemCPP* cash);

  // optional .DataCommon.RewardItemCPP refresh = 9;
  inline bool has_refresh() const;
  inline void clear_refresh();
  static const int kRefreshFieldNumber = 9;
  inline const ::DataCommon::RewardItemCPP& refresh() const;
  inline ::DataCommon::RewardItemCPP* mutable_refresh();
  inline ::DataCommon::RewardItemCPP* release_refresh();
  inline void set_allocated_refresh(::DataCommon::RewardItemCPP* refresh);

  // optional .DataCommon.RewardItemCPP arefresh = 10;
  inline bool has_arefresh() const;
  inline void clear_arefresh();
  static const int kArefreshFieldNumber = 10;
  inline const ::DataCommon::RewardItemCPP& arefresh() const;
  inline ::DataCommon::RewardItemCPP* mutable_arefresh();
  inline ::DataCommon::RewardItemCPP* release_arefresh();
  inline void set_allocated_arefresh(::DataCommon::RewardItemCPP* arefresh);

  // optional .DataCommon.RewardItemCPP sacrifice = 11;
  inline bool has_sacrifice() const;
  inline void clear_sacrifice();
  static const int kSacrificeFieldNumber = 11;
  inline const ::DataCommon::RewardItemCPP& sacrifice() const;
  inline ::DataCommon::RewardItemCPP* mutable_sacrifice();
  inline ::DataCommon::RewardItemCPP* release_sacrifice();
  inline void set_allocated_sacrifice(::DataCommon::RewardItemCPP* sacrifice);

  // optional .DataCommon.RewardItemCPP market = 12;
  inline bool has_market() const;
  inline void clear_market();
  static const int kMarketFieldNumber = 12;
  inline const ::DataCommon::RewardItemCPP& market() const;
  inline ::DataCommon::RewardItemCPP* mutable_market();
  inline ::DataCommon::RewardItemCPP* release_market();
  inline void set_allocated_market(::DataCommon::RewardItemCPP* market);

  // optional .DataCommon.RewardItemCPP shadow = 13;
  inline bool has_shadow() const;
  inline void clear_shadow();
  static const int kShadowFieldNumber = 13;
  inline const ::DataCommon::RewardItemCPP& shadow() const;
  inline ::DataCommon::RewardItemCPP* mutable_shadow();
  inline ::DataCommon::RewardItemCPP* release_shadow();
  inline void set_allocated_shadow(::DataCommon::RewardItemCPP* shadow);

  // @@protoc_insertion_point(class_scope:DataCommon.CommonBaseRewardCPP)
 private:
  inline void set_has_food();
  inline void clear_has_food();
  inline void set_has_iron();
  inline void clear_has_iron();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_wood();
  inline void clear_has_wood();
  inline void set_has_hammer();
  inline void clear_has_hammer();
  inline void set_has_cash();
  inline void clear_has_cash();
  inline void set_has_refresh();
  inline void clear_has_refresh();
  inline void set_has_arefresh();
  inline void clear_has_arefresh();
  inline void set_has_sacrifice();
  inline void clear_has_sacrifice();
  inline void set_has_market();
  inline void clear_has_market();
  inline void set_has_shadow();
  inline void clear_has_shadow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DataCommon::RewardItemCPP* food_;
  ::DataCommon::RewardItemCPP* iron_;
  ::DataCommon::RewardItemCPP* order_;
  ::DataCommon::RewardItemCPP* exp_;
  ::DataCommon::RewardItemCPP* coin_;
  ::DataCommon::RewardItemCPP* wood_;
  ::DataCommon::RewardItemCPP* hammer_;
  ::DataCommon::RewardItemCPP* cash_;
  ::DataCommon::RewardItemCPP* refresh_;
  ::DataCommon::RewardItemCPP* arefresh_;
  ::DataCommon::RewardItemCPP* sacrifice_;
  ::DataCommon::RewardItemCPP* market_;
  ::DataCommon::RewardItemCPP* shadow_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static CommonBaseRewardCPP* default_instance_;
};
// -------------------------------------------------------------------

class UserResourceCPP : public ::google::protobuf::Message {
 public:
  UserResourceCPP();
  virtual ~UserResourceCPP();

  UserResourceCPP(const UserResourceCPP& from);

  inline UserResourceCPP& operator=(const UserResourceCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserResourceCPP& default_instance();

  void Swap(UserResourceCPP* other);

  // implements Message ----------------------------------------------

  UserResourceCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserResourceCPP& from);
  void MergeFrom(const UserResourceCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 coin = 1;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 1;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // required uint32 wood = 2;
  inline bool has_wood() const;
  inline void clear_wood();
  static const int kWoodFieldNumber = 2;
  inline ::google::protobuf::uint32 wood() const;
  inline void set_wood(::google::protobuf::uint32 value);

  // required uint32 food = 3;
  inline bool has_food() const;
  inline void clear_food();
  static const int kFoodFieldNumber = 3;
  inline ::google::protobuf::uint32 food() const;
  inline void set_food(::google::protobuf::uint32 value);

  // required uint32 iron = 4;
  inline bool has_iron() const;
  inline void clear_iron();
  static const int kIronFieldNumber = 4;
  inline ::google::protobuf::uint32 iron() const;
  inline void set_iron(::google::protobuf::uint32 value);

  // optional uint32 cash = 5;
  inline bool has_cash() const;
  inline void clear_cash();
  static const int kCashFieldNumber = 5;
  inline ::google::protobuf::uint32 cash() const;
  inline void set_cash(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DataCommon.UserResourceCPP)
 private:
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_wood();
  inline void clear_has_wood();
  inline void set_has_food();
  inline void clear_has_food();
  inline void set_has_iron();
  inline void clear_has_iron();
  inline void set_has_cash();
  inline void clear_has_cash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 wood_;
  ::google::protobuf::uint32 food_;
  ::google::protobuf::uint32 iron_;
  ::google::protobuf::uint32 cash_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static UserResourceCPP* default_instance_;
};
// -------------------------------------------------------------------

class CostItemCPP : public ::google::protobuf::Message {
 public:
  CostItemCPP();
  virtual ~CostItemCPP();

  CostItemCPP(const CostItemCPP& from);

  inline CostItemCPP& operator=(const CostItemCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CostItemCPP& default_instance();

  void Swap(CostItemCPP* other);

  // implements Message ----------------------------------------------

  CostItemCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CostItemCPP& from);
  void MergeFrom(const CostItemCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // required uint64 total_value = 2;
  inline bool has_total_value() const;
  inline void clear_total_value();
  static const int kTotalValueFieldNumber = 2;
  inline ::google::protobuf::uint64 total_value() const;
  inline void set_total_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DataCommon.CostItemCPP)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_total_value();
  inline void clear_has_total_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 total_value_;
  ::google::protobuf::uint32 value_;
  friend void  protobuf_AddDesc_DataCommon_2eproto();
  friend void protobuf_AssignDesc_DataCommon_2eproto();
  friend void protobuf_ShutdownFile_DataCommon_2eproto();

  void InitAsDefaultInstance();
  static CostItemCPP* default_instance_;
};
// ===================================================================


// ===================================================================

// EquipShopCPP

// required uint32 eqid = 1;
inline bool EquipShopCPP::has_eqid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipShopCPP::set_has_eqid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipShopCPP::clear_has_eqid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipShopCPP::clear_eqid() {
  eqid_ = 0u;
  clear_has_eqid();
}
inline ::google::protobuf::uint32 EquipShopCPP::eqid() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipShopCPP.eqid)
  return eqid_;
}
inline void EquipShopCPP::set_eqid(::google::protobuf::uint32 value) {
  set_has_eqid();
  eqid_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipShopCPP.eqid)
}

// required bool status = 2;
inline bool EquipShopCPP::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipShopCPP::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipShopCPP::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipShopCPP::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool EquipShopCPP::status() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipShopCPP.status)
  return status_;
}
inline void EquipShopCPP::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipShopCPP.status)
}

// repeated uint32 subs = 3;
inline int EquipShopCPP::subs_size() const {
  return subs_.size();
}
inline void EquipShopCPP::clear_subs() {
  subs_.Clear();
}
inline ::google::protobuf::uint32 EquipShopCPP::subs(int index) const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipShopCPP.subs)
  return subs_.Get(index);
}
inline void EquipShopCPP::set_subs(int index, ::google::protobuf::uint32 value) {
  subs_.Set(index, value);
  // @@protoc_insertion_point(field_set:DataCommon.EquipShopCPP.subs)
}
inline void EquipShopCPP::add_subs(::google::protobuf::uint32 value) {
  subs_.Add(value);
  // @@protoc_insertion_point(field_add:DataCommon.EquipShopCPP.subs)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EquipShopCPP::subs() const {
  // @@protoc_insertion_point(field_list:DataCommon.EquipShopCPP.subs)
  return subs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EquipShopCPP::mutable_subs() {
  // @@protoc_insertion_point(field_mutable_list:DataCommon.EquipShopCPP.subs)
  return &subs_;
}

// -------------------------------------------------------------------

// EquipSubsCPP

// required uint32 type = 1;
inline bool EquipSubsCPP::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipSubsCPP::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipSubsCPP::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipSubsCPP::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 EquipSubsCPP::type() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipSubsCPP.type)
  return type_;
}
inline void EquipSubsCPP::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipSubsCPP.type)
}

// required uint32 level = 2;
inline bool EquipSubsCPP::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipSubsCPP::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipSubsCPP::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipSubsCPP::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 EquipSubsCPP::level() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipSubsCPP.level)
  return level_;
}
inline void EquipSubsCPP::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipSubsCPP.level)
}

// -------------------------------------------------------------------

// EquipmentCPP

// required uint32 equd = 1;
inline bool EquipmentCPP::has_equd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipmentCPP::set_has_equd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipmentCPP::clear_has_equd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipmentCPP::clear_equd() {
  equd_ = 0u;
  clear_has_equd();
}
inline ::google::protobuf::uint32 EquipmentCPP::equd() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.equd)
  return equd_;
}
inline void EquipmentCPP::set_equd(::google::protobuf::uint32 value) {
  set_has_equd();
  equd_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.equd)
}

// required uint32 eqid = 2;
inline bool EquipmentCPP::has_eqid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipmentCPP::set_has_eqid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipmentCPP::clear_has_eqid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipmentCPP::clear_eqid() {
  eqid_ = 0u;
  clear_has_eqid();
}
inline ::google::protobuf::uint32 EquipmentCPP::eqid() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.eqid)
  return eqid_;
}
inline void EquipmentCPP::set_eqid(::google::protobuf::uint32 value) {
  set_has_eqid();
  eqid_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.eqid)
}

// required uint32 num = 3;
inline bool EquipmentCPP::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EquipmentCPP::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EquipmentCPP::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EquipmentCPP::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 EquipmentCPP::num() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.num)
  return num_;
}
inline void EquipmentCPP::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.num)
}

// required uint32 deltime = 4;
inline bool EquipmentCPP::has_deltime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EquipmentCPP::set_has_deltime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EquipmentCPP::clear_has_deltime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EquipmentCPP::clear_deltime() {
  deltime_ = 0u;
  clear_has_deltime();
}
inline ::google::protobuf::uint32 EquipmentCPP::deltime() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.deltime)
  return deltime_;
}
inline void EquipmentCPP::set_deltime(::google::protobuf::uint32 value) {
  set_has_deltime();
  deltime_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.deltime)
}

// required uint32 heroid = 5;
inline bool EquipmentCPP::has_heroid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EquipmentCPP::set_has_heroid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EquipmentCPP::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EquipmentCPP::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 EquipmentCPP::heroid() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.heroid)
  return heroid_;
}
inline void EquipmentCPP::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.heroid)
}

// required uint32 star = 7;
inline bool EquipmentCPP::has_star() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EquipmentCPP::set_has_star() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EquipmentCPP::clear_has_star() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EquipmentCPP::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 EquipmentCPP::star() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.star)
  return star_;
}
inline void EquipmentCPP::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.star)
}

// required bool issold = 8;
inline bool EquipmentCPP::has_issold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EquipmentCPP::set_has_issold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EquipmentCPP::clear_has_issold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EquipmentCPP::clear_issold() {
  issold_ = false;
  clear_has_issold();
}
inline bool EquipmentCPP::issold() const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.issold)
  return issold_;
}
inline void EquipmentCPP::set_issold(bool value) {
  set_has_issold();
  issold_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.issold)
}

// repeated uint32 bornval = 9;
inline int EquipmentCPP::bornval_size() const {
  return bornval_.size();
}
inline void EquipmentCPP::clear_bornval() {
  bornval_.Clear();
}
inline ::google::protobuf::uint32 EquipmentCPP::bornval(int index) const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.bornval)
  return bornval_.Get(index);
}
inline void EquipmentCPP::set_bornval(int index, ::google::protobuf::uint32 value) {
  bornval_.Set(index, value);
  // @@protoc_insertion_point(field_set:DataCommon.EquipmentCPP.bornval)
}
inline void EquipmentCPP::add_bornval(::google::protobuf::uint32 value) {
  bornval_.Add(value);
  // @@protoc_insertion_point(field_add:DataCommon.EquipmentCPP.bornval)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EquipmentCPP::bornval() const {
  // @@protoc_insertion_point(field_list:DataCommon.EquipmentCPP.bornval)
  return bornval_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EquipmentCPP::mutable_bornval() {
  // @@protoc_insertion_point(field_mutable_list:DataCommon.EquipmentCPP.bornval)
  return &bornval_;
}

// repeated .DataCommon.EquipSubsCPP subs = 10;
inline int EquipmentCPP::subs_size() const {
  return subs_.size();
}
inline void EquipmentCPP::clear_subs() {
  subs_.Clear();
}
inline const ::DataCommon::EquipSubsCPP& EquipmentCPP::subs(int index) const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentCPP.subs)
  return subs_.Get(index);
}
inline ::DataCommon::EquipSubsCPP* EquipmentCPP::mutable_subs(int index) {
  // @@protoc_insertion_point(field_mutable:DataCommon.EquipmentCPP.subs)
  return subs_.Mutable(index);
}
inline ::DataCommon::EquipSubsCPP* EquipmentCPP::add_subs() {
  // @@protoc_insertion_point(field_add:DataCommon.EquipmentCPP.subs)
  return subs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipSubsCPP >&
EquipmentCPP::subs() const {
  // @@protoc_insertion_point(field_list:DataCommon.EquipmentCPP.subs)
  return subs_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipSubsCPP >*
EquipmentCPP::mutable_subs() {
  // @@protoc_insertion_point(field_mutable_list:DataCommon.EquipmentCPP.subs)
  return &subs_;
}

// -------------------------------------------------------------------

// EquipmentAllCPP

// repeated .DataCommon.EquipmentCPP equips = 1;
inline int EquipmentAllCPP::equips_size() const {
  return equips_.size();
}
inline void EquipmentAllCPP::clear_equips() {
  equips_.Clear();
}
inline const ::DataCommon::EquipmentCPP& EquipmentAllCPP::equips(int index) const {
  // @@protoc_insertion_point(field_get:DataCommon.EquipmentAllCPP.equips)
  return equips_.Get(index);
}
inline ::DataCommon::EquipmentCPP* EquipmentAllCPP::mutable_equips(int index) {
  // @@protoc_insertion_point(field_mutable:DataCommon.EquipmentAllCPP.equips)
  return equips_.Mutable(index);
}
inline ::DataCommon::EquipmentCPP* EquipmentAllCPP::add_equips() {
  // @@protoc_insertion_point(field_add:DataCommon.EquipmentAllCPP.equips)
  return equips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipmentCPP >&
EquipmentAllCPP::equips() const {
  // @@protoc_insertion_point(field_list:DataCommon.EquipmentAllCPP.equips)
  return equips_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataCommon::EquipmentCPP >*
EquipmentAllCPP::mutable_equips() {
  // @@protoc_insertion_point(field_mutable_list:DataCommon.EquipmentAllCPP.equips)
  return &equips_;
}

// -------------------------------------------------------------------

// RewardItemCPP

// required uint32 value = 1;
inline bool RewardItemCPP::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardItemCPP::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardItemCPP::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardItemCPP::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 RewardItemCPP::value() const {
  // @@protoc_insertion_point(field_get:DataCommon.RewardItemCPP.value)
  return value_;
}
inline void RewardItemCPP::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.RewardItemCPP.value)
}

// required uint64 total_value = 2;
inline bool RewardItemCPP::has_total_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardItemCPP::set_has_total_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardItemCPP::clear_has_total_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardItemCPP::clear_total_value() {
  total_value_ = GOOGLE_ULONGLONG(0);
  clear_has_total_value();
}
inline ::google::protobuf::uint64 RewardItemCPP::total_value() const {
  // @@protoc_insertion_point(field_get:DataCommon.RewardItemCPP.total_value)
  return total_value_;
}
inline void RewardItemCPP::set_total_value(::google::protobuf::uint64 value) {
  set_has_total_value();
  total_value_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.RewardItemCPP.total_value)
}

// -------------------------------------------------------------------

// CommonBaseRewardCPP

// optional .DataCommon.RewardItemCPP food = 1;
inline bool CommonBaseRewardCPP::has_food() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonBaseRewardCPP::set_has_food() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonBaseRewardCPP::clear_has_food() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonBaseRewardCPP::clear_food() {
  if (food_ != NULL) food_->::DataCommon::RewardItemCPP::Clear();
  clear_has_food();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::food() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.food)
  return food_ != NULL ? *food_ : *default_instance_->food_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_food() {
  set_has_food();
  if (food_ == NULL) food_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.food)
  return food_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_food() {
  clear_has_food();
  ::DataCommon::RewardItemCPP* temp = food_;
  food_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_food(::DataCommon::RewardItemCPP* food) {
  delete food_;
  food_ = food;
  if (food) {
    set_has_food();
  } else {
    clear_has_food();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.food)
}

// optional .DataCommon.RewardItemCPP iron = 2;
inline bool CommonBaseRewardCPP::has_iron() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonBaseRewardCPP::set_has_iron() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonBaseRewardCPP::clear_has_iron() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonBaseRewardCPP::clear_iron() {
  if (iron_ != NULL) iron_->::DataCommon::RewardItemCPP::Clear();
  clear_has_iron();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::iron() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.iron)
  return iron_ != NULL ? *iron_ : *default_instance_->iron_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_iron() {
  set_has_iron();
  if (iron_ == NULL) iron_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.iron)
  return iron_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_iron() {
  clear_has_iron();
  ::DataCommon::RewardItemCPP* temp = iron_;
  iron_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_iron(::DataCommon::RewardItemCPP* iron) {
  delete iron_;
  iron_ = iron;
  if (iron) {
    set_has_iron();
  } else {
    clear_has_iron();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.iron)
}

// optional .DataCommon.RewardItemCPP order = 3;
inline bool CommonBaseRewardCPP::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonBaseRewardCPP::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonBaseRewardCPP::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonBaseRewardCPP::clear_order() {
  if (order_ != NULL) order_->::DataCommon::RewardItemCPP::Clear();
  clear_has_order();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::order() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.order)
  return order_ != NULL ? *order_ : *default_instance_->order_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_order() {
  set_has_order();
  if (order_ == NULL) order_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.order)
  return order_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_order() {
  clear_has_order();
  ::DataCommon::RewardItemCPP* temp = order_;
  order_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_order(::DataCommon::RewardItemCPP* order) {
  delete order_;
  order_ = order;
  if (order) {
    set_has_order();
  } else {
    clear_has_order();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.order)
}

// optional .DataCommon.RewardItemCPP exp = 4;
inline bool CommonBaseRewardCPP::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonBaseRewardCPP::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonBaseRewardCPP::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonBaseRewardCPP::clear_exp() {
  if (exp_ != NULL) exp_->::DataCommon::RewardItemCPP::Clear();
  clear_has_exp();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::exp() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.exp)
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.exp)
  return exp_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_exp() {
  clear_has_exp();
  ::DataCommon::RewardItemCPP* temp = exp_;
  exp_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_exp(::DataCommon::RewardItemCPP* exp) {
  delete exp_;
  exp_ = exp;
  if (exp) {
    set_has_exp();
  } else {
    clear_has_exp();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.exp)
}

// optional .DataCommon.RewardItemCPP coin = 5;
inline bool CommonBaseRewardCPP::has_coin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonBaseRewardCPP::set_has_coin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonBaseRewardCPP::clear_has_coin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonBaseRewardCPP::clear_coin() {
  if (coin_ != NULL) coin_->::DataCommon::RewardItemCPP::Clear();
  clear_has_coin();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::coin() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.coin)
  return coin_ != NULL ? *coin_ : *default_instance_->coin_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_coin() {
  set_has_coin();
  if (coin_ == NULL) coin_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.coin)
  return coin_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_coin() {
  clear_has_coin();
  ::DataCommon::RewardItemCPP* temp = coin_;
  coin_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_coin(::DataCommon::RewardItemCPP* coin) {
  delete coin_;
  coin_ = coin;
  if (coin) {
    set_has_coin();
  } else {
    clear_has_coin();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.coin)
}

// optional .DataCommon.RewardItemCPP wood = 6;
inline bool CommonBaseRewardCPP::has_wood() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonBaseRewardCPP::set_has_wood() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonBaseRewardCPP::clear_has_wood() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonBaseRewardCPP::clear_wood() {
  if (wood_ != NULL) wood_->::DataCommon::RewardItemCPP::Clear();
  clear_has_wood();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::wood() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.wood)
  return wood_ != NULL ? *wood_ : *default_instance_->wood_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_wood() {
  set_has_wood();
  if (wood_ == NULL) wood_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.wood)
  return wood_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_wood() {
  clear_has_wood();
  ::DataCommon::RewardItemCPP* temp = wood_;
  wood_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_wood(::DataCommon::RewardItemCPP* wood) {
  delete wood_;
  wood_ = wood;
  if (wood) {
    set_has_wood();
  } else {
    clear_has_wood();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.wood)
}

// optional .DataCommon.RewardItemCPP hammer = 7;
inline bool CommonBaseRewardCPP::has_hammer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonBaseRewardCPP::set_has_hammer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonBaseRewardCPP::clear_has_hammer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonBaseRewardCPP::clear_hammer() {
  if (hammer_ != NULL) hammer_->::DataCommon::RewardItemCPP::Clear();
  clear_has_hammer();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::hammer() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.hammer)
  return hammer_ != NULL ? *hammer_ : *default_instance_->hammer_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_hammer() {
  set_has_hammer();
  if (hammer_ == NULL) hammer_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.hammer)
  return hammer_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_hammer() {
  clear_has_hammer();
  ::DataCommon::RewardItemCPP* temp = hammer_;
  hammer_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_hammer(::DataCommon::RewardItemCPP* hammer) {
  delete hammer_;
  hammer_ = hammer;
  if (hammer) {
    set_has_hammer();
  } else {
    clear_has_hammer();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.hammer)
}

// optional .DataCommon.RewardItemCPP cash = 8;
inline bool CommonBaseRewardCPP::has_cash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonBaseRewardCPP::set_has_cash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonBaseRewardCPP::clear_has_cash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonBaseRewardCPP::clear_cash() {
  if (cash_ != NULL) cash_->::DataCommon::RewardItemCPP::Clear();
  clear_has_cash();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::cash() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.cash)
  return cash_ != NULL ? *cash_ : *default_instance_->cash_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_cash() {
  set_has_cash();
  if (cash_ == NULL) cash_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.cash)
  return cash_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_cash() {
  clear_has_cash();
  ::DataCommon::RewardItemCPP* temp = cash_;
  cash_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_cash(::DataCommon::RewardItemCPP* cash) {
  delete cash_;
  cash_ = cash;
  if (cash) {
    set_has_cash();
  } else {
    clear_has_cash();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.cash)
}

// optional .DataCommon.RewardItemCPP refresh = 9;
inline bool CommonBaseRewardCPP::has_refresh() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonBaseRewardCPP::set_has_refresh() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonBaseRewardCPP::clear_has_refresh() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonBaseRewardCPP::clear_refresh() {
  if (refresh_ != NULL) refresh_->::DataCommon::RewardItemCPP::Clear();
  clear_has_refresh();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::refresh() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.refresh)
  return refresh_ != NULL ? *refresh_ : *default_instance_->refresh_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_refresh() {
  set_has_refresh();
  if (refresh_ == NULL) refresh_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.refresh)
  return refresh_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_refresh() {
  clear_has_refresh();
  ::DataCommon::RewardItemCPP* temp = refresh_;
  refresh_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_refresh(::DataCommon::RewardItemCPP* refresh) {
  delete refresh_;
  refresh_ = refresh;
  if (refresh) {
    set_has_refresh();
  } else {
    clear_has_refresh();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.refresh)
}

// optional .DataCommon.RewardItemCPP arefresh = 10;
inline bool CommonBaseRewardCPP::has_arefresh() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonBaseRewardCPP::set_has_arefresh() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonBaseRewardCPP::clear_has_arefresh() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonBaseRewardCPP::clear_arefresh() {
  if (arefresh_ != NULL) arefresh_->::DataCommon::RewardItemCPP::Clear();
  clear_has_arefresh();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::arefresh() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.arefresh)
  return arefresh_ != NULL ? *arefresh_ : *default_instance_->arefresh_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_arefresh() {
  set_has_arefresh();
  if (arefresh_ == NULL) arefresh_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.arefresh)
  return arefresh_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_arefresh() {
  clear_has_arefresh();
  ::DataCommon::RewardItemCPP* temp = arefresh_;
  arefresh_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_arefresh(::DataCommon::RewardItemCPP* arefresh) {
  delete arefresh_;
  arefresh_ = arefresh;
  if (arefresh) {
    set_has_arefresh();
  } else {
    clear_has_arefresh();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.arefresh)
}

// optional .DataCommon.RewardItemCPP sacrifice = 11;
inline bool CommonBaseRewardCPP::has_sacrifice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommonBaseRewardCPP::set_has_sacrifice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommonBaseRewardCPP::clear_has_sacrifice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommonBaseRewardCPP::clear_sacrifice() {
  if (sacrifice_ != NULL) sacrifice_->::DataCommon::RewardItemCPP::Clear();
  clear_has_sacrifice();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::sacrifice() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.sacrifice)
  return sacrifice_ != NULL ? *sacrifice_ : *default_instance_->sacrifice_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_sacrifice() {
  set_has_sacrifice();
  if (sacrifice_ == NULL) sacrifice_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.sacrifice)
  return sacrifice_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_sacrifice() {
  clear_has_sacrifice();
  ::DataCommon::RewardItemCPP* temp = sacrifice_;
  sacrifice_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_sacrifice(::DataCommon::RewardItemCPP* sacrifice) {
  delete sacrifice_;
  sacrifice_ = sacrifice;
  if (sacrifice) {
    set_has_sacrifice();
  } else {
    clear_has_sacrifice();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.sacrifice)
}

// optional .DataCommon.RewardItemCPP market = 12;
inline bool CommonBaseRewardCPP::has_market() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommonBaseRewardCPP::set_has_market() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommonBaseRewardCPP::clear_has_market() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommonBaseRewardCPP::clear_market() {
  if (market_ != NULL) market_->::DataCommon::RewardItemCPP::Clear();
  clear_has_market();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::market() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.market)
  return market_ != NULL ? *market_ : *default_instance_->market_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_market() {
  set_has_market();
  if (market_ == NULL) market_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.market)
  return market_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_market() {
  clear_has_market();
  ::DataCommon::RewardItemCPP* temp = market_;
  market_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_market(::DataCommon::RewardItemCPP* market) {
  delete market_;
  market_ = market;
  if (market) {
    set_has_market();
  } else {
    clear_has_market();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.market)
}

// optional .DataCommon.RewardItemCPP shadow = 13;
inline bool CommonBaseRewardCPP::has_shadow() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommonBaseRewardCPP::set_has_shadow() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommonBaseRewardCPP::clear_has_shadow() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommonBaseRewardCPP::clear_shadow() {
  if (shadow_ != NULL) shadow_->::DataCommon::RewardItemCPP::Clear();
  clear_has_shadow();
}
inline const ::DataCommon::RewardItemCPP& CommonBaseRewardCPP::shadow() const {
  // @@protoc_insertion_point(field_get:DataCommon.CommonBaseRewardCPP.shadow)
  return shadow_ != NULL ? *shadow_ : *default_instance_->shadow_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::mutable_shadow() {
  set_has_shadow();
  if (shadow_ == NULL) shadow_ = new ::DataCommon::RewardItemCPP;
  // @@protoc_insertion_point(field_mutable:DataCommon.CommonBaseRewardCPP.shadow)
  return shadow_;
}
inline ::DataCommon::RewardItemCPP* CommonBaseRewardCPP::release_shadow() {
  clear_has_shadow();
  ::DataCommon::RewardItemCPP* temp = shadow_;
  shadow_ = NULL;
  return temp;
}
inline void CommonBaseRewardCPP::set_allocated_shadow(::DataCommon::RewardItemCPP* shadow) {
  delete shadow_;
  shadow_ = shadow;
  if (shadow) {
    set_has_shadow();
  } else {
    clear_has_shadow();
  }
  // @@protoc_insertion_point(field_set_allocated:DataCommon.CommonBaseRewardCPP.shadow)
}

// -------------------------------------------------------------------

// UserResourceCPP

// required uint32 coin = 1;
inline bool UserResourceCPP::has_coin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserResourceCPP::set_has_coin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserResourceCPP::clear_has_coin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserResourceCPP::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 UserResourceCPP::coin() const {
  // @@protoc_insertion_point(field_get:DataCommon.UserResourceCPP.coin)
  return coin_;
}
inline void UserResourceCPP::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.UserResourceCPP.coin)
}

// required uint32 wood = 2;
inline bool UserResourceCPP::has_wood() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserResourceCPP::set_has_wood() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserResourceCPP::clear_has_wood() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserResourceCPP::clear_wood() {
  wood_ = 0u;
  clear_has_wood();
}
inline ::google::protobuf::uint32 UserResourceCPP::wood() const {
  // @@protoc_insertion_point(field_get:DataCommon.UserResourceCPP.wood)
  return wood_;
}
inline void UserResourceCPP::set_wood(::google::protobuf::uint32 value) {
  set_has_wood();
  wood_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.UserResourceCPP.wood)
}

// required uint32 food = 3;
inline bool UserResourceCPP::has_food() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserResourceCPP::set_has_food() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserResourceCPP::clear_has_food() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserResourceCPP::clear_food() {
  food_ = 0u;
  clear_has_food();
}
inline ::google::protobuf::uint32 UserResourceCPP::food() const {
  // @@protoc_insertion_point(field_get:DataCommon.UserResourceCPP.food)
  return food_;
}
inline void UserResourceCPP::set_food(::google::protobuf::uint32 value) {
  set_has_food();
  food_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.UserResourceCPP.food)
}

// required uint32 iron = 4;
inline bool UserResourceCPP::has_iron() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserResourceCPP::set_has_iron() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserResourceCPP::clear_has_iron() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserResourceCPP::clear_iron() {
  iron_ = 0u;
  clear_has_iron();
}
inline ::google::protobuf::uint32 UserResourceCPP::iron() const {
  // @@protoc_insertion_point(field_get:DataCommon.UserResourceCPP.iron)
  return iron_;
}
inline void UserResourceCPP::set_iron(::google::protobuf::uint32 value) {
  set_has_iron();
  iron_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.UserResourceCPP.iron)
}

// optional uint32 cash = 5;
inline bool UserResourceCPP::has_cash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserResourceCPP::set_has_cash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserResourceCPP::clear_has_cash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserResourceCPP::clear_cash() {
  cash_ = 0u;
  clear_has_cash();
}
inline ::google::protobuf::uint32 UserResourceCPP::cash() const {
  // @@protoc_insertion_point(field_get:DataCommon.UserResourceCPP.cash)
  return cash_;
}
inline void UserResourceCPP::set_cash(::google::protobuf::uint32 value) {
  set_has_cash();
  cash_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.UserResourceCPP.cash)
}

// -------------------------------------------------------------------

// CostItemCPP

// required uint32 value = 1;
inline bool CostItemCPP::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CostItemCPP::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CostItemCPP::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CostItemCPP::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 CostItemCPP::value() const {
  // @@protoc_insertion_point(field_get:DataCommon.CostItemCPP.value)
  return value_;
}
inline void CostItemCPP::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.CostItemCPP.value)
}

// required uint64 total_value = 2;
inline bool CostItemCPP::has_total_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CostItemCPP::set_has_total_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CostItemCPP::clear_has_total_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CostItemCPP::clear_total_value() {
  total_value_ = GOOGLE_ULONGLONG(0);
  clear_has_total_value();
}
inline ::google::protobuf::uint64 CostItemCPP::total_value() const {
  // @@protoc_insertion_point(field_get:DataCommon.CostItemCPP.total_value)
  return total_value_;
}
inline void CostItemCPP::set_total_value(::google::protobuf::uint64 value) {
  set_has_total_value();
  total_value_ = value;
  // @@protoc_insertion_point(field_set:DataCommon.CostItemCPP.total_value)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DataCommon

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DataCommon_2eproto__INCLUDED
