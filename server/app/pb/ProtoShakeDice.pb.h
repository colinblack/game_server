// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoShakeDice.proto

#ifndef PROTOBUF_ProtoShakeDice_2eproto__INCLUDED
#define PROTOBUF_ProtoShakeDice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "User.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoShakeDice {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoShakeDice_2eproto();
void protobuf_AssignDesc_ProtoShakeDice_2eproto();
void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

class ShakeDiceCPP;
class OpenShakeDiceWindowReq;
class OpenShakeDiceWindowResp;
class RollDiceReq;
class RollDiceResp;
class ResetMapReq;
class ResetMapResp;
class EnterMapReq;
class EnterMapResp;
class UnlockMapReq;
class UnlockMapResp;
class PositionRewardReq;
class PositionRewardResp;
class ReceiveExtraRewardReq;
class ReceiveExtraRewardResp;

// ===================================================================

class ShakeDiceCPP : public ::google::protobuf::Message {
 public:
  ShakeDiceCPP();
  virtual ~ShakeDiceCPP();

  ShakeDiceCPP(const ShakeDiceCPP& from);

  inline ShakeDiceCPP& operator=(const ShakeDiceCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShakeDiceCPP& default_instance();

  void Swap(ShakeDiceCPP* other);

  // implements Message ----------------------------------------------

  ShakeDiceCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShakeDiceCPP& from);
  void MergeFrom(const ShakeDiceCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required uint32 curmap = 2;
  inline bool has_curmap() const;
  inline void clear_curmap();
  static const int kCurmapFieldNumber = 2;
  inline ::google::protobuf::uint32 curmap() const;
  inline void set_curmap(::google::protobuf::uint32 value);

  // required uint32 map1_status = 3;
  inline bool has_map1_status() const;
  inline void clear_map1_status();
  static const int kMap1StatusFieldNumber = 3;
  inline ::google::protobuf::uint32 map1_status() const;
  inline void set_map1_status(::google::protobuf::uint32 value);

  // required uint32 map2_status = 4;
  inline bool has_map2_status() const;
  inline void clear_map2_status();
  static const int kMap2StatusFieldNumber = 4;
  inline ::google::protobuf::uint32 map2_status() const;
  inline void set_map2_status(::google::protobuf::uint32 value);

  // required uint32 map3_status = 5;
  inline bool has_map3_status() const;
  inline void clear_map3_status();
  static const int kMap3StatusFieldNumber = 5;
  inline ::google::protobuf::uint32 map3_status() const;
  inline void set_map3_status(::google::protobuf::uint32 value);

  // required uint32 dice_times = 6;
  inline bool has_dice_times() const;
  inline void clear_dice_times();
  static const int kDiceTimesFieldNumber = 6;
  inline ::google::protobuf::uint32 dice_times() const;
  inline void set_dice_times(::google::protobuf::uint32 value);

  // required uint32 reset_times = 7;
  inline bool has_reset_times() const;
  inline void clear_reset_times();
  static const int kResetTimesFieldNumber = 7;
  inline ::google::protobuf::uint32 reset_times() const;
  inline void set_reset_times(::google::protobuf::uint32 value);

  // required uint32 steps = 8;
  inline bool has_steps() const;
  inline void clear_steps();
  static const int kStepsFieldNumber = 8;
  inline ::google::protobuf::uint32 steps() const;
  inline void set_steps(::google::protobuf::uint32 value);

  // required uint32 operate_ts = 9;
  inline bool has_operate_ts() const;
  inline void clear_operate_ts();
  static const int kOperateTsFieldNumber = 9;
  inline ::google::protobuf::uint32 operate_ts() const;
  inline void set_operate_ts(::google::protobuf::uint32 value);

  // required uint32 extra_reward_status = 10;
  inline bool has_extra_reward_status() const;
  inline void clear_extra_reward_status();
  static const int kExtraRewardStatusFieldNumber = 10;
  inline ::google::protobuf::uint32 extra_reward_status() const;
  inline void set_extra_reward_status(::google::protobuf::uint32 value);

  // required uint32 map1_rewards = 11;
  inline bool has_map1_rewards() const;
  inline void clear_map1_rewards();
  static const int kMap1RewardsFieldNumber = 11;
  inline ::google::protobuf::uint32 map1_rewards() const;
  inline void set_map1_rewards(::google::protobuf::uint32 value);

  // required uint32 map2_rewards = 12;
  inline bool has_map2_rewards() const;
  inline void clear_map2_rewards();
  static const int kMap2RewardsFieldNumber = 12;
  inline ::google::protobuf::uint32 map2_rewards() const;
  inline void set_map2_rewards(::google::protobuf::uint32 value);

  // required uint32 map3_rewards = 13;
  inline bool has_map3_rewards() const;
  inline void clear_map3_rewards();
  static const int kMap3RewardsFieldNumber = 13;
  inline ::google::protobuf::uint32 map3_rewards() const;
  inline void set_map3_rewards(::google::protobuf::uint32 value);

  // required uint32 curpos = 14;
  inline bool has_curpos() const;
  inline void clear_curpos();
  static const int kCurposFieldNumber = 14;
  inline ::google::protobuf::uint32 curpos() const;
  inline void set_curpos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.ShakeDiceCPP)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_curmap();
  inline void clear_has_curmap();
  inline void set_has_map1_status();
  inline void clear_has_map1_status();
  inline void set_has_map2_status();
  inline void clear_has_map2_status();
  inline void set_has_map3_status();
  inline void clear_has_map3_status();
  inline void set_has_dice_times();
  inline void clear_has_dice_times();
  inline void set_has_reset_times();
  inline void clear_has_reset_times();
  inline void set_has_steps();
  inline void clear_has_steps();
  inline void set_has_operate_ts();
  inline void clear_has_operate_ts();
  inline void set_has_extra_reward_status();
  inline void clear_has_extra_reward_status();
  inline void set_has_map1_rewards();
  inline void clear_has_map1_rewards();
  inline void set_has_map2_rewards();
  inline void clear_has_map2_rewards();
  inline void set_has_map3_rewards();
  inline void clear_has_map3_rewards();
  inline void set_has_curpos();
  inline void clear_has_curpos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 curmap_;
  ::google::protobuf::uint32 map1_status_;
  ::google::protobuf::uint32 map2_status_;
  ::google::protobuf::uint32 map3_status_;
  ::google::protobuf::uint32 dice_times_;
  ::google::protobuf::uint32 reset_times_;
  ::google::protobuf::uint32 steps_;
  ::google::protobuf::uint32 operate_ts_;
  ::google::protobuf::uint32 extra_reward_status_;
  ::google::protobuf::uint32 map1_rewards_;
  ::google::protobuf::uint32 map2_rewards_;
  ::google::protobuf::uint32 map3_rewards_;
  ::google::protobuf::uint32 curpos_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static ShakeDiceCPP* default_instance_;
};
// -------------------------------------------------------------------

class OpenShakeDiceWindowReq : public ::google::protobuf::Message {
 public:
  OpenShakeDiceWindowReq();
  virtual ~OpenShakeDiceWindowReq();

  OpenShakeDiceWindowReq(const OpenShakeDiceWindowReq& from);

  inline OpenShakeDiceWindowReq& operator=(const OpenShakeDiceWindowReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenShakeDiceWindowReq& default_instance();

  void Swap(OpenShakeDiceWindowReq* other);

  // implements Message ----------------------------------------------

  OpenShakeDiceWindowReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenShakeDiceWindowReq& from);
  void MergeFrom(const OpenShakeDiceWindowReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.OpenShakeDiceWindowReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static OpenShakeDiceWindowReq* default_instance_;
};
// -------------------------------------------------------------------

class OpenShakeDiceWindowResp : public ::google::protobuf::Message {
 public:
  OpenShakeDiceWindowResp();
  virtual ~OpenShakeDiceWindowResp();

  OpenShakeDiceWindowResp(const OpenShakeDiceWindowResp& from);

  inline OpenShakeDiceWindowResp& operator=(const OpenShakeDiceWindowResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenShakeDiceWindowResp& default_instance();

  void Swap(OpenShakeDiceWindowResp* other);

  // implements Message ----------------------------------------------

  OpenShakeDiceWindowResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenShakeDiceWindowResp& from);
  void MergeFrom(const OpenShakeDiceWindowResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.OpenShakeDiceWindowResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static OpenShakeDiceWindowResp* default_instance_;
};
// -------------------------------------------------------------------

class RollDiceReq : public ::google::protobuf::Message {
 public:
  RollDiceReq();
  virtual ~RollDiceReq();

  RollDiceReq(const RollDiceReq& from);

  inline RollDiceReq& operator=(const RollDiceReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RollDiceReq& default_instance();

  void Swap(RollDiceReq* other);

  // implements Message ----------------------------------------------

  RollDiceReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RollDiceReq& from);
  void MergeFrom(const RollDiceReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.RollDiceReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static RollDiceReq* default_instance_;
};
// -------------------------------------------------------------------

class RollDiceResp : public ::google::protobuf::Message {
 public:
  RollDiceResp();
  virtual ~RollDiceResp();

  RollDiceResp(const RollDiceResp& from);

  inline RollDiceResp& operator=(const RollDiceResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RollDiceResp& default_instance();

  void Swap(RollDiceResp* other);

  // implements Message ----------------------------------------------

  RollDiceResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RollDiceResp& from);
  void MergeFrom(const RollDiceResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // required uint32 cash = 2;
  inline bool has_cash() const;
  inline void clear_cash();
  static const int kCashFieldNumber = 2;
  inline ::google::protobuf::uint32 cash() const;
  inline void set_cash(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.RollDiceResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();
  inline void set_has_cash();
  inline void clear_has_cash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  ::google::protobuf::uint32 cash_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static RollDiceResp* default_instance_;
};
// -------------------------------------------------------------------

class ResetMapReq : public ::google::protobuf::Message {
 public:
  ResetMapReq();
  virtual ~ResetMapReq();

  ResetMapReq(const ResetMapReq& from);

  inline ResetMapReq& operator=(const ResetMapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetMapReq& default_instance();

  void Swap(ResetMapReq* other);

  // implements Message ----------------------------------------------

  ResetMapReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetMapReq& from);
  void MergeFrom(const ResetMapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.ResetMapReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static ResetMapReq* default_instance_;
};
// -------------------------------------------------------------------

class ResetMapResp : public ::google::protobuf::Message {
 public:
  ResetMapResp();
  virtual ~ResetMapResp();

  ResetMapResp(const ResetMapResp& from);

  inline ResetMapResp& operator=(const ResetMapResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetMapResp& default_instance();

  void Swap(ResetMapResp* other);

  // implements Message ----------------------------------------------

  ResetMapResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetMapResp& from);
  void MergeFrom(const ResetMapResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // required uint32 cash = 2;
  inline bool has_cash() const;
  inline void clear_cash();
  static const int kCashFieldNumber = 2;
  inline ::google::protobuf::uint32 cash() const;
  inline void set_cash(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.ResetMapResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();
  inline void set_has_cash();
  inline void clear_has_cash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  ::google::protobuf::uint32 cash_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static ResetMapResp* default_instance_;
};
// -------------------------------------------------------------------

class EnterMapReq : public ::google::protobuf::Message {
 public:
  EnterMapReq();
  virtual ~EnterMapReq();

  EnterMapReq(const EnterMapReq& from);

  inline EnterMapReq& operator=(const EnterMapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterMapReq& default_instance();

  void Swap(EnterMapReq* other);

  // implements Message ----------------------------------------------

  EnterMapReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterMapReq& from);
  void MergeFrom(const EnterMapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mapid = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 1;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.EnterMapReq)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 mapid_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static EnterMapReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterMapResp : public ::google::protobuf::Message {
 public:
  EnterMapResp();
  virtual ~EnterMapResp();

  EnterMapResp(const EnterMapResp& from);

  inline EnterMapResp& operator=(const EnterMapResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterMapResp& default_instance();

  void Swap(EnterMapResp* other);

  // implements Message ----------------------------------------------

  EnterMapResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterMapResp& from);
  void MergeFrom(const EnterMapResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.EnterMapResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static EnterMapResp* default_instance_;
};
// -------------------------------------------------------------------

class UnlockMapReq : public ::google::protobuf::Message {
 public:
  UnlockMapReq();
  virtual ~UnlockMapReq();

  UnlockMapReq(const UnlockMapReq& from);

  inline UnlockMapReq& operator=(const UnlockMapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockMapReq& default_instance();

  void Swap(UnlockMapReq* other);

  // implements Message ----------------------------------------------

  UnlockMapReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnlockMapReq& from);
  void MergeFrom(const UnlockMapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mapid = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 1;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.UnlockMapReq)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 mapid_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static UnlockMapReq* default_instance_;
};
// -------------------------------------------------------------------

class UnlockMapResp : public ::google::protobuf::Message {
 public:
  UnlockMapResp();
  virtual ~UnlockMapResp();

  UnlockMapResp(const UnlockMapResp& from);

  inline UnlockMapResp& operator=(const UnlockMapResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockMapResp& default_instance();

  void Swap(UnlockMapResp* other);

  // implements Message ----------------------------------------------

  UnlockMapResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnlockMapResp& from);
  void MergeFrom(const UnlockMapResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.UnlockMapResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static UnlockMapResp* default_instance_;
};
// -------------------------------------------------------------------

class PositionRewardReq : public ::google::protobuf::Message {
 public:
  PositionRewardReq();
  virtual ~PositionRewardReq();

  PositionRewardReq(const PositionRewardReq& from);

  inline PositionRewardReq& operator=(const PositionRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionRewardReq& default_instance();

  void Swap(PositionRewardReq* other);

  // implements Message ----------------------------------------------

  PositionRewardReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionRewardReq& from);
  void MergeFrom(const PositionRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 pids = 1;
  inline int pids_size() const;
  inline void clear_pids();
  static const int kPidsFieldNumber = 1;
  inline ::google::protobuf::uint32 pids(int index) const;
  inline void set_pids(int index, ::google::protobuf::uint32 value);
  inline void add_pids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pids();

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.PositionRewardReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pids_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static PositionRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class PositionRewardResp : public ::google::protobuf::Message {
 public:
  PositionRewardResp();
  virtual ~PositionRewardResp();

  PositionRewardResp(const PositionRewardResp& from);

  inline PositionRewardResp& operator=(const PositionRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionRewardResp& default_instance();

  void Swap(PositionRewardResp* other);

  // implements Message ----------------------------------------------

  PositionRewardResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionRewardResp& from);
  void MergeFrom(const PositionRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // required .User.RewardBagInfo reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::User::RewardBagInfo& reward() const;
  inline ::User::RewardBagInfo* mutable_reward();
  inline ::User::RewardBagInfo* release_reward();
  inline void set_allocated_reward(::User::RewardBagInfo* reward);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.PositionRewardResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  ::User::RewardBagInfo* reward_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static PositionRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveExtraRewardReq : public ::google::protobuf::Message {
 public:
  ReceiveExtraRewardReq();
  virtual ~ReceiveExtraRewardReq();

  ReceiveExtraRewardReq(const ReceiveExtraRewardReq& from);

  inline ReceiveExtraRewardReq& operator=(const ReceiveExtraRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveExtraRewardReq& default_instance();

  void Swap(ReceiveExtraRewardReq* other);

  // implements Message ----------------------------------------------

  ReceiveExtraRewardReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveExtraRewardReq& from);
  void MergeFrom(const ReceiveExtraRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.ReceiveExtraRewardReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static ReceiveExtraRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveExtraRewardResp : public ::google::protobuf::Message {
 public:
  ReceiveExtraRewardResp();
  virtual ~ReceiveExtraRewardResp();

  ReceiveExtraRewardResp(const ReceiveExtraRewardResp& from);

  inline ReceiveExtraRewardResp& operator=(const ReceiveExtraRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveExtraRewardResp& default_instance();

  void Swap(ReceiveExtraRewardResp* other);

  // implements Message ----------------------------------------------

  ReceiveExtraRewardResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveExtraRewardResp& from);
  void MergeFrom(const ReceiveExtraRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoShakeDice.ShakeDiceCPP dice = 1;
  inline bool has_dice() const;
  inline void clear_dice();
  static const int kDiceFieldNumber = 1;
  inline const ::ProtoShakeDice::ShakeDiceCPP& dice() const;
  inline ::ProtoShakeDice::ShakeDiceCPP* mutable_dice();
  inline ::ProtoShakeDice::ShakeDiceCPP* release_dice();
  inline void set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice);

  // required .User.RewardBagInfo reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::User::RewardBagInfo& reward() const;
  inline ::User::RewardBagInfo* mutable_reward();
  inline ::User::RewardBagInfo* release_reward();
  inline void set_allocated_reward(::User::RewardBagInfo* reward);

  // @@protoc_insertion_point(class_scope:ProtoShakeDice.ReceiveExtraRewardResp)
 private:
  inline void set_has_dice();
  inline void clear_has_dice();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoShakeDice::ShakeDiceCPP* dice_;
  ::User::RewardBagInfo* reward_;
  friend void  protobuf_AddDesc_ProtoShakeDice_2eproto();
  friend void protobuf_AssignDesc_ProtoShakeDice_2eproto();
  friend void protobuf_ShutdownFile_ProtoShakeDice_2eproto();

  void InitAsDefaultInstance();
  static ReceiveExtraRewardResp* default_instance_;
};
// ===================================================================


// ===================================================================

// ShakeDiceCPP

// required uint32 version = 1;
inline bool ShakeDiceCPP::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShakeDiceCPP::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShakeDiceCPP::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShakeDiceCPP::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::version() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.version)
  return version_;
}
inline void ShakeDiceCPP::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.version)
}

// required uint32 curmap = 2;
inline bool ShakeDiceCPP::has_curmap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShakeDiceCPP::set_has_curmap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShakeDiceCPP::clear_has_curmap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShakeDiceCPP::clear_curmap() {
  curmap_ = 0u;
  clear_has_curmap();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::curmap() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.curmap)
  return curmap_;
}
inline void ShakeDiceCPP::set_curmap(::google::protobuf::uint32 value) {
  set_has_curmap();
  curmap_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.curmap)
}

// required uint32 map1_status = 3;
inline bool ShakeDiceCPP::has_map1_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShakeDiceCPP::set_has_map1_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShakeDiceCPP::clear_has_map1_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShakeDiceCPP::clear_map1_status() {
  map1_status_ = 0u;
  clear_has_map1_status();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::map1_status() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.map1_status)
  return map1_status_;
}
inline void ShakeDiceCPP::set_map1_status(::google::protobuf::uint32 value) {
  set_has_map1_status();
  map1_status_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.map1_status)
}

// required uint32 map2_status = 4;
inline bool ShakeDiceCPP::has_map2_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShakeDiceCPP::set_has_map2_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShakeDiceCPP::clear_has_map2_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShakeDiceCPP::clear_map2_status() {
  map2_status_ = 0u;
  clear_has_map2_status();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::map2_status() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.map2_status)
  return map2_status_;
}
inline void ShakeDiceCPP::set_map2_status(::google::protobuf::uint32 value) {
  set_has_map2_status();
  map2_status_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.map2_status)
}

// required uint32 map3_status = 5;
inline bool ShakeDiceCPP::has_map3_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShakeDiceCPP::set_has_map3_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShakeDiceCPP::clear_has_map3_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShakeDiceCPP::clear_map3_status() {
  map3_status_ = 0u;
  clear_has_map3_status();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::map3_status() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.map3_status)
  return map3_status_;
}
inline void ShakeDiceCPP::set_map3_status(::google::protobuf::uint32 value) {
  set_has_map3_status();
  map3_status_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.map3_status)
}

// required uint32 dice_times = 6;
inline bool ShakeDiceCPP::has_dice_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShakeDiceCPP::set_has_dice_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShakeDiceCPP::clear_has_dice_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShakeDiceCPP::clear_dice_times() {
  dice_times_ = 0u;
  clear_has_dice_times();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::dice_times() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.dice_times)
  return dice_times_;
}
inline void ShakeDiceCPP::set_dice_times(::google::protobuf::uint32 value) {
  set_has_dice_times();
  dice_times_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.dice_times)
}

// required uint32 reset_times = 7;
inline bool ShakeDiceCPP::has_reset_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShakeDiceCPP::set_has_reset_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShakeDiceCPP::clear_has_reset_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShakeDiceCPP::clear_reset_times() {
  reset_times_ = 0u;
  clear_has_reset_times();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::reset_times() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.reset_times)
  return reset_times_;
}
inline void ShakeDiceCPP::set_reset_times(::google::protobuf::uint32 value) {
  set_has_reset_times();
  reset_times_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.reset_times)
}

// required uint32 steps = 8;
inline bool ShakeDiceCPP::has_steps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShakeDiceCPP::set_has_steps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShakeDiceCPP::clear_has_steps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShakeDiceCPP::clear_steps() {
  steps_ = 0u;
  clear_has_steps();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::steps() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.steps)
  return steps_;
}
inline void ShakeDiceCPP::set_steps(::google::protobuf::uint32 value) {
  set_has_steps();
  steps_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.steps)
}

// required uint32 operate_ts = 9;
inline bool ShakeDiceCPP::has_operate_ts() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ShakeDiceCPP::set_has_operate_ts() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ShakeDiceCPP::clear_has_operate_ts() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ShakeDiceCPP::clear_operate_ts() {
  operate_ts_ = 0u;
  clear_has_operate_ts();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::operate_ts() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.operate_ts)
  return operate_ts_;
}
inline void ShakeDiceCPP::set_operate_ts(::google::protobuf::uint32 value) {
  set_has_operate_ts();
  operate_ts_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.operate_ts)
}

// required uint32 extra_reward_status = 10;
inline bool ShakeDiceCPP::has_extra_reward_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ShakeDiceCPP::set_has_extra_reward_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ShakeDiceCPP::clear_has_extra_reward_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ShakeDiceCPP::clear_extra_reward_status() {
  extra_reward_status_ = 0u;
  clear_has_extra_reward_status();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::extra_reward_status() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.extra_reward_status)
  return extra_reward_status_;
}
inline void ShakeDiceCPP::set_extra_reward_status(::google::protobuf::uint32 value) {
  set_has_extra_reward_status();
  extra_reward_status_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.extra_reward_status)
}

// required uint32 map1_rewards = 11;
inline bool ShakeDiceCPP::has_map1_rewards() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ShakeDiceCPP::set_has_map1_rewards() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ShakeDiceCPP::clear_has_map1_rewards() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ShakeDiceCPP::clear_map1_rewards() {
  map1_rewards_ = 0u;
  clear_has_map1_rewards();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::map1_rewards() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.map1_rewards)
  return map1_rewards_;
}
inline void ShakeDiceCPP::set_map1_rewards(::google::protobuf::uint32 value) {
  set_has_map1_rewards();
  map1_rewards_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.map1_rewards)
}

// required uint32 map2_rewards = 12;
inline bool ShakeDiceCPP::has_map2_rewards() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ShakeDiceCPP::set_has_map2_rewards() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ShakeDiceCPP::clear_has_map2_rewards() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ShakeDiceCPP::clear_map2_rewards() {
  map2_rewards_ = 0u;
  clear_has_map2_rewards();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::map2_rewards() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.map2_rewards)
  return map2_rewards_;
}
inline void ShakeDiceCPP::set_map2_rewards(::google::protobuf::uint32 value) {
  set_has_map2_rewards();
  map2_rewards_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.map2_rewards)
}

// required uint32 map3_rewards = 13;
inline bool ShakeDiceCPP::has_map3_rewards() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ShakeDiceCPP::set_has_map3_rewards() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ShakeDiceCPP::clear_has_map3_rewards() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ShakeDiceCPP::clear_map3_rewards() {
  map3_rewards_ = 0u;
  clear_has_map3_rewards();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::map3_rewards() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.map3_rewards)
  return map3_rewards_;
}
inline void ShakeDiceCPP::set_map3_rewards(::google::protobuf::uint32 value) {
  set_has_map3_rewards();
  map3_rewards_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.map3_rewards)
}

// required uint32 curpos = 14;
inline bool ShakeDiceCPP::has_curpos() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ShakeDiceCPP::set_has_curpos() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ShakeDiceCPP::clear_has_curpos() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ShakeDiceCPP::clear_curpos() {
  curpos_ = 0u;
  clear_has_curpos();
}
inline ::google::protobuf::uint32 ShakeDiceCPP::curpos() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ShakeDiceCPP.curpos)
  return curpos_;
}
inline void ShakeDiceCPP::set_curpos(::google::protobuf::uint32 value) {
  set_has_curpos();
  curpos_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ShakeDiceCPP.curpos)
}

// -------------------------------------------------------------------

// OpenShakeDiceWindowReq

// -------------------------------------------------------------------

// OpenShakeDiceWindowResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool OpenShakeDiceWindowResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenShakeDiceWindowResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenShakeDiceWindowResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenShakeDiceWindowResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& OpenShakeDiceWindowResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.OpenShakeDiceWindowResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* OpenShakeDiceWindowResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.OpenShakeDiceWindowResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* OpenShakeDiceWindowResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void OpenShakeDiceWindowResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.OpenShakeDiceWindowResp.dice)
}

// -------------------------------------------------------------------

// RollDiceReq

// -------------------------------------------------------------------

// RollDiceResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool RollDiceResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RollDiceResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RollDiceResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RollDiceResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& RollDiceResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.RollDiceResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* RollDiceResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.RollDiceResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* RollDiceResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void RollDiceResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.RollDiceResp.dice)
}

// required uint32 cash = 2;
inline bool RollDiceResp::has_cash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RollDiceResp::set_has_cash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RollDiceResp::clear_has_cash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RollDiceResp::clear_cash() {
  cash_ = 0u;
  clear_has_cash();
}
inline ::google::protobuf::uint32 RollDiceResp::cash() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.RollDiceResp.cash)
  return cash_;
}
inline void RollDiceResp::set_cash(::google::protobuf::uint32 value) {
  set_has_cash();
  cash_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.RollDiceResp.cash)
}

// -------------------------------------------------------------------

// ResetMapReq

// -------------------------------------------------------------------

// ResetMapResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool ResetMapResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetMapResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetMapResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetMapResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& ResetMapResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ResetMapResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* ResetMapResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.ResetMapResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* ResetMapResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void ResetMapResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.ResetMapResp.dice)
}

// required uint32 cash = 2;
inline bool ResetMapResp::has_cash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetMapResp::set_has_cash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetMapResp::clear_has_cash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetMapResp::clear_cash() {
  cash_ = 0u;
  clear_has_cash();
}
inline ::google::protobuf::uint32 ResetMapResp::cash() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ResetMapResp.cash)
  return cash_;
}
inline void ResetMapResp::set_cash(::google::protobuf::uint32 value) {
  set_has_cash();
  cash_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.ResetMapResp.cash)
}

// -------------------------------------------------------------------

// EnterMapReq

// required uint32 mapid = 1;
inline bool EnterMapReq::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterMapReq::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterMapReq::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterMapReq::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 EnterMapReq::mapid() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.EnterMapReq.mapid)
  return mapid_;
}
inline void EnterMapReq::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.EnterMapReq.mapid)
}

// -------------------------------------------------------------------

// EnterMapResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool EnterMapResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterMapResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterMapResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterMapResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& EnterMapResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.EnterMapResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* EnterMapResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.EnterMapResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* EnterMapResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void EnterMapResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.EnterMapResp.dice)
}

// -------------------------------------------------------------------

// UnlockMapReq

// required uint32 mapid = 1;
inline bool UnlockMapReq::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockMapReq::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockMapReq::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockMapReq::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 UnlockMapReq::mapid() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.UnlockMapReq.mapid)
  return mapid_;
}
inline void UnlockMapReq::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
  // @@protoc_insertion_point(field_set:ProtoShakeDice.UnlockMapReq.mapid)
}

// -------------------------------------------------------------------

// UnlockMapResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool UnlockMapResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockMapResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockMapResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockMapResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& UnlockMapResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.UnlockMapResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* UnlockMapResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.UnlockMapResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* UnlockMapResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void UnlockMapResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.UnlockMapResp.dice)
}

// -------------------------------------------------------------------

// PositionRewardReq

// repeated uint32 pids = 1;
inline int PositionRewardReq::pids_size() const {
  return pids_.size();
}
inline void PositionRewardReq::clear_pids() {
  pids_.Clear();
}
inline ::google::protobuf::uint32 PositionRewardReq::pids(int index) const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.PositionRewardReq.pids)
  return pids_.Get(index);
}
inline void PositionRewardReq::set_pids(int index, ::google::protobuf::uint32 value) {
  pids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ProtoShakeDice.PositionRewardReq.pids)
}
inline void PositionRewardReq::add_pids(::google::protobuf::uint32 value) {
  pids_.Add(value);
  // @@protoc_insertion_point(field_add:ProtoShakeDice.PositionRewardReq.pids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PositionRewardReq::pids() const {
  // @@protoc_insertion_point(field_list:ProtoShakeDice.PositionRewardReq.pids)
  return pids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PositionRewardReq::mutable_pids() {
  // @@protoc_insertion_point(field_mutable_list:ProtoShakeDice.PositionRewardReq.pids)
  return &pids_;
}

// -------------------------------------------------------------------

// PositionRewardResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool PositionRewardResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionRewardResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionRewardResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionRewardResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& PositionRewardResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.PositionRewardResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* PositionRewardResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.PositionRewardResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* PositionRewardResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void PositionRewardResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.PositionRewardResp.dice)
}

// required .User.RewardBagInfo reward = 2;
inline bool PositionRewardResp::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionRewardResp::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionRewardResp::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionRewardResp::clear_reward() {
  if (reward_ != NULL) reward_->::User::RewardBagInfo::Clear();
  clear_has_reward();
}
inline const ::User::RewardBagInfo& PositionRewardResp::reward() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.PositionRewardResp.reward)
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::User::RewardBagInfo* PositionRewardResp::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::User::RewardBagInfo;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.PositionRewardResp.reward)
  return reward_;
}
inline ::User::RewardBagInfo* PositionRewardResp::release_reward() {
  clear_has_reward();
  ::User::RewardBagInfo* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline void PositionRewardResp::set_allocated_reward(::User::RewardBagInfo* reward) {
  delete reward_;
  reward_ = reward;
  if (reward) {
    set_has_reward();
  } else {
    clear_has_reward();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.PositionRewardResp.reward)
}

// -------------------------------------------------------------------

// ReceiveExtraRewardReq

// -------------------------------------------------------------------

// ReceiveExtraRewardResp

// required .ProtoShakeDice.ShakeDiceCPP dice = 1;
inline bool ReceiveExtraRewardResp::has_dice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiveExtraRewardResp::set_has_dice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiveExtraRewardResp::clear_has_dice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiveExtraRewardResp::clear_dice() {
  if (dice_ != NULL) dice_->::ProtoShakeDice::ShakeDiceCPP::Clear();
  clear_has_dice();
}
inline const ::ProtoShakeDice::ShakeDiceCPP& ReceiveExtraRewardResp::dice() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ReceiveExtraRewardResp.dice)
  return dice_ != NULL ? *dice_ : *default_instance_->dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* ReceiveExtraRewardResp::mutable_dice() {
  set_has_dice();
  if (dice_ == NULL) dice_ = new ::ProtoShakeDice::ShakeDiceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.ReceiveExtraRewardResp.dice)
  return dice_;
}
inline ::ProtoShakeDice::ShakeDiceCPP* ReceiveExtraRewardResp::release_dice() {
  clear_has_dice();
  ::ProtoShakeDice::ShakeDiceCPP* temp = dice_;
  dice_ = NULL;
  return temp;
}
inline void ReceiveExtraRewardResp::set_allocated_dice(::ProtoShakeDice::ShakeDiceCPP* dice) {
  delete dice_;
  dice_ = dice;
  if (dice) {
    set_has_dice();
  } else {
    clear_has_dice();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.ReceiveExtraRewardResp.dice)
}

// required .User.RewardBagInfo reward = 2;
inline bool ReceiveExtraRewardResp::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiveExtraRewardResp::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiveExtraRewardResp::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiveExtraRewardResp::clear_reward() {
  if (reward_ != NULL) reward_->::User::RewardBagInfo::Clear();
  clear_has_reward();
}
inline const ::User::RewardBagInfo& ReceiveExtraRewardResp::reward() const {
  // @@protoc_insertion_point(field_get:ProtoShakeDice.ReceiveExtraRewardResp.reward)
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::User::RewardBagInfo* ReceiveExtraRewardResp::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::User::RewardBagInfo;
  // @@protoc_insertion_point(field_mutable:ProtoShakeDice.ReceiveExtraRewardResp.reward)
  return reward_;
}
inline ::User::RewardBagInfo* ReceiveExtraRewardResp::release_reward() {
  clear_has_reward();
  ::User::RewardBagInfo* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline void ReceiveExtraRewardResp::set_allocated_reward(::User::RewardBagInfo* reward) {
  delete reward_;
  reward_ = reward;
  if (reward) {
    set_has_reward();
  } else {
    clear_has_reward();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoShakeDice.ReceiveExtraRewardResp.reward)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoShakeDice

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoShakeDice_2eproto__INCLUDED
