// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoWeapon.proto

#ifndef PROTOBUF_ProtoWeapon_2eproto__INCLUDED
#define PROTOBUF_ProtoWeapon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "DataCommon.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoWeapon {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoWeapon_2eproto();
void protobuf_AssignDesc_ProtoWeapon_2eproto();
void protobuf_ShutdownFile_ProtoWeapon_2eproto();

class WeaponInfoCPP;
class WeaponUnlockReq;
class WeaponUnlockResp;
class WeaponCastReq;
class WeaponCastResp;

// ===================================================================

class WeaponInfoCPP : public ::google::protobuf::Message {
 public:
  WeaponInfoCPP();
  virtual ~WeaponInfoCPP();

  WeaponInfoCPP(const WeaponInfoCPP& from);

  inline WeaponInfoCPP& operator=(const WeaponInfoCPP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponInfoCPP& default_instance();

  void Swap(WeaponInfoCPP* other);

  // implements Message ----------------------------------------------

  WeaponInfoCPP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponInfoCPP& from);
  void MergeFrom(const WeaponInfoCPP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 cast = 3;
  inline bool has_cast() const;
  inline void clear_cast();
  static const int kCastFieldNumber = 3;
  inline ::google::protobuf::uint32 cast() const;
  inline void set_cast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoWeapon.WeaponInfoCPP)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_cast();
  inline void clear_has_cast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 cast_;
  friend void  protobuf_AddDesc_ProtoWeapon_2eproto();
  friend void protobuf_AssignDesc_ProtoWeapon_2eproto();
  friend void protobuf_ShutdownFile_ProtoWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponInfoCPP* default_instance_;
};
// -------------------------------------------------------------------

class WeaponUnlockReq : public ::google::protobuf::Message {
 public:
  WeaponUnlockReq();
  virtual ~WeaponUnlockReq();

  WeaponUnlockReq(const WeaponUnlockReq& from);

  inline WeaponUnlockReq& operator=(const WeaponUnlockReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponUnlockReq& default_instance();

  void Swap(WeaponUnlockReq* other);

  // implements Message ----------------------------------------------

  WeaponUnlockReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponUnlockReq& from);
  void MergeFrom(const WeaponUnlockReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoWeapon.WeaponUnlockReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_ProtoWeapon_2eproto();
  friend void protobuf_AssignDesc_ProtoWeapon_2eproto();
  friend void protobuf_ShutdownFile_ProtoWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponUnlockReq* default_instance_;
};
// -------------------------------------------------------------------

class WeaponUnlockResp : public ::google::protobuf::Message {
 public:
  WeaponUnlockResp();
  virtual ~WeaponUnlockResp();

  WeaponUnlockResp(const WeaponUnlockResp& from);

  inline WeaponUnlockResp& operator=(const WeaponUnlockResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponUnlockResp& default_instance();

  void Swap(WeaponUnlockResp* other);

  // implements Message ----------------------------------------------

  WeaponUnlockResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponUnlockResp& from);
  void MergeFrom(const WeaponUnlockResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoWeapon.WeaponInfoCPP item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::ProtoWeapon::WeaponInfoCPP& item() const;
  inline ::ProtoWeapon::WeaponInfoCPP* mutable_item();
  inline ::ProtoWeapon::WeaponInfoCPP* release_item();
  inline void set_allocated_item(::ProtoWeapon::WeaponInfoCPP* item);

  // required .DataCommon.UserResourceCPP resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::DataCommon::UserResourceCPP& resource() const;
  inline ::DataCommon::UserResourceCPP* mutable_resource();
  inline ::DataCommon::UserResourceCPP* release_resource();
  inline void set_allocated_resource(::DataCommon::UserResourceCPP* resource);

  // @@protoc_insertion_point(class_scope:ProtoWeapon.WeaponUnlockResp)
 private:
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoWeapon::WeaponInfoCPP* item_;
  ::DataCommon::UserResourceCPP* resource_;
  friend void  protobuf_AddDesc_ProtoWeapon_2eproto();
  friend void protobuf_AssignDesc_ProtoWeapon_2eproto();
  friend void protobuf_ShutdownFile_ProtoWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponUnlockResp* default_instance_;
};
// -------------------------------------------------------------------

class WeaponCastReq : public ::google::protobuf::Message {
 public:
  WeaponCastReq();
  virtual ~WeaponCastReq();

  WeaponCastReq(const WeaponCastReq& from);

  inline WeaponCastReq& operator=(const WeaponCastReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponCastReq& default_instance();

  void Swap(WeaponCastReq* other);

  // implements Message ----------------------------------------------

  WeaponCastReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponCastReq& from);
  void MergeFrom(const WeaponCastReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ProtoWeapon.WeaponCastReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_ProtoWeapon_2eproto();
  friend void protobuf_AssignDesc_ProtoWeapon_2eproto();
  friend void protobuf_ShutdownFile_ProtoWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponCastReq* default_instance_;
};
// -------------------------------------------------------------------

class WeaponCastResp : public ::google::protobuf::Message {
 public:
  WeaponCastResp();
  virtual ~WeaponCastResp();

  WeaponCastResp(const WeaponCastResp& from);

  inline WeaponCastResp& operator=(const WeaponCastResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponCastResp& default_instance();

  void Swap(WeaponCastResp* other);

  // implements Message ----------------------------------------------

  WeaponCastResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponCastResp& from);
  void MergeFrom(const WeaponCastResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoWeapon.WeaponInfoCPP item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::ProtoWeapon::WeaponInfoCPP& item() const;
  inline ::ProtoWeapon::WeaponInfoCPP* mutable_item();
  inline ::ProtoWeapon::WeaponInfoCPP* release_item();
  inline void set_allocated_item(::ProtoWeapon::WeaponInfoCPP* item);

  // required uint32 multiple = 2;
  inline bool has_multiple() const;
  inline void clear_multiple();
  static const int kMultipleFieldNumber = 2;
  inline ::google::protobuf::uint32 multiple() const;
  inline void set_multiple(::google::protobuf::uint32 value);

  // required .DataCommon.UserResourceCPP resource = 3;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 3;
  inline const ::DataCommon::UserResourceCPP& resource() const;
  inline ::DataCommon::UserResourceCPP* mutable_resource();
  inline ::DataCommon::UserResourceCPP* release_resource();
  inline void set_allocated_resource(::DataCommon::UserResourceCPP* resource);

  // @@protoc_insertion_point(class_scope:ProtoWeapon.WeaponCastResp)
 private:
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_multiple();
  inline void clear_has_multiple();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ProtoWeapon::WeaponInfoCPP* item_;
  ::DataCommon::UserResourceCPP* resource_;
  ::google::protobuf::uint32 multiple_;
  friend void  protobuf_AddDesc_ProtoWeapon_2eproto();
  friend void protobuf_AssignDesc_ProtoWeapon_2eproto();
  friend void protobuf_ShutdownFile_ProtoWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponCastResp* default_instance_;
};
// ===================================================================


// ===================================================================

// WeaponInfoCPP

// required uint32 id = 1;
inline bool WeaponInfoCPP::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponInfoCPP::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponInfoCPP::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponInfoCPP::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 WeaponInfoCPP::id() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponInfoCPP.id)
  return id_;
}
inline void WeaponInfoCPP::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ProtoWeapon.WeaponInfoCPP.id)
}

// required uint32 level = 2;
inline bool WeaponInfoCPP::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponInfoCPP::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponInfoCPP::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponInfoCPP::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 WeaponInfoCPP::level() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponInfoCPP.level)
  return level_;
}
inline void WeaponInfoCPP::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:ProtoWeapon.WeaponInfoCPP.level)
}

// required uint32 cast = 3;
inline bool WeaponInfoCPP::has_cast() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponInfoCPP::set_has_cast() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponInfoCPP::clear_has_cast() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponInfoCPP::clear_cast() {
  cast_ = 0u;
  clear_has_cast();
}
inline ::google::protobuf::uint32 WeaponInfoCPP::cast() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponInfoCPP.cast)
  return cast_;
}
inline void WeaponInfoCPP::set_cast(::google::protobuf::uint32 value) {
  set_has_cast();
  cast_ = value;
  // @@protoc_insertion_point(field_set:ProtoWeapon.WeaponInfoCPP.cast)
}

// -------------------------------------------------------------------

// WeaponUnlockReq

// required uint32 id = 1;
inline bool WeaponUnlockReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponUnlockReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponUnlockReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponUnlockReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 WeaponUnlockReq::id() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponUnlockReq.id)
  return id_;
}
inline void WeaponUnlockReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ProtoWeapon.WeaponUnlockReq.id)
}

// -------------------------------------------------------------------

// WeaponUnlockResp

// required .ProtoWeapon.WeaponInfoCPP item = 1;
inline bool WeaponUnlockResp::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponUnlockResp::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponUnlockResp::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponUnlockResp::clear_item() {
  if (item_ != NULL) item_->::ProtoWeapon::WeaponInfoCPP::Clear();
  clear_has_item();
}
inline const ::ProtoWeapon::WeaponInfoCPP& WeaponUnlockResp::item() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponUnlockResp.item)
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::ProtoWeapon::WeaponInfoCPP* WeaponUnlockResp::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ProtoWeapon::WeaponInfoCPP;
  // @@protoc_insertion_point(field_mutable:ProtoWeapon.WeaponUnlockResp.item)
  return item_;
}
inline ::ProtoWeapon::WeaponInfoCPP* WeaponUnlockResp::release_item() {
  clear_has_item();
  ::ProtoWeapon::WeaponInfoCPP* temp = item_;
  item_ = NULL;
  return temp;
}
inline void WeaponUnlockResp::set_allocated_item(::ProtoWeapon::WeaponInfoCPP* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoWeapon.WeaponUnlockResp.item)
}

// required .DataCommon.UserResourceCPP resource = 2;
inline bool WeaponUnlockResp::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponUnlockResp::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponUnlockResp::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponUnlockResp::clear_resource() {
  if (resource_ != NULL) resource_->::DataCommon::UserResourceCPP::Clear();
  clear_has_resource();
}
inline const ::DataCommon::UserResourceCPP& WeaponUnlockResp::resource() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponUnlockResp.resource)
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::DataCommon::UserResourceCPP* WeaponUnlockResp::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::DataCommon::UserResourceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoWeapon.WeaponUnlockResp.resource)
  return resource_;
}
inline ::DataCommon::UserResourceCPP* WeaponUnlockResp::release_resource() {
  clear_has_resource();
  ::DataCommon::UserResourceCPP* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void WeaponUnlockResp::set_allocated_resource(::DataCommon::UserResourceCPP* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoWeapon.WeaponUnlockResp.resource)
}

// -------------------------------------------------------------------

// WeaponCastReq

// required uint32 id = 1;
inline bool WeaponCastReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponCastReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponCastReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponCastReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 WeaponCastReq::id() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponCastReq.id)
  return id_;
}
inline void WeaponCastReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ProtoWeapon.WeaponCastReq.id)
}

// -------------------------------------------------------------------

// WeaponCastResp

// required .ProtoWeapon.WeaponInfoCPP item = 1;
inline bool WeaponCastResp::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponCastResp::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponCastResp::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponCastResp::clear_item() {
  if (item_ != NULL) item_->::ProtoWeapon::WeaponInfoCPP::Clear();
  clear_has_item();
}
inline const ::ProtoWeapon::WeaponInfoCPP& WeaponCastResp::item() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponCastResp.item)
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::ProtoWeapon::WeaponInfoCPP* WeaponCastResp::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ProtoWeapon::WeaponInfoCPP;
  // @@protoc_insertion_point(field_mutable:ProtoWeapon.WeaponCastResp.item)
  return item_;
}
inline ::ProtoWeapon::WeaponInfoCPP* WeaponCastResp::release_item() {
  clear_has_item();
  ::ProtoWeapon::WeaponInfoCPP* temp = item_;
  item_ = NULL;
  return temp;
}
inline void WeaponCastResp::set_allocated_item(::ProtoWeapon::WeaponInfoCPP* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoWeapon.WeaponCastResp.item)
}

// required uint32 multiple = 2;
inline bool WeaponCastResp::has_multiple() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponCastResp::set_has_multiple() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponCastResp::clear_has_multiple() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponCastResp::clear_multiple() {
  multiple_ = 0u;
  clear_has_multiple();
}
inline ::google::protobuf::uint32 WeaponCastResp::multiple() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponCastResp.multiple)
  return multiple_;
}
inline void WeaponCastResp::set_multiple(::google::protobuf::uint32 value) {
  set_has_multiple();
  multiple_ = value;
  // @@protoc_insertion_point(field_set:ProtoWeapon.WeaponCastResp.multiple)
}

// required .DataCommon.UserResourceCPP resource = 3;
inline bool WeaponCastResp::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponCastResp::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponCastResp::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponCastResp::clear_resource() {
  if (resource_ != NULL) resource_->::DataCommon::UserResourceCPP::Clear();
  clear_has_resource();
}
inline const ::DataCommon::UserResourceCPP& WeaponCastResp::resource() const {
  // @@protoc_insertion_point(field_get:ProtoWeapon.WeaponCastResp.resource)
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::DataCommon::UserResourceCPP* WeaponCastResp::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::DataCommon::UserResourceCPP;
  // @@protoc_insertion_point(field_mutable:ProtoWeapon.WeaponCastResp.resource)
  return resource_;
}
inline ::DataCommon::UserResourceCPP* WeaponCastResp::release_resource() {
  clear_has_resource();
  ::DataCommon::UserResourceCPP* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void WeaponCastResp::set_allocated_resource(::DataCommon::UserResourceCPP* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoWeapon.WeaponCastResp.resource)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoWeapon

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoWeapon_2eproto__INCLUDED
