// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoPush.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoPush.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ProtoPush {

namespace {

const ::google::protobuf::Descriptor* UserUpLevel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserUpLevel_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuildYieldInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuildYieldInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* HerosInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HerosInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScienceFinish_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScienceFinish_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushNPCPassRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushNPCPassRecord_reflection_ = NULL;
const ::google::protobuf::Descriptor* OnceEveryDayReward_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OnceEveryDayReward_reflection_ = NULL;
const ::google::protobuf::Descriptor* SmeltActivityHint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SmeltActivityHint_reflection_ = NULL;
const ::google::protobuf::Descriptor* TimesAddPushReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimesAddPushReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* MineKingdomRewardStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MineKingdomRewardStatus_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ProtoPush_2eproto() {
  protobuf_AddDesc_ProtoPush_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ProtoPush.proto");
  GOOGLE_CHECK(file != NULL);
  UserUpLevel_descriptor_ = file->message_type(0);
  static const int UserUpLevel_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, old_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, new_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, sacrifice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, reward_s_),
  };
  UserUpLevel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserUpLevel_descriptor_,
      UserUpLevel::default_instance_,
      UserUpLevel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserUpLevel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserUpLevel));
  BuildYieldInfo_descriptor_ = file->message_type(1);
  static const int BuildYieldInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildYieldInfo, yield_),
  };
  BuildYieldInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuildYieldInfo_descriptor_,
      BuildYieldInfo::default_instance_,
      BuildYieldInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildYieldInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildYieldInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuildYieldInfo));
  HerosInfo_descriptor_ = file->message_type(2);
  static const int HerosInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HerosInfo, heros_),
  };
  HerosInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HerosInfo_descriptor_,
      HerosInfo::default_instance_,
      HerosInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HerosInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HerosInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HerosInfo));
  ScienceFinish_descriptor_ = file->message_type(3);
  static const int ScienceFinish_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScienceFinish, science_),
  };
  ScienceFinish_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ScienceFinish_descriptor_,
      ScienceFinish::default_instance_,
      ScienceFinish_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScienceFinish, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScienceFinish, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ScienceFinish));
  PushNPCPassRecord_descriptor_ = file->message_type(4);
  static const int PushNPCPassRecord_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushNPCPassRecord, item_),
  };
  PushNPCPassRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PushNPCPassRecord_descriptor_,
      PushNPCPassRecord::default_instance_,
      PushNPCPassRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushNPCPassRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushNPCPassRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PushNPCPassRecord));
  OnceEveryDayReward_descriptor_ = file->message_type(5);
  static const int OnceEveryDayReward_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, integral_time_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, market_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, sacrifice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, order_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, refresh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, ladder_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, freerefresh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, reward_times_),
  };
  OnceEveryDayReward_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OnceEveryDayReward_descriptor_,
      OnceEveryDayReward::default_instance_,
      OnceEveryDayReward_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnceEveryDayReward, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OnceEveryDayReward));
  SmeltActivityHint_descriptor_ = file->message_type(6);
  static const int SmeltActivityHint_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmeltActivityHint, type_),
  };
  SmeltActivityHint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SmeltActivityHint_descriptor_,
      SmeltActivityHint::default_instance_,
      SmeltActivityHint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmeltActivityHint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SmeltActivityHint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SmeltActivityHint));
  TimesAddPushReq_descriptor_ = file->message_type(7);
  static const int TimesAddPushReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimesAddPushReq, mission_times_),
  };
  TimesAddPushReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TimesAddPushReq_descriptor_,
      TimesAddPushReq::default_instance_,
      TimesAddPushReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimesAddPushReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimesAddPushReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TimesAddPushReq));
  MineKingdomRewardStatus_descriptor_ = file->message_type(8);
  static const int MineKingdomRewardStatus_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardStatus, kingdom_),
  };
  MineKingdomRewardStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MineKingdomRewardStatus_descriptor_,
      MineKingdomRewardStatus::default_instance_,
      MineKingdomRewardStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MineKingdomRewardStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MineKingdomRewardStatus));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ProtoPush_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserUpLevel_descriptor_, &UserUpLevel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuildYieldInfo_descriptor_, &BuildYieldInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HerosInfo_descriptor_, &HerosInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ScienceFinish_descriptor_, &ScienceFinish::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PushNPCPassRecord_descriptor_, &PushNPCPassRecord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OnceEveryDayReward_descriptor_, &OnceEveryDayReward::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SmeltActivityHint_descriptor_, &SmeltActivityHint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimesAddPushReq_descriptor_, &TimesAddPushReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MineKingdomRewardStatus_descriptor_, &MineKingdomRewardStatus::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ProtoPush_2eproto() {
  delete UserUpLevel::default_instance_;
  delete UserUpLevel_reflection_;
  delete BuildYieldInfo::default_instance_;
  delete BuildYieldInfo_reflection_;
  delete HerosInfo::default_instance_;
  delete HerosInfo_reflection_;
  delete ScienceFinish::default_instance_;
  delete ScienceFinish_reflection_;
  delete PushNPCPassRecord::default_instance_;
  delete PushNPCPassRecord_reflection_;
  delete OnceEveryDayReward::default_instance_;
  delete OnceEveryDayReward_reflection_;
  delete SmeltActivityHint::default_instance_;
  delete SmeltActivityHint_reflection_;
  delete TimesAddPushReq::default_instance_;
  delete TimesAddPushReq_reflection_;
  delete MineKingdomRewardStatus::default_instance_;
  delete MineKingdomRewardStatus_reflection_;
}

void protobuf_AddDesc_ProtoPush_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::ProtoBuilding::protobuf_AddDesc_ProtoBuilding_2eproto();
  ::ProtoHero::protobuf_AddDesc_ProtoHero_2eproto();
  ::ProtoScience::protobuf_AddDesc_ProtoScience_2eproto();
  ::ProtoPass::protobuf_AddDesc_ProtoPass_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017ProtoPush.proto\022\tProtoPush\032\023ProtoBuild"
    "ing.proto\032\017ProtoHero.proto\032\022ProtoScience"
    ".proto\032\017ProtoPass.proto\"r\n\013UserUpLevel\022\013"
    "\n\003uid\030\001 \002(\r\022\021\n\told_level\030\002 \002(\r\022\021\n\tnew_le"
    "vel\030\003 \002(\r\022\013\n\003exp\030\004 \002(\004\022\021\n\tsacrifice\030\005 \002("
    "\r\022\020\n\010reward_s\030\006 \002(\r\":\n\016BuildYieldInfo\022(\n"
    "\005yield\030\001 \003(\0132\031.ProtoBuilding.BuildYield\""
    "6\n\tHerosInfo\022)\n\005heros\030\001 \003(\0132\032.ProtoHero."
    "HeroBaseInfoCPP\">\n\rScienceFinish\022-\n\007scie"
    "nce\030\001 \002(\0132\034.ProtoScience.ScienceItemCPP\""
    ";\n\021PushNPCPassRecord\022&\n\004item\030\001 \002(\0132\030.Pro"
    "toPass.NPCPassRecord\"\255\001\n\022OnceEveryDayRew"
    "ard\022\031\n\021integral_time_cnt\030\001 \002(\r\022\016\n\006market"
    "\030\002 \002(\r\022\021\n\tsacrifice\030\003 \002(\r\022\r\n\005order\030\004 \002(\r"
    "\022\017\n\007refresh\030\005 \002(\r\022\016\n\006ladder\030\006 \002(\r\022\023\n\013fre"
    "erefresh\030\007 \002(\r\022\024\n\014reward_times\030\010 \002(\r\"!\n\021"
    "SmeltActivityHint\022\014\n\004type\030\001 \002(\r\"(\n\017Times"
    "AddPushReq\022\025\n\rmission_times\030\001 \001(\r\"*\n\027Min"
    "eKingdomRewardStatus\022\017\n\007kingdom\030\001 \002(\r", 757);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ProtoPush.proto", &protobuf_RegisterTypes);
  UserUpLevel::default_instance_ = new UserUpLevel();
  BuildYieldInfo::default_instance_ = new BuildYieldInfo();
  HerosInfo::default_instance_ = new HerosInfo();
  ScienceFinish::default_instance_ = new ScienceFinish();
  PushNPCPassRecord::default_instance_ = new PushNPCPassRecord();
  OnceEveryDayReward::default_instance_ = new OnceEveryDayReward();
  SmeltActivityHint::default_instance_ = new SmeltActivityHint();
  TimesAddPushReq::default_instance_ = new TimesAddPushReq();
  MineKingdomRewardStatus::default_instance_ = new MineKingdomRewardStatus();
  UserUpLevel::default_instance_->InitAsDefaultInstance();
  BuildYieldInfo::default_instance_->InitAsDefaultInstance();
  HerosInfo::default_instance_->InitAsDefaultInstance();
  ScienceFinish::default_instance_->InitAsDefaultInstance();
  PushNPCPassRecord::default_instance_->InitAsDefaultInstance();
  OnceEveryDayReward::default_instance_->InitAsDefaultInstance();
  SmeltActivityHint::default_instance_->InitAsDefaultInstance();
  TimesAddPushReq::default_instance_->InitAsDefaultInstance();
  MineKingdomRewardStatus::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoPush_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoPush_2eproto {
  StaticDescriptorInitializer_ProtoPush_2eproto() {
    protobuf_AddDesc_ProtoPush_2eproto();
  }
} static_descriptor_initializer_ProtoPush_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int UserUpLevel::kUidFieldNumber;
const int UserUpLevel::kOldLevelFieldNumber;
const int UserUpLevel::kNewLevelFieldNumber;
const int UserUpLevel::kExpFieldNumber;
const int UserUpLevel::kSacrificeFieldNumber;
const int UserUpLevel::kRewardSFieldNumber;
#endif  // !_MSC_VER

UserUpLevel::UserUpLevel()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.UserUpLevel)
}

void UserUpLevel::InitAsDefaultInstance() {
}

UserUpLevel::UserUpLevel(const UserUpLevel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.UserUpLevel)
}

void UserUpLevel::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  old_level_ = 0u;
  new_level_ = 0u;
  exp_ = GOOGLE_ULONGLONG(0);
  sacrifice_ = 0u;
  reward_s_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserUpLevel::~UserUpLevel() {
  // @@protoc_insertion_point(destructor:ProtoPush.UserUpLevel)
  SharedDtor();
}

void UserUpLevel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UserUpLevel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserUpLevel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserUpLevel_descriptor_;
}

const UserUpLevel& UserUpLevel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

UserUpLevel* UserUpLevel::default_instance_ = NULL;

UserUpLevel* UserUpLevel::New() const {
  return new UserUpLevel;
}

void UserUpLevel::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserUpLevel*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(uid_, reward_s_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserUpLevel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.UserUpLevel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 uid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_old_level;
        break;
      }

      // required uint32 old_level = 2;
      case 2: {
        if (tag == 16) {
         parse_old_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &old_level_)));
          set_has_old_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_new_level;
        break;
      }

      // required uint32 new_level = 3;
      case 3: {
        if (tag == 24) {
         parse_new_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &new_level_)));
          set_has_new_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_exp;
        break;
      }

      // required uint64 exp = 4;
      case 4: {
        if (tag == 32) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_sacrifice;
        break;
      }

      // required uint32 sacrifice = 5;
      case 5: {
        if (tag == 40) {
         parse_sacrifice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sacrifice_)));
          set_has_sacrifice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_reward_s;
        break;
      }

      // required uint32 reward_s = 6;
      case 6: {
        if (tag == 48) {
         parse_reward_s:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reward_s_)));
          set_has_reward_s();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.UserUpLevel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.UserUpLevel)
  return false;
#undef DO_
}

void UserUpLevel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.UserUpLevel)
  // required uint32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint32 old_level = 2;
  if (has_old_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->old_level(), output);
  }

  // required uint32 new_level = 3;
  if (has_new_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->new_level(), output);
  }

  // required uint64 exp = 4;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->exp(), output);
  }

  // required uint32 sacrifice = 5;
  if (has_sacrifice()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sacrifice(), output);
  }

  // required uint32 reward_s = 6;
  if (has_reward_s()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->reward_s(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.UserUpLevel)
}

::google::protobuf::uint8* UserUpLevel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.UserUpLevel)
  // required uint32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint32 old_level = 2;
  if (has_old_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->old_level(), target);
  }

  // required uint32 new_level = 3;
  if (has_new_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->new_level(), target);
  }

  // required uint64 exp = 4;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->exp(), target);
  }

  // required uint32 sacrifice = 5;
  if (has_sacrifice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->sacrifice(), target);
  }

  // required uint32 reward_s = 6;
  if (has_reward_s()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->reward_s(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.UserUpLevel)
  return target;
}

int UserUpLevel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint32 old_level = 2;
    if (has_old_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->old_level());
    }

    // required uint32 new_level = 3;
    if (has_new_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->new_level());
    }

    // required uint64 exp = 4;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->exp());
    }

    // required uint32 sacrifice = 5;
    if (has_sacrifice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sacrifice());
    }

    // required uint32 reward_s = 6;
    if (has_reward_s()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reward_s());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserUpLevel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserUpLevel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserUpLevel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserUpLevel::MergeFrom(const UserUpLevel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_old_level()) {
      set_old_level(from.old_level());
    }
    if (from.has_new_level()) {
      set_new_level(from.new_level());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_sacrifice()) {
      set_sacrifice(from.sacrifice());
    }
    if (from.has_reward_s()) {
      set_reward_s(from.reward_s());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserUpLevel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserUpLevel::CopyFrom(const UserUpLevel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserUpLevel::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void UserUpLevel::Swap(UserUpLevel* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(old_level_, other->old_level_);
    std::swap(new_level_, other->new_level_);
    std::swap(exp_, other->exp_);
    std::swap(sacrifice_, other->sacrifice_);
    std::swap(reward_s_, other->reward_s_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserUpLevel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserUpLevel_descriptor_;
  metadata.reflection = UserUpLevel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuildYieldInfo::kYieldFieldNumber;
#endif  // !_MSC_VER

BuildYieldInfo::BuildYieldInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.BuildYieldInfo)
}

void BuildYieldInfo::InitAsDefaultInstance() {
}

BuildYieldInfo::BuildYieldInfo(const BuildYieldInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.BuildYieldInfo)
}

void BuildYieldInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildYieldInfo::~BuildYieldInfo() {
  // @@protoc_insertion_point(destructor:ProtoPush.BuildYieldInfo)
  SharedDtor();
}

void BuildYieldInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BuildYieldInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuildYieldInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuildYieldInfo_descriptor_;
}

const BuildYieldInfo& BuildYieldInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

BuildYieldInfo* BuildYieldInfo::default_instance_ = NULL;

BuildYieldInfo* BuildYieldInfo::New() const {
  return new BuildYieldInfo;
}

void BuildYieldInfo::Clear() {
  yield_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuildYieldInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.BuildYieldInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtoBuilding.BuildYield yield = 1;
      case 1: {
        if (tag == 10) {
         parse_yield:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_yield()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_yield;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.BuildYieldInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.BuildYieldInfo)
  return false;
#undef DO_
}

void BuildYieldInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.BuildYieldInfo)
  // repeated .ProtoBuilding.BuildYield yield = 1;
  for (int i = 0; i < this->yield_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->yield(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.BuildYieldInfo)
}

::google::protobuf::uint8* BuildYieldInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.BuildYieldInfo)
  // repeated .ProtoBuilding.BuildYield yield = 1;
  for (int i = 0; i < this->yield_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->yield(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.BuildYieldInfo)
  return target;
}

int BuildYieldInfo::ByteSize() const {
  int total_size = 0;

  // repeated .ProtoBuilding.BuildYield yield = 1;
  total_size += 1 * this->yield_size();
  for (int i = 0; i < this->yield_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->yield(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildYieldInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuildYieldInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuildYieldInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuildYieldInfo::MergeFrom(const BuildYieldInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  yield_.MergeFrom(from.yield_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuildYieldInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuildYieldInfo::CopyFrom(const BuildYieldInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildYieldInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->yield())) return false;
  return true;
}

void BuildYieldInfo::Swap(BuildYieldInfo* other) {
  if (other != this) {
    yield_.Swap(&other->yield_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuildYieldInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuildYieldInfo_descriptor_;
  metadata.reflection = BuildYieldInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HerosInfo::kHerosFieldNumber;
#endif  // !_MSC_VER

HerosInfo::HerosInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.HerosInfo)
}

void HerosInfo::InitAsDefaultInstance() {
}

HerosInfo::HerosInfo(const HerosInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.HerosInfo)
}

void HerosInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HerosInfo::~HerosInfo() {
  // @@protoc_insertion_point(destructor:ProtoPush.HerosInfo)
  SharedDtor();
}

void HerosInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HerosInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HerosInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HerosInfo_descriptor_;
}

const HerosInfo& HerosInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

HerosInfo* HerosInfo::default_instance_ = NULL;

HerosInfo* HerosInfo::New() const {
  return new HerosInfo;
}

void HerosInfo::Clear() {
  heros_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HerosInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.HerosInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtoHero.HeroBaseInfoCPP heros = 1;
      case 1: {
        if (tag == 10) {
         parse_heros:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_heros()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_heros;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.HerosInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.HerosInfo)
  return false;
#undef DO_
}

void HerosInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.HerosInfo)
  // repeated .ProtoHero.HeroBaseInfoCPP heros = 1;
  for (int i = 0; i < this->heros_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->heros(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.HerosInfo)
}

::google::protobuf::uint8* HerosInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.HerosInfo)
  // repeated .ProtoHero.HeroBaseInfoCPP heros = 1;
  for (int i = 0; i < this->heros_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->heros(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.HerosInfo)
  return target;
}

int HerosInfo::ByteSize() const {
  int total_size = 0;

  // repeated .ProtoHero.HeroBaseInfoCPP heros = 1;
  total_size += 1 * this->heros_size();
  for (int i = 0; i < this->heros_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->heros(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HerosInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HerosInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HerosInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HerosInfo::MergeFrom(const HerosInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  heros_.MergeFrom(from.heros_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HerosInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HerosInfo::CopyFrom(const HerosInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HerosInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->heros())) return false;
  return true;
}

void HerosInfo::Swap(HerosInfo* other) {
  if (other != this) {
    heros_.Swap(&other->heros_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HerosInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HerosInfo_descriptor_;
  metadata.reflection = HerosInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ScienceFinish::kScienceFieldNumber;
#endif  // !_MSC_VER

ScienceFinish::ScienceFinish()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.ScienceFinish)
}

void ScienceFinish::InitAsDefaultInstance() {
  science_ = const_cast< ::ProtoScience::ScienceItemCPP*>(&::ProtoScience::ScienceItemCPP::default_instance());
}

ScienceFinish::ScienceFinish(const ScienceFinish& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.ScienceFinish)
}

void ScienceFinish::SharedCtor() {
  _cached_size_ = 0;
  science_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScienceFinish::~ScienceFinish() {
  // @@protoc_insertion_point(destructor:ProtoPush.ScienceFinish)
  SharedDtor();
}

void ScienceFinish::SharedDtor() {
  if (this != default_instance_) {
    delete science_;
  }
}

void ScienceFinish::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScienceFinish::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScienceFinish_descriptor_;
}

const ScienceFinish& ScienceFinish::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

ScienceFinish* ScienceFinish::default_instance_ = NULL;

ScienceFinish* ScienceFinish::New() const {
  return new ScienceFinish;
}

void ScienceFinish::Clear() {
  if (has_science()) {
    if (science_ != NULL) science_->::ProtoScience::ScienceItemCPP::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ScienceFinish::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.ScienceFinish)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoScience.ScienceItemCPP science = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_science()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.ScienceFinish)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.ScienceFinish)
  return false;
#undef DO_
}

void ScienceFinish::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.ScienceFinish)
  // required .ProtoScience.ScienceItemCPP science = 1;
  if (has_science()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->science(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.ScienceFinish)
}

::google::protobuf::uint8* ScienceFinish::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.ScienceFinish)
  // required .ProtoScience.ScienceItemCPP science = 1;
  if (has_science()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->science(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.ScienceFinish)
  return target;
}

int ScienceFinish::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoScience.ScienceItemCPP science = 1;
    if (has_science()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->science());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScienceFinish::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ScienceFinish* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ScienceFinish*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScienceFinish::MergeFrom(const ScienceFinish& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_science()) {
      mutable_science()->::ProtoScience::ScienceItemCPP::MergeFrom(from.science());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ScienceFinish::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScienceFinish::CopyFrom(const ScienceFinish& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScienceFinish::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_science()) {
    if (!this->science().IsInitialized()) return false;
  }
  return true;
}

void ScienceFinish::Swap(ScienceFinish* other) {
  if (other != this) {
    std::swap(science_, other->science_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ScienceFinish::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScienceFinish_descriptor_;
  metadata.reflection = ScienceFinish_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PushNPCPassRecord::kItemFieldNumber;
#endif  // !_MSC_VER

PushNPCPassRecord::PushNPCPassRecord()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.PushNPCPassRecord)
}

void PushNPCPassRecord::InitAsDefaultInstance() {
  item_ = const_cast< ::ProtoPass::NPCPassRecord*>(&::ProtoPass::NPCPassRecord::default_instance());
}

PushNPCPassRecord::PushNPCPassRecord(const PushNPCPassRecord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.PushNPCPassRecord)
}

void PushNPCPassRecord::SharedCtor() {
  _cached_size_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushNPCPassRecord::~PushNPCPassRecord() {
  // @@protoc_insertion_point(destructor:ProtoPush.PushNPCPassRecord)
  SharedDtor();
}

void PushNPCPassRecord::SharedDtor() {
  if (this != default_instance_) {
    delete item_;
  }
}

void PushNPCPassRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushNPCPassRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushNPCPassRecord_descriptor_;
}

const PushNPCPassRecord& PushNPCPassRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

PushNPCPassRecord* PushNPCPassRecord::default_instance_ = NULL;

PushNPCPassRecord* PushNPCPassRecord::New() const {
  return new PushNPCPassRecord;
}

void PushNPCPassRecord::Clear() {
  if (has_item()) {
    if (item_ != NULL) item_->::ProtoPass::NPCPassRecord::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PushNPCPassRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.PushNPCPassRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtoPass.NPCPassRecord item = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.PushNPCPassRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.PushNPCPassRecord)
  return false;
#undef DO_
}

void PushNPCPassRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.PushNPCPassRecord)
  // required .ProtoPass.NPCPassRecord item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->item(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.PushNPCPassRecord)
}

::google::protobuf::uint8* PushNPCPassRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.PushNPCPassRecord)
  // required .ProtoPass.NPCPassRecord item = 1;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->item(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.PushNPCPassRecord)
  return target;
}

int PushNPCPassRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtoPass.NPCPassRecord item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushNPCPassRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PushNPCPassRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PushNPCPassRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PushNPCPassRecord::MergeFrom(const PushNPCPassRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      mutable_item()->::ProtoPass::NPCPassRecord::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PushNPCPassRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushNPCPassRecord::CopyFrom(const PushNPCPassRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushNPCPassRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_item()) {
    if (!this->item().IsInitialized()) return false;
  }
  return true;
}

void PushNPCPassRecord::Swap(PushNPCPassRecord* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PushNPCPassRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushNPCPassRecord_descriptor_;
  metadata.reflection = PushNPCPassRecord_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OnceEveryDayReward::kIntegralTimeCntFieldNumber;
const int OnceEveryDayReward::kMarketFieldNumber;
const int OnceEveryDayReward::kSacrificeFieldNumber;
const int OnceEveryDayReward::kOrderFieldNumber;
const int OnceEveryDayReward::kRefreshFieldNumber;
const int OnceEveryDayReward::kLadderFieldNumber;
const int OnceEveryDayReward::kFreerefreshFieldNumber;
const int OnceEveryDayReward::kRewardTimesFieldNumber;
#endif  // !_MSC_VER

OnceEveryDayReward::OnceEveryDayReward()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.OnceEveryDayReward)
}

void OnceEveryDayReward::InitAsDefaultInstance() {
}

OnceEveryDayReward::OnceEveryDayReward(const OnceEveryDayReward& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.OnceEveryDayReward)
}

void OnceEveryDayReward::SharedCtor() {
  _cached_size_ = 0;
  integral_time_cnt_ = 0u;
  market_ = 0u;
  sacrifice_ = 0u;
  order_ = 0u;
  refresh_ = 0u;
  ladder_ = 0u;
  freerefresh_ = 0u;
  reward_times_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OnceEveryDayReward::~OnceEveryDayReward() {
  // @@protoc_insertion_point(destructor:ProtoPush.OnceEveryDayReward)
  SharedDtor();
}

void OnceEveryDayReward::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OnceEveryDayReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OnceEveryDayReward::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OnceEveryDayReward_descriptor_;
}

const OnceEveryDayReward& OnceEveryDayReward::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

OnceEveryDayReward* OnceEveryDayReward::default_instance_ = NULL;

OnceEveryDayReward* OnceEveryDayReward::New() const {
  return new OnceEveryDayReward;
}

void OnceEveryDayReward::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OnceEveryDayReward*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(integral_time_cnt_, reward_times_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OnceEveryDayReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.OnceEveryDayReward)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 integral_time_cnt = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &integral_time_cnt_)));
          set_has_integral_time_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_market;
        break;
      }

      // required uint32 market = 2;
      case 2: {
        if (tag == 16) {
         parse_market:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &market_)));
          set_has_market();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sacrifice;
        break;
      }

      // required uint32 sacrifice = 3;
      case 3: {
        if (tag == 24) {
         parse_sacrifice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sacrifice_)));
          set_has_sacrifice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_order;
        break;
      }

      // required uint32 order = 4;
      case 4: {
        if (tag == 32) {
         parse_order:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_refresh;
        break;
      }

      // required uint32 refresh = 5;
      case 5: {
        if (tag == 40) {
         parse_refresh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &refresh_)));
          set_has_refresh();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ladder;
        break;
      }

      // required uint32 ladder = 6;
      case 6: {
        if (tag == 48) {
         parse_ladder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ladder_)));
          set_has_ladder();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_freerefresh;
        break;
      }

      // required uint32 freerefresh = 7;
      case 7: {
        if (tag == 56) {
         parse_freerefresh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &freerefresh_)));
          set_has_freerefresh();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_reward_times;
        break;
      }

      // required uint32 reward_times = 8;
      case 8: {
        if (tag == 64) {
         parse_reward_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reward_times_)));
          set_has_reward_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.OnceEveryDayReward)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.OnceEveryDayReward)
  return false;
#undef DO_
}

void OnceEveryDayReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.OnceEveryDayReward)
  // required uint32 integral_time_cnt = 1;
  if (has_integral_time_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->integral_time_cnt(), output);
  }

  // required uint32 market = 2;
  if (has_market()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->market(), output);
  }

  // required uint32 sacrifice = 3;
  if (has_sacrifice()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sacrifice(), output);
  }

  // required uint32 order = 4;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->order(), output);
  }

  // required uint32 refresh = 5;
  if (has_refresh()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->refresh(), output);
  }

  // required uint32 ladder = 6;
  if (has_ladder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ladder(), output);
  }

  // required uint32 freerefresh = 7;
  if (has_freerefresh()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->freerefresh(), output);
  }

  // required uint32 reward_times = 8;
  if (has_reward_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->reward_times(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.OnceEveryDayReward)
}

::google::protobuf::uint8* OnceEveryDayReward::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.OnceEveryDayReward)
  // required uint32 integral_time_cnt = 1;
  if (has_integral_time_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->integral_time_cnt(), target);
  }

  // required uint32 market = 2;
  if (has_market()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->market(), target);
  }

  // required uint32 sacrifice = 3;
  if (has_sacrifice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->sacrifice(), target);
  }

  // required uint32 order = 4;
  if (has_order()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->order(), target);
  }

  // required uint32 refresh = 5;
  if (has_refresh()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->refresh(), target);
  }

  // required uint32 ladder = 6;
  if (has_ladder()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->ladder(), target);
  }

  // required uint32 freerefresh = 7;
  if (has_freerefresh()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->freerefresh(), target);
  }

  // required uint32 reward_times = 8;
  if (has_reward_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->reward_times(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.OnceEveryDayReward)
  return target;
}

int OnceEveryDayReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 integral_time_cnt = 1;
    if (has_integral_time_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->integral_time_cnt());
    }

    // required uint32 market = 2;
    if (has_market()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->market());
    }

    // required uint32 sacrifice = 3;
    if (has_sacrifice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sacrifice());
    }

    // required uint32 order = 4;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->order());
    }

    // required uint32 refresh = 5;
    if (has_refresh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->refresh());
    }

    // required uint32 ladder = 6;
    if (has_ladder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ladder());
    }

    // required uint32 freerefresh = 7;
    if (has_freerefresh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->freerefresh());
    }

    // required uint32 reward_times = 8;
    if (has_reward_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reward_times());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OnceEveryDayReward::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OnceEveryDayReward* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OnceEveryDayReward*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OnceEveryDayReward::MergeFrom(const OnceEveryDayReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_integral_time_cnt()) {
      set_integral_time_cnt(from.integral_time_cnt());
    }
    if (from.has_market()) {
      set_market(from.market());
    }
    if (from.has_sacrifice()) {
      set_sacrifice(from.sacrifice());
    }
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_refresh()) {
      set_refresh(from.refresh());
    }
    if (from.has_ladder()) {
      set_ladder(from.ladder());
    }
    if (from.has_freerefresh()) {
      set_freerefresh(from.freerefresh());
    }
    if (from.has_reward_times()) {
      set_reward_times(from.reward_times());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OnceEveryDayReward::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OnceEveryDayReward::CopyFrom(const OnceEveryDayReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnceEveryDayReward::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void OnceEveryDayReward::Swap(OnceEveryDayReward* other) {
  if (other != this) {
    std::swap(integral_time_cnt_, other->integral_time_cnt_);
    std::swap(market_, other->market_);
    std::swap(sacrifice_, other->sacrifice_);
    std::swap(order_, other->order_);
    std::swap(refresh_, other->refresh_);
    std::swap(ladder_, other->ladder_);
    std::swap(freerefresh_, other->freerefresh_);
    std::swap(reward_times_, other->reward_times_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OnceEveryDayReward::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OnceEveryDayReward_descriptor_;
  metadata.reflection = OnceEveryDayReward_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SmeltActivityHint::kTypeFieldNumber;
#endif  // !_MSC_VER

SmeltActivityHint::SmeltActivityHint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.SmeltActivityHint)
}

void SmeltActivityHint::InitAsDefaultInstance() {
}

SmeltActivityHint::SmeltActivityHint(const SmeltActivityHint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.SmeltActivityHint)
}

void SmeltActivityHint::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SmeltActivityHint::~SmeltActivityHint() {
  // @@protoc_insertion_point(destructor:ProtoPush.SmeltActivityHint)
  SharedDtor();
}

void SmeltActivityHint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SmeltActivityHint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SmeltActivityHint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SmeltActivityHint_descriptor_;
}

const SmeltActivityHint& SmeltActivityHint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

SmeltActivityHint* SmeltActivityHint::default_instance_ = NULL;

SmeltActivityHint* SmeltActivityHint::New() const {
  return new SmeltActivityHint;
}

void SmeltActivityHint::Clear() {
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SmeltActivityHint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.SmeltActivityHint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.SmeltActivityHint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.SmeltActivityHint)
  return false;
#undef DO_
}

void SmeltActivityHint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.SmeltActivityHint)
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.SmeltActivityHint)
}

::google::protobuf::uint8* SmeltActivityHint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.SmeltActivityHint)
  // required uint32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.SmeltActivityHint)
  return target;
}

int SmeltActivityHint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SmeltActivityHint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SmeltActivityHint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SmeltActivityHint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SmeltActivityHint::MergeFrom(const SmeltActivityHint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SmeltActivityHint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SmeltActivityHint::CopyFrom(const SmeltActivityHint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmeltActivityHint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SmeltActivityHint::Swap(SmeltActivityHint* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SmeltActivityHint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SmeltActivityHint_descriptor_;
  metadata.reflection = SmeltActivityHint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TimesAddPushReq::kMissionTimesFieldNumber;
#endif  // !_MSC_VER

TimesAddPushReq::TimesAddPushReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.TimesAddPushReq)
}

void TimesAddPushReq::InitAsDefaultInstance() {
}

TimesAddPushReq::TimesAddPushReq(const TimesAddPushReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.TimesAddPushReq)
}

void TimesAddPushReq::SharedCtor() {
  _cached_size_ = 0;
  mission_times_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimesAddPushReq::~TimesAddPushReq() {
  // @@protoc_insertion_point(destructor:ProtoPush.TimesAddPushReq)
  SharedDtor();
}

void TimesAddPushReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimesAddPushReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimesAddPushReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimesAddPushReq_descriptor_;
}

const TimesAddPushReq& TimesAddPushReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

TimesAddPushReq* TimesAddPushReq::default_instance_ = NULL;

TimesAddPushReq* TimesAddPushReq::New() const {
  return new TimesAddPushReq;
}

void TimesAddPushReq::Clear() {
  mission_times_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimesAddPushReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.TimesAddPushReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mission_times = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mission_times_)));
          set_has_mission_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.TimesAddPushReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.TimesAddPushReq)
  return false;
#undef DO_
}

void TimesAddPushReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.TimesAddPushReq)
  // optional uint32 mission_times = 1;
  if (has_mission_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mission_times(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.TimesAddPushReq)
}

::google::protobuf::uint8* TimesAddPushReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.TimesAddPushReq)
  // optional uint32 mission_times = 1;
  if (has_mission_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->mission_times(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.TimesAddPushReq)
  return target;
}

int TimesAddPushReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 mission_times = 1;
    if (has_mission_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mission_times());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimesAddPushReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimesAddPushReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TimesAddPushReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimesAddPushReq::MergeFrom(const TimesAddPushReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_times()) {
      set_mission_times(from.mission_times());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimesAddPushReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimesAddPushReq::CopyFrom(const TimesAddPushReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimesAddPushReq::IsInitialized() const {

  return true;
}

void TimesAddPushReq::Swap(TimesAddPushReq* other) {
  if (other != this) {
    std::swap(mission_times_, other->mission_times_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TimesAddPushReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimesAddPushReq_descriptor_;
  metadata.reflection = TimesAddPushReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MineKingdomRewardStatus::kKingdomFieldNumber;
#endif  // !_MSC_VER

MineKingdomRewardStatus::MineKingdomRewardStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProtoPush.MineKingdomRewardStatus)
}

void MineKingdomRewardStatus::InitAsDefaultInstance() {
}

MineKingdomRewardStatus::MineKingdomRewardStatus(const MineKingdomRewardStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ProtoPush.MineKingdomRewardStatus)
}

void MineKingdomRewardStatus::SharedCtor() {
  _cached_size_ = 0;
  kingdom_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MineKingdomRewardStatus::~MineKingdomRewardStatus() {
  // @@protoc_insertion_point(destructor:ProtoPush.MineKingdomRewardStatus)
  SharedDtor();
}

void MineKingdomRewardStatus::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MineKingdomRewardStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MineKingdomRewardStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MineKingdomRewardStatus_descriptor_;
}

const MineKingdomRewardStatus& MineKingdomRewardStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoPush_2eproto();
  return *default_instance_;
}

MineKingdomRewardStatus* MineKingdomRewardStatus::default_instance_ = NULL;

MineKingdomRewardStatus* MineKingdomRewardStatus::New() const {
  return new MineKingdomRewardStatus;
}

void MineKingdomRewardStatus::Clear() {
  kingdom_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MineKingdomRewardStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProtoPush.MineKingdomRewardStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 kingdom = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &kingdom_)));
          set_has_kingdom();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProtoPush.MineKingdomRewardStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProtoPush.MineKingdomRewardStatus)
  return false;
#undef DO_
}

void MineKingdomRewardStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProtoPush.MineKingdomRewardStatus)
  // required uint32 kingdom = 1;
  if (has_kingdom()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->kingdom(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ProtoPush.MineKingdomRewardStatus)
}

::google::protobuf::uint8* MineKingdomRewardStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoPush.MineKingdomRewardStatus)
  // required uint32 kingdom = 1;
  if (has_kingdom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->kingdom(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoPush.MineKingdomRewardStatus)
  return target;
}

int MineKingdomRewardStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 kingdom = 1;
    if (has_kingdom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->kingdom());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MineKingdomRewardStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MineKingdomRewardStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MineKingdomRewardStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MineKingdomRewardStatus::MergeFrom(const MineKingdomRewardStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kingdom()) {
      set_kingdom(from.kingdom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MineKingdomRewardStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MineKingdomRewardStatus::CopyFrom(const MineKingdomRewardStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MineKingdomRewardStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MineKingdomRewardStatus::Swap(MineKingdomRewardStatus* other) {
  if (other != this) {
    std::swap(kingdom_, other->kingdom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MineKingdomRewardStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MineKingdomRewardStatus_descriptor_;
  metadata.reflection = MineKingdomRewardStatus_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoPush

// @@protoc_insertion_point(global_scope)
