// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NPC.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "NPC.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace NPC {

namespace {

const ::google::protobuf::Descriptor* NPCInfoItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NPCInfoItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* NPCInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NPCInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NPCList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NPCList_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_NPC_2eproto() {
  protobuf_AddDesc_NPC_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "NPC.proto");
  GOOGLE_CHECK(file != NULL);
  NPCInfoItem_descriptor_ = file->message_type(0);
  static const int NPCInfoItem_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfoItem, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfoItem, count_),
  };
  NPCInfoItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NPCInfoItem_descriptor_,
      NPCInfoItem::default_instance_,
      NPCInfoItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfoItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfoItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NPCInfoItem));
  NPCInfo_descriptor_ = file->message_type(1);
  static const int NPCInfo_offsets_[32] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, npcid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, character_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, skillid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, skillco_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, skillrange_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, skilltime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, tacticalarea1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, tacticalarea2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, tacticalarea3_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, tacticalarea4_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, tacticaladd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, giftarea_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, giftadd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_hp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_attack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_defend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_skill_extra_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_skill_anti_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_attack_extra_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_attack_anti_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_int_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_str_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_soldier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_tech_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, p_anti_tech_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, r_exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, r_coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, r_food_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, r_wood_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, r_iron_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, r_item_),
  };
  NPCInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NPCInfo_descriptor_,
      NPCInfo::default_instance_,
      NPCInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NPCInfo));
  NPCList_descriptor_ = file->message_type(2);
  static const int NPCList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCList, npc_),
  };
  NPCList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NPCList_descriptor_,
      NPCList::default_instance_,
      NPCList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NPCList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NPCList));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_NPC_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NPCInfoItem_descriptor_, &NPCInfoItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NPCInfo_descriptor_, &NPCInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NPCList_descriptor_, &NPCList::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_NPC_2eproto() {
  delete NPCInfoItem::default_instance_;
  delete NPCInfoItem_reflection_;
  delete NPCInfo::default_instance_;
  delete NPCInfo_reflection_;
  delete NPCList::default_instance_;
  delete NPCList_reflection_;
}

void protobuf_AddDesc_NPC_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tNPC.proto\022\003NPC\"(\n\013NPCInfoItem\022\n\n\002id\030\001 "
    "\002(\r\022\r\n\005count\030\002 \002(\r\"\356\004\n\007NPCInfo\022\r\n\005npcid\030"
    "\001 \002(\r\022\021\n\tcharacter\030\002 \002(\r\022\017\n\007skillid\030\003 \002("
    "\r\022\017\n\007skillco\030\004 \002(\002\022\022\n\nskillrange\030\005 \002(\r\022\021"
    "\n\tskilltime\030\006 \002(\r\022\025\n\rtacticalarea1\030\007 \003(\r"
    "\022\025\n\rtacticalarea2\030\010 \003(\r\022\025\n\rtacticalarea3"
    "\030\t \003(\r\022\025\n\rtacticalarea4\030\n \003(\r\022\023\n\013tactica"
    "ladd\030\013 \002(\r\022\020\n\010giftarea\030\014 \003(\r\022\017\n\007giftadd\030"
    "\r \002(\002\022\014\n\004p_hp\030\016 \002(\r\022\020\n\010p_attack\030\017 \002(\r\022\020\n"
    "\010p_defend\030\020 \002(\r\022\025\n\rp_skill_extra\030\021 \002(\r\022\024"
    "\n\014p_skill_anti\030\022 \002(\r\022\026\n\016p_attack_extra\030\023"
    " \002(\r\022\025\n\rp_attack_anti\030\024 \002(\r\022\r\n\005p_int\030\025 \002"
    "(\r\022\r\n\005p_str\030\026 \002(\r\022\017\n\007p_level\030\027 \002(\r\022\021\n\tp_"
    "soldier\030\030 \002(\r\022\016\n\006p_tech\030\031 \002(\r\022\023\n\013p_anti_"
    "tech\030\032 \002(\r\022\r\n\005r_exp\030\033 \002(\r\022\016\n\006r_coin\030\034 \002("
    "\r\022\016\n\006r_food\030\035 \002(\r\022\016\n\006r_wood\030\036 \002(\r\022\016\n\006r_i"
    "ron\030\037 \002(\r\022 \n\006r_item\030  \003(\0132\020.NPC.NPCInfoI"
    "tem\"$\n\007NPCList\022\031\n\003npc\030\001 \003(\0132\014.NPC.NPCInf"
    "o", 721);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "NPC.proto", &protobuf_RegisterTypes);
  NPCInfoItem::default_instance_ = new NPCInfoItem();
  NPCInfo::default_instance_ = new NPCInfo();
  NPCList::default_instance_ = new NPCList();
  NPCInfoItem::default_instance_->InitAsDefaultInstance();
  NPCInfo::default_instance_->InitAsDefaultInstance();
  NPCList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_NPC_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_NPC_2eproto {
  StaticDescriptorInitializer_NPC_2eproto() {
    protobuf_AddDesc_NPC_2eproto();
  }
} static_descriptor_initializer_NPC_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int NPCInfoItem::kIdFieldNumber;
const int NPCInfoItem::kCountFieldNumber;
#endif  // !_MSC_VER

NPCInfoItem::NPCInfoItem()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NPC.NPCInfoItem)
}

void NPCInfoItem::InitAsDefaultInstance() {
}

NPCInfoItem::NPCInfoItem(const NPCInfoItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NPC.NPCInfoItem)
}

void NPCInfoItem::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCInfoItem::~NPCInfoItem() {
  // @@protoc_insertion_point(destructor:NPC.NPCInfoItem)
  SharedDtor();
}

void NPCInfoItem::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NPCInfoItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NPCInfoItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NPCInfoItem_descriptor_;
}

const NPCInfoItem& NPCInfoItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NPC_2eproto();
  return *default_instance_;
}

NPCInfoItem* NPCInfoItem::default_instance_ = NULL;

NPCInfoItem* NPCInfoItem::New() const {
  return new NPCInfoItem;
}

void NPCInfoItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NPCInfoItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NPCInfoItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NPC.NPCInfoItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // required uint32 count = 2;
      case 2: {
        if (tag == 16) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NPC.NPCInfoItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NPC.NPCInfoItem)
  return false;
#undef DO_
}

void NPCInfoItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NPC.NPCInfoItem)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:NPC.NPCInfoItem)
}

::google::protobuf::uint8* NPCInfoItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NPC.NPCInfoItem)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 count = 2;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NPC.NPCInfoItem)
  return target;
}

int NPCInfoItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCInfoItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NPCInfoItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NPCInfoItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NPCInfoItem::MergeFrom(const NPCInfoItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NPCInfoItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NPCInfoItem::CopyFrom(const NPCInfoItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCInfoItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NPCInfoItem::Swap(NPCInfoItem* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NPCInfoItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NPCInfoItem_descriptor_;
  metadata.reflection = NPCInfoItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NPCInfo::kNpcidFieldNumber;
const int NPCInfo::kCharacterFieldNumber;
const int NPCInfo::kSkillidFieldNumber;
const int NPCInfo::kSkillcoFieldNumber;
const int NPCInfo::kSkillrangeFieldNumber;
const int NPCInfo::kSkilltimeFieldNumber;
const int NPCInfo::kTacticalarea1FieldNumber;
const int NPCInfo::kTacticalarea2FieldNumber;
const int NPCInfo::kTacticalarea3FieldNumber;
const int NPCInfo::kTacticalarea4FieldNumber;
const int NPCInfo::kTacticaladdFieldNumber;
const int NPCInfo::kGiftareaFieldNumber;
const int NPCInfo::kGiftaddFieldNumber;
const int NPCInfo::kPHpFieldNumber;
const int NPCInfo::kPAttackFieldNumber;
const int NPCInfo::kPDefendFieldNumber;
const int NPCInfo::kPSkillExtraFieldNumber;
const int NPCInfo::kPSkillAntiFieldNumber;
const int NPCInfo::kPAttackExtraFieldNumber;
const int NPCInfo::kPAttackAntiFieldNumber;
const int NPCInfo::kPIntFieldNumber;
const int NPCInfo::kPStrFieldNumber;
const int NPCInfo::kPLevelFieldNumber;
const int NPCInfo::kPSoldierFieldNumber;
const int NPCInfo::kPTechFieldNumber;
const int NPCInfo::kPAntiTechFieldNumber;
const int NPCInfo::kRExpFieldNumber;
const int NPCInfo::kRCoinFieldNumber;
const int NPCInfo::kRFoodFieldNumber;
const int NPCInfo::kRWoodFieldNumber;
const int NPCInfo::kRIronFieldNumber;
const int NPCInfo::kRItemFieldNumber;
#endif  // !_MSC_VER

NPCInfo::NPCInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NPC.NPCInfo)
}

void NPCInfo::InitAsDefaultInstance() {
}

NPCInfo::NPCInfo(const NPCInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NPC.NPCInfo)
}

void NPCInfo::SharedCtor() {
  _cached_size_ = 0;
  npcid_ = 0u;
  character_ = 0u;
  skillid_ = 0u;
  skillco_ = 0;
  skillrange_ = 0u;
  skilltime_ = 0u;
  tacticaladd_ = 0u;
  giftadd_ = 0;
  p_hp_ = 0u;
  p_attack_ = 0u;
  p_defend_ = 0u;
  p_skill_extra_ = 0u;
  p_skill_anti_ = 0u;
  p_attack_extra_ = 0u;
  p_attack_anti_ = 0u;
  p_int_ = 0u;
  p_str_ = 0u;
  p_level_ = 0u;
  p_soldier_ = 0u;
  p_tech_ = 0u;
  p_anti_tech_ = 0u;
  r_exp_ = 0u;
  r_coin_ = 0u;
  r_food_ = 0u;
  r_wood_ = 0u;
  r_iron_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCInfo::~NPCInfo() {
  // @@protoc_insertion_point(destructor:NPC.NPCInfo)
  SharedDtor();
}

void NPCInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NPCInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NPCInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NPCInfo_descriptor_;
}

const NPCInfo& NPCInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NPC_2eproto();
  return *default_instance_;
}

NPCInfo* NPCInfo::default_instance_ = NULL;

NPCInfo* NPCInfo::New() const {
  return new NPCInfo;
}

void NPCInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NPCInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(npcid_, skilltime_);
  }
  if (_has_bits_[8 / 32] & 62464) {
    ZR_(tacticaladd_, p_defend_);
  }
  if (_has_bits_[16 / 32] & 16711680) {
    ZR_(p_skill_extra_, p_soldier_);
  }
  if (_has_bits_[24 / 32] & 2130706432) {
    ZR_(p_tech_, r_iron_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  tacticalarea1_.Clear();
  tacticalarea2_.Clear();
  tacticalarea3_.Clear();
  tacticalarea4_.Clear();
  giftarea_.Clear();
  r_item_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NPCInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NPC.NPCInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 npcid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &npcid_)));
          set_has_npcid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_character;
        break;
      }

      // required uint32 character = 2;
      case 2: {
        if (tag == 16) {
         parse_character:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &character_)));
          set_has_character();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_skillid;
        break;
      }

      // required uint32 skillid = 3;
      case 3: {
        if (tag == 24) {
         parse_skillid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_skillco;
        break;
      }

      // required float skillco = 4;
      case 4: {
        if (tag == 37) {
         parse_skillco:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &skillco_)));
          set_has_skillco();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_skillrange;
        break;
      }

      // required uint32 skillrange = 5;
      case 5: {
        if (tag == 40) {
         parse_skillrange:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skillrange_)));
          set_has_skillrange();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_skilltime;
        break;
      }

      // required uint32 skilltime = 6;
      case 6: {
        if (tag == 48) {
         parse_skilltime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &skilltime_)));
          set_has_skilltime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tacticalarea1;
        break;
      }

      // repeated uint32 tacticalarea1 = 7;
      case 7: {
        if (tag == 56) {
         parse_tacticalarea1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_tacticalarea1())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tacticalarea1())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tacticalarea1;
        if (input->ExpectTag(64)) goto parse_tacticalarea2;
        break;
      }

      // repeated uint32 tacticalarea2 = 8;
      case 8: {
        if (tag == 64) {
         parse_tacticalarea2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_tacticalarea2())));
        } else if (tag == 66) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tacticalarea2())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_tacticalarea2;
        if (input->ExpectTag(72)) goto parse_tacticalarea3;
        break;
      }

      // repeated uint32 tacticalarea3 = 9;
      case 9: {
        if (tag == 72) {
         parse_tacticalarea3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 72, input, this->mutable_tacticalarea3())));
        } else if (tag == 74) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tacticalarea3())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_tacticalarea3;
        if (input->ExpectTag(80)) goto parse_tacticalarea4;
        break;
      }

      // repeated uint32 tacticalarea4 = 10;
      case 10: {
        if (tag == 80) {
         parse_tacticalarea4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 80, input, this->mutable_tacticalarea4())));
        } else if (tag == 82) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tacticalarea4())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_tacticalarea4;
        if (input->ExpectTag(88)) goto parse_tacticaladd;
        break;
      }

      // required uint32 tacticaladd = 11;
      case 11: {
        if (tag == 88) {
         parse_tacticaladd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tacticaladd_)));
          set_has_tacticaladd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_giftarea;
        break;
      }

      // repeated uint32 giftarea = 12;
      case 12: {
        if (tag == 96) {
         parse_giftarea:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 96, input, this->mutable_giftarea())));
        } else if (tag == 98) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_giftarea())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_giftarea;
        if (input->ExpectTag(109)) goto parse_giftadd;
        break;
      }

      // required float giftadd = 13;
      case 13: {
        if (tag == 109) {
         parse_giftadd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &giftadd_)));
          set_has_giftadd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_p_hp;
        break;
      }

      // required uint32 p_hp = 14;
      case 14: {
        if (tag == 112) {
         parse_p_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_hp_)));
          set_has_p_hp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_p_attack;
        break;
      }

      // required uint32 p_attack = 15;
      case 15: {
        if (tag == 120) {
         parse_p_attack:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_attack_)));
          set_has_p_attack();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_p_defend;
        break;
      }

      // required uint32 p_defend = 16;
      case 16: {
        if (tag == 128) {
         parse_p_defend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_defend_)));
          set_has_p_defend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_p_skill_extra;
        break;
      }

      // required uint32 p_skill_extra = 17;
      case 17: {
        if (tag == 136) {
         parse_p_skill_extra:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_skill_extra_)));
          set_has_p_skill_extra();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_p_skill_anti;
        break;
      }

      // required uint32 p_skill_anti = 18;
      case 18: {
        if (tag == 144) {
         parse_p_skill_anti:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_skill_anti_)));
          set_has_p_skill_anti();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_p_attack_extra;
        break;
      }

      // required uint32 p_attack_extra = 19;
      case 19: {
        if (tag == 152) {
         parse_p_attack_extra:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_attack_extra_)));
          set_has_p_attack_extra();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_p_attack_anti;
        break;
      }

      // required uint32 p_attack_anti = 20;
      case 20: {
        if (tag == 160) {
         parse_p_attack_anti:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_attack_anti_)));
          set_has_p_attack_anti();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_p_int;
        break;
      }

      // required uint32 p_int = 21;
      case 21: {
        if (tag == 168) {
         parse_p_int:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_int_)));
          set_has_p_int();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_p_str;
        break;
      }

      // required uint32 p_str = 22;
      case 22: {
        if (tag == 176) {
         parse_p_str:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_str_)));
          set_has_p_str();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_p_level;
        break;
      }

      // required uint32 p_level = 23;
      case 23: {
        if (tag == 184) {
         parse_p_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_level_)));
          set_has_p_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_p_soldier;
        break;
      }

      // required uint32 p_soldier = 24;
      case 24: {
        if (tag == 192) {
         parse_p_soldier:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_soldier_)));
          set_has_p_soldier();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_p_tech;
        break;
      }

      // required uint32 p_tech = 25;
      case 25: {
        if (tag == 200) {
         parse_p_tech:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_tech_)));
          set_has_p_tech();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_p_anti_tech;
        break;
      }

      // required uint32 p_anti_tech = 26;
      case 26: {
        if (tag == 208) {
         parse_p_anti_tech:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &p_anti_tech_)));
          set_has_p_anti_tech();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_r_exp;
        break;
      }

      // required uint32 r_exp = 27;
      case 27: {
        if (tag == 216) {
         parse_r_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_exp_)));
          set_has_r_exp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_r_coin;
        break;
      }

      // required uint32 r_coin = 28;
      case 28: {
        if (tag == 224) {
         parse_r_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_coin_)));
          set_has_r_coin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_r_food;
        break;
      }

      // required uint32 r_food = 29;
      case 29: {
        if (tag == 232) {
         parse_r_food:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_food_)));
          set_has_r_food();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_r_wood;
        break;
      }

      // required uint32 r_wood = 30;
      case 30: {
        if (tag == 240) {
         parse_r_wood:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_wood_)));
          set_has_r_wood();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_r_iron;
        break;
      }

      // required uint32 r_iron = 31;
      case 31: {
        if (tag == 248) {
         parse_r_iron:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_iron_)));
          set_has_r_iron();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_r_item;
        break;
      }

      // repeated .NPC.NPCInfoItem r_item = 32;
      case 32: {
        if (tag == 258) {
         parse_r_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_r_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_r_item;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NPC.NPCInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NPC.NPCInfo)
  return false;
#undef DO_
}

void NPCInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NPC.NPCInfo)
  // required uint32 npcid = 1;
  if (has_npcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->npcid(), output);
  }

  // required uint32 character = 2;
  if (has_character()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->character(), output);
  }

  // required uint32 skillid = 3;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->skillid(), output);
  }

  // required float skillco = 4;
  if (has_skillco()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->skillco(), output);
  }

  // required uint32 skillrange = 5;
  if (has_skillrange()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->skillrange(), output);
  }

  // required uint32 skilltime = 6;
  if (has_skilltime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->skilltime(), output);
  }

  // repeated uint32 tacticalarea1 = 7;
  for (int i = 0; i < this->tacticalarea1_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->tacticalarea1(i), output);
  }

  // repeated uint32 tacticalarea2 = 8;
  for (int i = 0; i < this->tacticalarea2_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->tacticalarea2(i), output);
  }

  // repeated uint32 tacticalarea3 = 9;
  for (int i = 0; i < this->tacticalarea3_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      9, this->tacticalarea3(i), output);
  }

  // repeated uint32 tacticalarea4 = 10;
  for (int i = 0; i < this->tacticalarea4_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      10, this->tacticalarea4(i), output);
  }

  // required uint32 tacticaladd = 11;
  if (has_tacticaladd()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->tacticaladd(), output);
  }

  // repeated uint32 giftarea = 12;
  for (int i = 0; i < this->giftarea_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      12, this->giftarea(i), output);
  }

  // required float giftadd = 13;
  if (has_giftadd()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->giftadd(), output);
  }

  // required uint32 p_hp = 14;
  if (has_p_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->p_hp(), output);
  }

  // required uint32 p_attack = 15;
  if (has_p_attack()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->p_attack(), output);
  }

  // required uint32 p_defend = 16;
  if (has_p_defend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->p_defend(), output);
  }

  // required uint32 p_skill_extra = 17;
  if (has_p_skill_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->p_skill_extra(), output);
  }

  // required uint32 p_skill_anti = 18;
  if (has_p_skill_anti()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(18, this->p_skill_anti(), output);
  }

  // required uint32 p_attack_extra = 19;
  if (has_p_attack_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(19, this->p_attack_extra(), output);
  }

  // required uint32 p_attack_anti = 20;
  if (has_p_attack_anti()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(20, this->p_attack_anti(), output);
  }

  // required uint32 p_int = 21;
  if (has_p_int()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(21, this->p_int(), output);
  }

  // required uint32 p_str = 22;
  if (has_p_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(22, this->p_str(), output);
  }

  // required uint32 p_level = 23;
  if (has_p_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->p_level(), output);
  }

  // required uint32 p_soldier = 24;
  if (has_p_soldier()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(24, this->p_soldier(), output);
  }

  // required uint32 p_tech = 25;
  if (has_p_tech()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(25, this->p_tech(), output);
  }

  // required uint32 p_anti_tech = 26;
  if (has_p_anti_tech()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(26, this->p_anti_tech(), output);
  }

  // required uint32 r_exp = 27;
  if (has_r_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(27, this->r_exp(), output);
  }

  // required uint32 r_coin = 28;
  if (has_r_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(28, this->r_coin(), output);
  }

  // required uint32 r_food = 29;
  if (has_r_food()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(29, this->r_food(), output);
  }

  // required uint32 r_wood = 30;
  if (has_r_wood()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(30, this->r_wood(), output);
  }

  // required uint32 r_iron = 31;
  if (has_r_iron()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->r_iron(), output);
  }

  // repeated .NPC.NPCInfoItem r_item = 32;
  for (int i = 0; i < this->r_item_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, this->r_item(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:NPC.NPCInfo)
}

::google::protobuf::uint8* NPCInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NPC.NPCInfo)
  // required uint32 npcid = 1;
  if (has_npcid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->npcid(), target);
  }

  // required uint32 character = 2;
  if (has_character()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->character(), target);
  }

  // required uint32 skillid = 3;
  if (has_skillid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->skillid(), target);
  }

  // required float skillco = 4;
  if (has_skillco()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->skillco(), target);
  }

  // required uint32 skillrange = 5;
  if (has_skillrange()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->skillrange(), target);
  }

  // required uint32 skilltime = 6;
  if (has_skilltime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->skilltime(), target);
  }

  // repeated uint32 tacticalarea1 = 7;
  for (int i = 0; i < this->tacticalarea1_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(7, this->tacticalarea1(i), target);
  }

  // repeated uint32 tacticalarea2 = 8;
  for (int i = 0; i < this->tacticalarea2_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(8, this->tacticalarea2(i), target);
  }

  // repeated uint32 tacticalarea3 = 9;
  for (int i = 0; i < this->tacticalarea3_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(9, this->tacticalarea3(i), target);
  }

  // repeated uint32 tacticalarea4 = 10;
  for (int i = 0; i < this->tacticalarea4_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(10, this->tacticalarea4(i), target);
  }

  // required uint32 tacticaladd = 11;
  if (has_tacticaladd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->tacticaladd(), target);
  }

  // repeated uint32 giftarea = 12;
  for (int i = 0; i < this->giftarea_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(12, this->giftarea(i), target);
  }

  // required float giftadd = 13;
  if (has_giftadd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->giftadd(), target);
  }

  // required uint32 p_hp = 14;
  if (has_p_hp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->p_hp(), target);
  }

  // required uint32 p_attack = 15;
  if (has_p_attack()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->p_attack(), target);
  }

  // required uint32 p_defend = 16;
  if (has_p_defend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->p_defend(), target);
  }

  // required uint32 p_skill_extra = 17;
  if (has_p_skill_extra()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(17, this->p_skill_extra(), target);
  }

  // required uint32 p_skill_anti = 18;
  if (has_p_skill_anti()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(18, this->p_skill_anti(), target);
  }

  // required uint32 p_attack_extra = 19;
  if (has_p_attack_extra()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(19, this->p_attack_extra(), target);
  }

  // required uint32 p_attack_anti = 20;
  if (has_p_attack_anti()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(20, this->p_attack_anti(), target);
  }

  // required uint32 p_int = 21;
  if (has_p_int()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(21, this->p_int(), target);
  }

  // required uint32 p_str = 22;
  if (has_p_str()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(22, this->p_str(), target);
  }

  // required uint32 p_level = 23;
  if (has_p_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(23, this->p_level(), target);
  }

  // required uint32 p_soldier = 24;
  if (has_p_soldier()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(24, this->p_soldier(), target);
  }

  // required uint32 p_tech = 25;
  if (has_p_tech()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(25, this->p_tech(), target);
  }

  // required uint32 p_anti_tech = 26;
  if (has_p_anti_tech()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(26, this->p_anti_tech(), target);
  }

  // required uint32 r_exp = 27;
  if (has_r_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(27, this->r_exp(), target);
  }

  // required uint32 r_coin = 28;
  if (has_r_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(28, this->r_coin(), target);
  }

  // required uint32 r_food = 29;
  if (has_r_food()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(29, this->r_food(), target);
  }

  // required uint32 r_wood = 30;
  if (has_r_wood()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(30, this->r_wood(), target);
  }

  // required uint32 r_iron = 31;
  if (has_r_iron()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(31, this->r_iron(), target);
  }

  // repeated .NPC.NPCInfoItem r_item = 32;
  for (int i = 0; i < this->r_item_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        32, this->r_item(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NPC.NPCInfo)
  return target;
}

int NPCInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 npcid = 1;
    if (has_npcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->npcid());
    }

    // required uint32 character = 2;
    if (has_character()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->character());
    }

    // required uint32 skillid = 3;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skillid());
    }

    // required float skillco = 4;
    if (has_skillco()) {
      total_size += 1 + 4;
    }

    // required uint32 skillrange = 5;
    if (has_skillrange()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skillrange());
    }

    // required uint32 skilltime = 6;
    if (has_skilltime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->skilltime());
    }

  }
  if (_has_bits_[10 / 32] & (0xffu << (10 % 32))) {
    // required uint32 tacticaladd = 11;
    if (has_tacticaladd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tacticaladd());
    }

    // required float giftadd = 13;
    if (has_giftadd()) {
      total_size += 1 + 4;
    }

    // required uint32 p_hp = 14;
    if (has_p_hp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_hp());
    }

    // required uint32 p_attack = 15;
    if (has_p_attack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_attack());
    }

    // required uint32 p_defend = 16;
    if (has_p_defend()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_defend());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // required uint32 p_skill_extra = 17;
    if (has_p_skill_extra()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_skill_extra());
    }

    // required uint32 p_skill_anti = 18;
    if (has_p_skill_anti()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_skill_anti());
    }

    // required uint32 p_attack_extra = 19;
    if (has_p_attack_extra()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_attack_extra());
    }

    // required uint32 p_attack_anti = 20;
    if (has_p_attack_anti()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_attack_anti());
    }

    // required uint32 p_int = 21;
    if (has_p_int()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_int());
    }

    // required uint32 p_str = 22;
    if (has_p_str()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_str());
    }

    // required uint32 p_level = 23;
    if (has_p_level()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_level());
    }

    // required uint32 p_soldier = 24;
    if (has_p_soldier()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_soldier());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // required uint32 p_tech = 25;
    if (has_p_tech()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_tech());
    }

    // required uint32 p_anti_tech = 26;
    if (has_p_anti_tech()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->p_anti_tech());
    }

    // required uint32 r_exp = 27;
    if (has_r_exp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r_exp());
    }

    // required uint32 r_coin = 28;
    if (has_r_coin()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r_coin());
    }

    // required uint32 r_food = 29;
    if (has_r_food()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r_food());
    }

    // required uint32 r_wood = 30;
    if (has_r_wood()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r_wood());
    }

    // required uint32 r_iron = 31;
    if (has_r_iron()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r_iron());
    }

  }
  // repeated uint32 tacticalarea1 = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->tacticalarea1_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tacticalarea1(i));
    }
    total_size += 1 * this->tacticalarea1_size() + data_size;
  }

  // repeated uint32 tacticalarea2 = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->tacticalarea2_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tacticalarea2(i));
    }
    total_size += 1 * this->tacticalarea2_size() + data_size;
  }

  // repeated uint32 tacticalarea3 = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->tacticalarea3_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tacticalarea3(i));
    }
    total_size += 1 * this->tacticalarea3_size() + data_size;
  }

  // repeated uint32 tacticalarea4 = 10;
  {
    int data_size = 0;
    for (int i = 0; i < this->tacticalarea4_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tacticalarea4(i));
    }
    total_size += 1 * this->tacticalarea4_size() + data_size;
  }

  // repeated uint32 giftarea = 12;
  {
    int data_size = 0;
    for (int i = 0; i < this->giftarea_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->giftarea(i));
    }
    total_size += 1 * this->giftarea_size() + data_size;
  }

  // repeated .NPC.NPCInfoItem r_item = 32;
  total_size += 2 * this->r_item_size();
  for (int i = 0; i < this->r_item_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->r_item(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NPCInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NPCInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NPCInfo::MergeFrom(const NPCInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  tacticalarea1_.MergeFrom(from.tacticalarea1_);
  tacticalarea2_.MergeFrom(from.tacticalarea2_);
  tacticalarea3_.MergeFrom(from.tacticalarea3_);
  tacticalarea4_.MergeFrom(from.tacticalarea4_);
  giftarea_.MergeFrom(from.giftarea_);
  r_item_.MergeFrom(from.r_item_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npcid()) {
      set_npcid(from.npcid());
    }
    if (from.has_character()) {
      set_character(from.character());
    }
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
    if (from.has_skillco()) {
      set_skillco(from.skillco());
    }
    if (from.has_skillrange()) {
      set_skillrange(from.skillrange());
    }
    if (from.has_skilltime()) {
      set_skilltime(from.skilltime());
    }
  }
  if (from._has_bits_[10 / 32] & (0xffu << (10 % 32))) {
    if (from.has_tacticaladd()) {
      set_tacticaladd(from.tacticaladd());
    }
    if (from.has_giftadd()) {
      set_giftadd(from.giftadd());
    }
    if (from.has_p_hp()) {
      set_p_hp(from.p_hp());
    }
    if (from.has_p_attack()) {
      set_p_attack(from.p_attack());
    }
    if (from.has_p_defend()) {
      set_p_defend(from.p_defend());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_p_skill_extra()) {
      set_p_skill_extra(from.p_skill_extra());
    }
    if (from.has_p_skill_anti()) {
      set_p_skill_anti(from.p_skill_anti());
    }
    if (from.has_p_attack_extra()) {
      set_p_attack_extra(from.p_attack_extra());
    }
    if (from.has_p_attack_anti()) {
      set_p_attack_anti(from.p_attack_anti());
    }
    if (from.has_p_int()) {
      set_p_int(from.p_int());
    }
    if (from.has_p_str()) {
      set_p_str(from.p_str());
    }
    if (from.has_p_level()) {
      set_p_level(from.p_level());
    }
    if (from.has_p_soldier()) {
      set_p_soldier(from.p_soldier());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_p_tech()) {
      set_p_tech(from.p_tech());
    }
    if (from.has_p_anti_tech()) {
      set_p_anti_tech(from.p_anti_tech());
    }
    if (from.has_r_exp()) {
      set_r_exp(from.r_exp());
    }
    if (from.has_r_coin()) {
      set_r_coin(from.r_coin());
    }
    if (from.has_r_food()) {
      set_r_food(from.r_food());
    }
    if (from.has_r_wood()) {
      set_r_wood(from.r_wood());
    }
    if (from.has_r_iron()) {
      set_r_iron(from.r_iron());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NPCInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NPCInfo::CopyFrom(const NPCInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x7ffff43f) != 0x7ffff43f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->r_item())) return false;
  return true;
}

void NPCInfo::Swap(NPCInfo* other) {
  if (other != this) {
    std::swap(npcid_, other->npcid_);
    std::swap(character_, other->character_);
    std::swap(skillid_, other->skillid_);
    std::swap(skillco_, other->skillco_);
    std::swap(skillrange_, other->skillrange_);
    std::swap(skilltime_, other->skilltime_);
    tacticalarea1_.Swap(&other->tacticalarea1_);
    tacticalarea2_.Swap(&other->tacticalarea2_);
    tacticalarea3_.Swap(&other->tacticalarea3_);
    tacticalarea4_.Swap(&other->tacticalarea4_);
    std::swap(tacticaladd_, other->tacticaladd_);
    giftarea_.Swap(&other->giftarea_);
    std::swap(giftadd_, other->giftadd_);
    std::swap(p_hp_, other->p_hp_);
    std::swap(p_attack_, other->p_attack_);
    std::swap(p_defend_, other->p_defend_);
    std::swap(p_skill_extra_, other->p_skill_extra_);
    std::swap(p_skill_anti_, other->p_skill_anti_);
    std::swap(p_attack_extra_, other->p_attack_extra_);
    std::swap(p_attack_anti_, other->p_attack_anti_);
    std::swap(p_int_, other->p_int_);
    std::swap(p_str_, other->p_str_);
    std::swap(p_level_, other->p_level_);
    std::swap(p_soldier_, other->p_soldier_);
    std::swap(p_tech_, other->p_tech_);
    std::swap(p_anti_tech_, other->p_anti_tech_);
    std::swap(r_exp_, other->r_exp_);
    std::swap(r_coin_, other->r_coin_);
    std::swap(r_food_, other->r_food_);
    std::swap(r_wood_, other->r_wood_);
    std::swap(r_iron_, other->r_iron_);
    r_item_.Swap(&other->r_item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NPCInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NPCInfo_descriptor_;
  metadata.reflection = NPCInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NPCList::kNpcFieldNumber;
#endif  // !_MSC_VER

NPCList::NPCList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NPC.NPCList)
}

void NPCList::InitAsDefaultInstance() {
}

NPCList::NPCList(const NPCList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NPC.NPCList)
}

void NPCList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NPCList::~NPCList() {
  // @@protoc_insertion_point(destructor:NPC.NPCList)
  SharedDtor();
}

void NPCList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NPCList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NPCList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NPCList_descriptor_;
}

const NPCList& NPCList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NPC_2eproto();
  return *default_instance_;
}

NPCList* NPCList::default_instance_ = NULL;

NPCList* NPCList::New() const {
  return new NPCList;
}

void NPCList::Clear() {
  npc_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NPCList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NPC.NPCList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .NPC.NPCInfo npc = 1;
      case 1: {
        if (tag == 10) {
         parse_npc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_npc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_npc;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NPC.NPCList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NPC.NPCList)
  return false;
#undef DO_
}

void NPCList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NPC.NPCList)
  // repeated .NPC.NPCInfo npc = 1;
  for (int i = 0; i < this->npc_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->npc(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:NPC.NPCList)
}

::google::protobuf::uint8* NPCList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NPC.NPCList)
  // repeated .NPC.NPCInfo npc = 1;
  for (int i = 0; i < this->npc_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->npc(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NPC.NPCList)
  return target;
}

int NPCList::ByteSize() const {
  int total_size = 0;

  // repeated .NPC.NPCInfo npc = 1;
  total_size += 1 * this->npc_size();
  for (int i = 0; i < this->npc_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->npc(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NPCList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NPCList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NPCList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NPCList::MergeFrom(const NPCList& from) {
  GOOGLE_CHECK_NE(&from, this);
  npc_.MergeFrom(from.npc_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NPCList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NPCList::CopyFrom(const NPCList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NPCList::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->npc())) return false;
  return true;
}

void NPCList::Swap(NPCList* other) {
  if (other != this) {
    npc_.Swap(&other->npc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NPCList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NPCList_descriptor_;
  metadata.reflection = NPCList_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NPC

// @@protoc_insertion_point(global_scope)
