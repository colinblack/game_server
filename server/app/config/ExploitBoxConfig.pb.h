// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ExploitBoxConfig.proto

#ifndef PROTOBUF_ExploitBoxConfig_2eproto__INCLUDED
#define PROTOBUF_ExploitBoxConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "VipGiftConfig.pb.h"
#include "CommonGiftConfig.pb.h"
// @@protoc_insertion_point(includes)

namespace ExploitBoxConfig {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

class ExploitRandomMul;
class ExploitReward;
class BaseRewardItem;
class ExploitItem;
class ExploitBox;
class Exploit;

// ===================================================================

class ExploitRandomMul : public ::google::protobuf::Message {
 public:
  ExploitRandomMul();
  virtual ~ExploitRandomMul();

  ExploitRandomMul(const ExploitRandomMul& from);

  inline ExploitRandomMul& operator=(const ExploitRandomMul& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploitRandomMul& default_instance();

  void Swap(ExploitRandomMul* other);

  // implements Message ----------------------------------------------

  ExploitRandomMul* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploitRandomMul& from);
  void MergeFrom(const ExploitRandomMul& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 stage_3 = 1;
  inline int stage_3_size() const;
  inline void clear_stage_3();
  static const int kStage3FieldNumber = 1;
  inline ::google::protobuf::uint32 stage_3(int index) const;
  inline void set_stage_3(int index, ::google::protobuf::uint32 value);
  inline void add_stage_3(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      stage_3() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_stage_3();

  // repeated uint32 stage_5 = 2;
  inline int stage_5_size() const;
  inline void clear_stage_5();
  static const int kStage5FieldNumber = 2;
  inline ::google::protobuf::uint32 stage_5(int index) const;
  inline void set_stage_5(int index, ::google::protobuf::uint32 value);
  inline void add_stage_5(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      stage_5() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_stage_5();

  // @@protoc_insertion_point(class_scope:ExploitBoxConfig.ExploitRandomMul)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > stage_3_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > stage_5_;
  friend void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

  void InitAsDefaultInstance();
  static ExploitRandomMul* default_instance_;
};
// -------------------------------------------------------------------

class ExploitReward : public ::google::protobuf::Message {
 public:
  ExploitReward();
  virtual ~ExploitReward();

  ExploitReward(const ExploitReward& from);

  inline ExploitReward& operator=(const ExploitReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploitReward& default_instance();

  void Swap(ExploitReward* other);

  // implements Message ----------------------------------------------

  ExploitReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploitReward& from);
  void MergeFrom(const ExploitReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .VipGiftConfig.EquipReward equips = 1;
  inline bool has_equips() const;
  inline void clear_equips();
  static const int kEquipsFieldNumber = 1;
  inline const ::VipGiftConfig::EquipReward& equips() const;
  inline ::VipGiftConfig::EquipReward* mutable_equips();
  inline ::VipGiftConfig::EquipReward* release_equips();
  inline void set_allocated_equips(::VipGiftConfig::EquipReward* equips);

  // optional .CommonGiftConfig.BaseReward base = 2;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 2;
  inline const ::CommonGiftConfig::BaseReward& base() const;
  inline ::CommonGiftConfig::BaseReward* mutable_base();
  inline ::CommonGiftConfig::BaseReward* release_base();
  inline void set_allocated_base(::CommonGiftConfig::BaseReward* base);

  // required bool is_mul = 3;
  inline bool has_is_mul() const;
  inline void clear_is_mul();
  static const int kIsMulFieldNumber = 3;
  inline bool is_mul() const;
  inline void set_is_mul(bool value);

  // required uint32 prob = 4;
  inline bool has_prob() const;
  inline void clear_prob();
  static const int kProbFieldNumber = 4;
  inline ::google::protobuf::uint32 prob() const;
  inline void set_prob(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ExploitBoxConfig.ExploitReward)
 private:
  inline void set_has_equips();
  inline void clear_has_equips();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_is_mul();
  inline void clear_has_is_mul();
  inline void set_has_prob();
  inline void clear_has_prob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::VipGiftConfig::EquipReward* equips_;
  ::CommonGiftConfig::BaseReward* base_;
  bool is_mul_;
  ::google::protobuf::uint32 prob_;
  friend void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

  void InitAsDefaultInstance();
  static ExploitReward* default_instance_;
};
// -------------------------------------------------------------------

class BaseRewardItem : public ::google::protobuf::Message {
 public:
  BaseRewardItem();
  virtual ~BaseRewardItem();

  BaseRewardItem(const BaseRewardItem& from);

  inline BaseRewardItem& operator=(const BaseRewardItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseRewardItem& default_instance();

  void Swap(BaseRewardItem* other);

  // implements Message ----------------------------------------------

  BaseRewardItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseRewardItem& from);
  void MergeFrom(const BaseRewardItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CommonGiftConfig.BaseReward base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::CommonGiftConfig::BaseReward& base() const;
  inline ::CommonGiftConfig::BaseReward* mutable_base();
  inline ::CommonGiftConfig::BaseReward* release_base();
  inline void set_allocated_base(::CommonGiftConfig::BaseReward* base);

  // required uint32 prob = 2;
  inline bool has_prob() const;
  inline void clear_prob();
  static const int kProbFieldNumber = 2;
  inline ::google::protobuf::uint32 prob() const;
  inline void set_prob(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ExploitBoxConfig.BaseRewardItem)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_prob();
  inline void clear_has_prob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CommonGiftConfig::BaseReward* base_;
  ::google::protobuf::uint32 prob_;
  friend void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

  void InitAsDefaultInstance();
  static BaseRewardItem* default_instance_;
};
// -------------------------------------------------------------------

class ExploitItem : public ::google::protobuf::Message {
 public:
  ExploitItem();
  virtual ~ExploitItem();

  ExploitItem(const ExploitItem& from);

  inline ExploitItem& operator=(const ExploitItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploitItem& default_instance();

  void Swap(ExploitItem* other);

  // implements Message ----------------------------------------------

  ExploitItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploitItem& from);
  void MergeFrom(const ExploitItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 box_level = 1;
  inline bool has_box_level() const;
  inline void clear_box_level();
  static const int kBoxLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 box_level() const;
  inline void set_box_level(::google::protobuf::uint32 value);

  // repeated uint32 exploit_amount = 2;
  inline int exploit_amount_size() const;
  inline void clear_exploit_amount();
  static const int kExploitAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 exploit_amount(int index) const;
  inline void set_exploit_amount(int index, ::google::protobuf::uint32 value);
  inline void add_exploit_amount(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      exploit_amount() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_exploit_amount();

  // repeated uint32 box_cnt = 3;
  inline int box_cnt_size() const;
  inline void clear_box_cnt();
  static const int kBoxCntFieldNumber = 3;
  inline ::google::protobuf::uint32 box_cnt(int index) const;
  inline void set_box_cnt(int index, ::google::protobuf::uint32 value);
  inline void add_box_cnt(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      box_cnt() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_box_cnt();

  // repeated .ExploitBoxConfig.ExploitReward reward = 4;
  inline int reward_size() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 4;
  inline const ::ExploitBoxConfig::ExploitReward& reward(int index) const;
  inline ::ExploitBoxConfig::ExploitReward* mutable_reward(int index);
  inline ::ExploitBoxConfig::ExploitReward* add_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitReward >&
      reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitReward >*
      mutable_reward();

  // repeated .ExploitBoxConfig.BaseRewardItem base_reward = 5;
  inline int base_reward_size() const;
  inline void clear_base_reward();
  static const int kBaseRewardFieldNumber = 5;
  inline const ::ExploitBoxConfig::BaseRewardItem& base_reward(int index) const;
  inline ::ExploitBoxConfig::BaseRewardItem* mutable_base_reward(int index);
  inline ::ExploitBoxConfig::BaseRewardItem* add_base_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::BaseRewardItem >&
      base_reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::BaseRewardItem >*
      mutable_base_reward();

  // @@protoc_insertion_point(class_scope:ExploitBoxConfig.ExploitItem)
 private:
  inline void set_has_box_level();
  inline void clear_has_box_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > exploit_amount_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > box_cnt_;
  ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitReward > reward_;
  ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::BaseRewardItem > base_reward_;
  ::google::protobuf::uint32 box_level_;
  friend void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

  void InitAsDefaultInstance();
  static ExploitItem* default_instance_;
};
// -------------------------------------------------------------------

class ExploitBox : public ::google::protobuf::Message {
 public:
  ExploitBox();
  virtual ~ExploitBox();

  ExploitBox(const ExploitBox& from);

  inline ExploitBox& operator=(const ExploitBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploitBox& default_instance();

  void Swap(ExploitBox* other);

  // implements Message ----------------------------------------------

  ExploitBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploitBox& from);
  void MergeFrom(const ExploitBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 prob = 1;
  inline int prob_size() const;
  inline void clear_prob();
  static const int kProbFieldNumber = 1;
  inline ::google::protobuf::uint32 prob(int index) const;
  inline void set_prob(int index, ::google::protobuf::uint32 value);
  inline void add_prob(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      prob() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_prob();

  // required .ExploitBoxConfig.ExploitRandomMul random_mul = 2;
  inline bool has_random_mul() const;
  inline void clear_random_mul();
  static const int kRandomMulFieldNumber = 2;
  inline const ::ExploitBoxConfig::ExploitRandomMul& random_mul() const;
  inline ::ExploitBoxConfig::ExploitRandomMul* mutable_random_mul();
  inline ::ExploitBoxConfig::ExploitRandomMul* release_random_mul();
  inline void set_allocated_random_mul(::ExploitBoxConfig::ExploitRandomMul* random_mul);

  // repeated .ExploitBoxConfig.ExploitItem out = 3;
  inline int out_size() const;
  inline void clear_out();
  static const int kOutFieldNumber = 3;
  inline const ::ExploitBoxConfig::ExploitItem& out(int index) const;
  inline ::ExploitBoxConfig::ExploitItem* mutable_out(int index);
  inline ::ExploitBoxConfig::ExploitItem* add_out();
  inline const ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitItem >&
      out() const;
  inline ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitItem >*
      mutable_out();

  // @@protoc_insertion_point(class_scope:ExploitBoxConfig.ExploitBox)
 private:
  inline void set_has_random_mul();
  inline void clear_has_random_mul();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > prob_;
  ::ExploitBoxConfig::ExploitRandomMul* random_mul_;
  ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitItem > out_;
  friend void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

  void InitAsDefaultInstance();
  static ExploitBox* default_instance_;
};
// -------------------------------------------------------------------

class Exploit : public ::google::protobuf::Message {
 public:
  Exploit();
  virtual ~Exploit();

  Exploit(const Exploit& from);

  inline Exploit& operator=(const Exploit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exploit& default_instance();

  void Swap(Exploit* other);

  // implements Message ----------------------------------------------

  Exploit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exploit& from);
  void MergeFrom(const Exploit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ExploitBoxConfig.ExploitBox exploit = 1;
  inline bool has_exploit() const;
  inline void clear_exploit();
  static const int kExploitFieldNumber = 1;
  inline const ::ExploitBoxConfig::ExploitBox& exploit() const;
  inline ::ExploitBoxConfig::ExploitBox* mutable_exploit();
  inline ::ExploitBoxConfig::ExploitBox* release_exploit();
  inline void set_allocated_exploit(::ExploitBoxConfig::ExploitBox* exploit);

  // @@protoc_insertion_point(class_scope:ExploitBoxConfig.Exploit)
 private:
  inline void set_has_exploit();
  inline void clear_has_exploit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ExploitBoxConfig::ExploitBox* exploit_;
  friend void  protobuf_AddDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_AssignDesc_ExploitBoxConfig_2eproto();
  friend void protobuf_ShutdownFile_ExploitBoxConfig_2eproto();

  void InitAsDefaultInstance();
  static Exploit* default_instance_;
};
// ===================================================================


// ===================================================================

// ExploitRandomMul

// repeated uint32 stage_3 = 1;
inline int ExploitRandomMul::stage_3_size() const {
  return stage_3_.size();
}
inline void ExploitRandomMul::clear_stage_3() {
  stage_3_.Clear();
}
inline ::google::protobuf::uint32 ExploitRandomMul::stage_3(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitRandomMul.stage_3)
  return stage_3_.Get(index);
}
inline void ExploitRandomMul::set_stage_3(int index, ::google::protobuf::uint32 value) {
  stage_3_.Set(index, value);
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitRandomMul.stage_3)
}
inline void ExploitRandomMul::add_stage_3(::google::protobuf::uint32 value) {
  stage_3_.Add(value);
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitRandomMul.stage_3)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ExploitRandomMul::stage_3() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitRandomMul.stage_3)
  return stage_3_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ExploitRandomMul::mutable_stage_3() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitRandomMul.stage_3)
  return &stage_3_;
}

// repeated uint32 stage_5 = 2;
inline int ExploitRandomMul::stage_5_size() const {
  return stage_5_.size();
}
inline void ExploitRandomMul::clear_stage_5() {
  stage_5_.Clear();
}
inline ::google::protobuf::uint32 ExploitRandomMul::stage_5(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitRandomMul.stage_5)
  return stage_5_.Get(index);
}
inline void ExploitRandomMul::set_stage_5(int index, ::google::protobuf::uint32 value) {
  stage_5_.Set(index, value);
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitRandomMul.stage_5)
}
inline void ExploitRandomMul::add_stage_5(::google::protobuf::uint32 value) {
  stage_5_.Add(value);
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitRandomMul.stage_5)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ExploitRandomMul::stage_5() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitRandomMul.stage_5)
  return stage_5_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ExploitRandomMul::mutable_stage_5() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitRandomMul.stage_5)
  return &stage_5_;
}

// -------------------------------------------------------------------

// ExploitReward

// optional .VipGiftConfig.EquipReward equips = 1;
inline bool ExploitReward::has_equips() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExploitReward::set_has_equips() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExploitReward::clear_has_equips() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExploitReward::clear_equips() {
  if (equips_ != NULL) equips_->::VipGiftConfig::EquipReward::Clear();
  clear_has_equips();
}
inline const ::VipGiftConfig::EquipReward& ExploitReward::equips() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitReward.equips)
  return equips_ != NULL ? *equips_ : *default_instance_->equips_;
}
inline ::VipGiftConfig::EquipReward* ExploitReward::mutable_equips() {
  set_has_equips();
  if (equips_ == NULL) equips_ = new ::VipGiftConfig::EquipReward;
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.ExploitReward.equips)
  return equips_;
}
inline ::VipGiftConfig::EquipReward* ExploitReward::release_equips() {
  clear_has_equips();
  ::VipGiftConfig::EquipReward* temp = equips_;
  equips_ = NULL;
  return temp;
}
inline void ExploitReward::set_allocated_equips(::VipGiftConfig::EquipReward* equips) {
  delete equips_;
  equips_ = equips;
  if (equips) {
    set_has_equips();
  } else {
    clear_has_equips();
  }
  // @@protoc_insertion_point(field_set_allocated:ExploitBoxConfig.ExploitReward.equips)
}

// optional .CommonGiftConfig.BaseReward base = 2;
inline bool ExploitReward::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExploitReward::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExploitReward::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExploitReward::clear_base() {
  if (base_ != NULL) base_->::CommonGiftConfig::BaseReward::Clear();
  clear_has_base();
}
inline const ::CommonGiftConfig::BaseReward& ExploitReward::base() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitReward.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::CommonGiftConfig::BaseReward* ExploitReward::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::CommonGiftConfig::BaseReward;
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.ExploitReward.base)
  return base_;
}
inline ::CommonGiftConfig::BaseReward* ExploitReward::release_base() {
  clear_has_base();
  ::CommonGiftConfig::BaseReward* temp = base_;
  base_ = NULL;
  return temp;
}
inline void ExploitReward::set_allocated_base(::CommonGiftConfig::BaseReward* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:ExploitBoxConfig.ExploitReward.base)
}

// required bool is_mul = 3;
inline bool ExploitReward::has_is_mul() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExploitReward::set_has_is_mul() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExploitReward::clear_has_is_mul() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExploitReward::clear_is_mul() {
  is_mul_ = false;
  clear_has_is_mul();
}
inline bool ExploitReward::is_mul() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitReward.is_mul)
  return is_mul_;
}
inline void ExploitReward::set_is_mul(bool value) {
  set_has_is_mul();
  is_mul_ = value;
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitReward.is_mul)
}

// required uint32 prob = 4;
inline bool ExploitReward::has_prob() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExploitReward::set_has_prob() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExploitReward::clear_has_prob() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExploitReward::clear_prob() {
  prob_ = 0u;
  clear_has_prob();
}
inline ::google::protobuf::uint32 ExploitReward::prob() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitReward.prob)
  return prob_;
}
inline void ExploitReward::set_prob(::google::protobuf::uint32 value) {
  set_has_prob();
  prob_ = value;
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitReward.prob)
}

// -------------------------------------------------------------------

// BaseRewardItem

// required .CommonGiftConfig.BaseReward base = 1;
inline bool BaseRewardItem::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseRewardItem::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseRewardItem::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseRewardItem::clear_base() {
  if (base_ != NULL) base_->::CommonGiftConfig::BaseReward::Clear();
  clear_has_base();
}
inline const ::CommonGiftConfig::BaseReward& BaseRewardItem::base() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.BaseRewardItem.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::CommonGiftConfig::BaseReward* BaseRewardItem::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::CommonGiftConfig::BaseReward;
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.BaseRewardItem.base)
  return base_;
}
inline ::CommonGiftConfig::BaseReward* BaseRewardItem::release_base() {
  clear_has_base();
  ::CommonGiftConfig::BaseReward* temp = base_;
  base_ = NULL;
  return temp;
}
inline void BaseRewardItem::set_allocated_base(::CommonGiftConfig::BaseReward* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:ExploitBoxConfig.BaseRewardItem.base)
}

// required uint32 prob = 2;
inline bool BaseRewardItem::has_prob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseRewardItem::set_has_prob() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseRewardItem::clear_has_prob() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseRewardItem::clear_prob() {
  prob_ = 0u;
  clear_has_prob();
}
inline ::google::protobuf::uint32 BaseRewardItem::prob() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.BaseRewardItem.prob)
  return prob_;
}
inline void BaseRewardItem::set_prob(::google::protobuf::uint32 value) {
  set_has_prob();
  prob_ = value;
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.BaseRewardItem.prob)
}

// -------------------------------------------------------------------

// ExploitItem

// required uint32 box_level = 1;
inline bool ExploitItem::has_box_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExploitItem::set_has_box_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExploitItem::clear_has_box_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExploitItem::clear_box_level() {
  box_level_ = 0u;
  clear_has_box_level();
}
inline ::google::protobuf::uint32 ExploitItem::box_level() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitItem.box_level)
  return box_level_;
}
inline void ExploitItem::set_box_level(::google::protobuf::uint32 value) {
  set_has_box_level();
  box_level_ = value;
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitItem.box_level)
}

// repeated uint32 exploit_amount = 2;
inline int ExploitItem::exploit_amount_size() const {
  return exploit_amount_.size();
}
inline void ExploitItem::clear_exploit_amount() {
  exploit_amount_.Clear();
}
inline ::google::protobuf::uint32 ExploitItem::exploit_amount(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitItem.exploit_amount)
  return exploit_amount_.Get(index);
}
inline void ExploitItem::set_exploit_amount(int index, ::google::protobuf::uint32 value) {
  exploit_amount_.Set(index, value);
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitItem.exploit_amount)
}
inline void ExploitItem::add_exploit_amount(::google::protobuf::uint32 value) {
  exploit_amount_.Add(value);
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitItem.exploit_amount)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ExploitItem::exploit_amount() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitItem.exploit_amount)
  return exploit_amount_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ExploitItem::mutable_exploit_amount() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitItem.exploit_amount)
  return &exploit_amount_;
}

// repeated uint32 box_cnt = 3;
inline int ExploitItem::box_cnt_size() const {
  return box_cnt_.size();
}
inline void ExploitItem::clear_box_cnt() {
  box_cnt_.Clear();
}
inline ::google::protobuf::uint32 ExploitItem::box_cnt(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitItem.box_cnt)
  return box_cnt_.Get(index);
}
inline void ExploitItem::set_box_cnt(int index, ::google::protobuf::uint32 value) {
  box_cnt_.Set(index, value);
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitItem.box_cnt)
}
inline void ExploitItem::add_box_cnt(::google::protobuf::uint32 value) {
  box_cnt_.Add(value);
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitItem.box_cnt)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ExploitItem::box_cnt() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitItem.box_cnt)
  return box_cnt_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ExploitItem::mutable_box_cnt() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitItem.box_cnt)
  return &box_cnt_;
}

// repeated .ExploitBoxConfig.ExploitReward reward = 4;
inline int ExploitItem::reward_size() const {
  return reward_.size();
}
inline void ExploitItem::clear_reward() {
  reward_.Clear();
}
inline const ::ExploitBoxConfig::ExploitReward& ExploitItem::reward(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitItem.reward)
  return reward_.Get(index);
}
inline ::ExploitBoxConfig::ExploitReward* ExploitItem::mutable_reward(int index) {
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.ExploitItem.reward)
  return reward_.Mutable(index);
}
inline ::ExploitBoxConfig::ExploitReward* ExploitItem::add_reward() {
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitItem.reward)
  return reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitReward >&
ExploitItem::reward() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitItem.reward)
  return reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitReward >*
ExploitItem::mutable_reward() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitItem.reward)
  return &reward_;
}

// repeated .ExploitBoxConfig.BaseRewardItem base_reward = 5;
inline int ExploitItem::base_reward_size() const {
  return base_reward_.size();
}
inline void ExploitItem::clear_base_reward() {
  base_reward_.Clear();
}
inline const ::ExploitBoxConfig::BaseRewardItem& ExploitItem::base_reward(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitItem.base_reward)
  return base_reward_.Get(index);
}
inline ::ExploitBoxConfig::BaseRewardItem* ExploitItem::mutable_base_reward(int index) {
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.ExploitItem.base_reward)
  return base_reward_.Mutable(index);
}
inline ::ExploitBoxConfig::BaseRewardItem* ExploitItem::add_base_reward() {
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitItem.base_reward)
  return base_reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::BaseRewardItem >&
ExploitItem::base_reward() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitItem.base_reward)
  return base_reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::BaseRewardItem >*
ExploitItem::mutable_base_reward() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitItem.base_reward)
  return &base_reward_;
}

// -------------------------------------------------------------------

// ExploitBox

// repeated uint32 prob = 1;
inline int ExploitBox::prob_size() const {
  return prob_.size();
}
inline void ExploitBox::clear_prob() {
  prob_.Clear();
}
inline ::google::protobuf::uint32 ExploitBox::prob(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitBox.prob)
  return prob_.Get(index);
}
inline void ExploitBox::set_prob(int index, ::google::protobuf::uint32 value) {
  prob_.Set(index, value);
  // @@protoc_insertion_point(field_set:ExploitBoxConfig.ExploitBox.prob)
}
inline void ExploitBox::add_prob(::google::protobuf::uint32 value) {
  prob_.Add(value);
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitBox.prob)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ExploitBox::prob() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitBox.prob)
  return prob_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ExploitBox::mutable_prob() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitBox.prob)
  return &prob_;
}

// required .ExploitBoxConfig.ExploitRandomMul random_mul = 2;
inline bool ExploitBox::has_random_mul() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExploitBox::set_has_random_mul() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExploitBox::clear_has_random_mul() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExploitBox::clear_random_mul() {
  if (random_mul_ != NULL) random_mul_->::ExploitBoxConfig::ExploitRandomMul::Clear();
  clear_has_random_mul();
}
inline const ::ExploitBoxConfig::ExploitRandomMul& ExploitBox::random_mul() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitBox.random_mul)
  return random_mul_ != NULL ? *random_mul_ : *default_instance_->random_mul_;
}
inline ::ExploitBoxConfig::ExploitRandomMul* ExploitBox::mutable_random_mul() {
  set_has_random_mul();
  if (random_mul_ == NULL) random_mul_ = new ::ExploitBoxConfig::ExploitRandomMul;
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.ExploitBox.random_mul)
  return random_mul_;
}
inline ::ExploitBoxConfig::ExploitRandomMul* ExploitBox::release_random_mul() {
  clear_has_random_mul();
  ::ExploitBoxConfig::ExploitRandomMul* temp = random_mul_;
  random_mul_ = NULL;
  return temp;
}
inline void ExploitBox::set_allocated_random_mul(::ExploitBoxConfig::ExploitRandomMul* random_mul) {
  delete random_mul_;
  random_mul_ = random_mul;
  if (random_mul) {
    set_has_random_mul();
  } else {
    clear_has_random_mul();
  }
  // @@protoc_insertion_point(field_set_allocated:ExploitBoxConfig.ExploitBox.random_mul)
}

// repeated .ExploitBoxConfig.ExploitItem out = 3;
inline int ExploitBox::out_size() const {
  return out_.size();
}
inline void ExploitBox::clear_out() {
  out_.Clear();
}
inline const ::ExploitBoxConfig::ExploitItem& ExploitBox::out(int index) const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.ExploitBox.out)
  return out_.Get(index);
}
inline ::ExploitBoxConfig::ExploitItem* ExploitBox::mutable_out(int index) {
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.ExploitBox.out)
  return out_.Mutable(index);
}
inline ::ExploitBoxConfig::ExploitItem* ExploitBox::add_out() {
  // @@protoc_insertion_point(field_add:ExploitBoxConfig.ExploitBox.out)
  return out_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitItem >&
ExploitBox::out() const {
  // @@protoc_insertion_point(field_list:ExploitBoxConfig.ExploitBox.out)
  return out_;
}
inline ::google::protobuf::RepeatedPtrField< ::ExploitBoxConfig::ExploitItem >*
ExploitBox::mutable_out() {
  // @@protoc_insertion_point(field_mutable_list:ExploitBoxConfig.ExploitBox.out)
  return &out_;
}

// -------------------------------------------------------------------

// Exploit

// required .ExploitBoxConfig.ExploitBox exploit = 1;
inline bool Exploit::has_exploit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exploit::set_has_exploit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exploit::clear_has_exploit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exploit::clear_exploit() {
  if (exploit_ != NULL) exploit_->::ExploitBoxConfig::ExploitBox::Clear();
  clear_has_exploit();
}
inline const ::ExploitBoxConfig::ExploitBox& Exploit::exploit() const {
  // @@protoc_insertion_point(field_get:ExploitBoxConfig.Exploit.exploit)
  return exploit_ != NULL ? *exploit_ : *default_instance_->exploit_;
}
inline ::ExploitBoxConfig::ExploitBox* Exploit::mutable_exploit() {
  set_has_exploit();
  if (exploit_ == NULL) exploit_ = new ::ExploitBoxConfig::ExploitBox;
  // @@protoc_insertion_point(field_mutable:ExploitBoxConfig.Exploit.exploit)
  return exploit_;
}
inline ::ExploitBoxConfig::ExploitBox* Exploit::release_exploit() {
  clear_has_exploit();
  ::ExploitBoxConfig::ExploitBox* temp = exploit_;
  exploit_ = NULL;
  return temp;
}
inline void Exploit::set_allocated_exploit(::ExploitBoxConfig::ExploitBox* exploit) {
  delete exploit_;
  exploit_ = exploit;
  if (exploit) {
    set_has_exploit();
  } else {
    clear_has_exploit();
  }
  // @@protoc_insertion_point(field_set_allocated:ExploitBoxConfig.Exploit.exploit)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ExploitBoxConfig

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ExploitBoxConfig_2eproto__INCLUDED
