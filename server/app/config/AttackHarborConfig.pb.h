// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AttackHarborConfig.proto

#ifndef PROTOBUF_AttackHarborConfig_2eproto__INCLUDED
#define PROTOBUF_AttackHarborConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "RewardConfig.pb.h"
// @@protoc_insertion_point(includes)

namespace AttackHarborConfig {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AttackHarborConfig_2eproto();
void protobuf_AssignDesc_AttackHarborConfig_2eproto();
void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

class NPCInfo;
class OpenPlatformNPC;
class NPCRefresh;
class OpenPlatformReward;
class CountryRankReward;
class AttackPearlHarbor;

// ===================================================================

class NPCInfo : public ::google::protobuf::Message {
 public:
  NPCInfo();
  virtual ~NPCInfo();

  NPCInfo(const NPCInfo& from);

  inline NPCInfo& operator=(const NPCInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NPCInfo& default_instance();

  void Swap(NPCInfo* other);

  // implements Message ----------------------------------------------

  NPCInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NPCInfo& from);
  void MergeFrom(const NPCInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 npcid = 1;
  inline bool has_npcid() const;
  inline void clear_npcid();
  static const int kNpcidFieldNumber = 1;
  inline ::google::protobuf::uint32 npcid() const;
  inline void set_npcid(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AttackHarborConfig.NPCInfo)
 private:
  inline void set_has_npcid();
  inline void clear_has_npcid();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 npcid_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_AttackHarborConfig_2eproto();
  friend void protobuf_AssignDesc_AttackHarborConfig_2eproto();
  friend void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

  void InitAsDefaultInstance();
  static NPCInfo* default_instance_;
};
// -------------------------------------------------------------------

class OpenPlatformNPC : public ::google::protobuf::Message {
 public:
  OpenPlatformNPC();
  virtual ~OpenPlatformNPC();

  OpenPlatformNPC(const OpenPlatformNPC& from);

  inline OpenPlatformNPC& operator=(const OpenPlatformNPC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenPlatformNPC& default_instance();

  void Swap(OpenPlatformNPC* other);

  // implements Message ----------------------------------------------

  OpenPlatformNPC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenPlatformNPC& from);
  void MergeFrom(const OpenPlatformNPC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 startday = 1;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartdayFieldNumber = 1;
  inline ::google::protobuf::uint32 startday() const;
  inline void set_startday(::google::protobuf::uint32 value);

  // repeated .AttackHarborConfig.NPCInfo npcs = 2;
  inline int npcs_size() const;
  inline void clear_npcs();
  static const int kNpcsFieldNumber = 2;
  inline const ::AttackHarborConfig::NPCInfo& npcs(int index) const;
  inline ::AttackHarborConfig::NPCInfo* mutable_npcs(int index);
  inline ::AttackHarborConfig::NPCInfo* add_npcs();
  inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCInfo >&
      npcs() const;
  inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCInfo >*
      mutable_npcs();

  // @@protoc_insertion_point(class_scope:AttackHarborConfig.OpenPlatformNPC)
 private:
  inline void set_has_startday();
  inline void clear_has_startday();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCInfo > npcs_;
  ::google::protobuf::uint32 startday_;
  friend void  protobuf_AddDesc_AttackHarborConfig_2eproto();
  friend void protobuf_AssignDesc_AttackHarborConfig_2eproto();
  friend void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

  void InitAsDefaultInstance();
  static OpenPlatformNPC* default_instance_;
};
// -------------------------------------------------------------------

class NPCRefresh : public ::google::protobuf::Message {
 public:
  NPCRefresh();
  virtual ~NPCRefresh();

  NPCRefresh(const NPCRefresh& from);

  inline NPCRefresh& operator=(const NPCRefresh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NPCRefresh& default_instance();

  void Swap(NPCRefresh* other);

  // implements Message ----------------------------------------------

  NPCRefresh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NPCRefresh& from);
  void MergeFrom(const NPCRefresh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 cid = 1;
  inline int cid_size() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::uint32 cid(int index) const;
  inline void set_cid(int index, ::google::protobuf::uint32 value);
  inline void add_cid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cid();

  // required uint32 enemy_kindom = 2;
  inline bool has_enemy_kindom() const;
  inline void clear_enemy_kindom();
  static const int kEnemyKindomFieldNumber = 2;
  inline ::google::protobuf::uint32 enemy_kindom() const;
  inline void set_enemy_kindom(::google::protobuf::uint32 value);

  // required uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // repeated .AttackHarborConfig.OpenPlatformNPC open_platform_npc = 4;
  inline int open_platform_npc_size() const;
  inline void clear_open_platform_npc();
  static const int kOpenPlatformNpcFieldNumber = 4;
  inline const ::AttackHarborConfig::OpenPlatformNPC& open_platform_npc(int index) const;
  inline ::AttackHarborConfig::OpenPlatformNPC* mutable_open_platform_npc(int index);
  inline ::AttackHarborConfig::OpenPlatformNPC* add_open_platform_npc();
  inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformNPC >&
      open_platform_npc() const;
  inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformNPC >*
      mutable_open_platform_npc();

  // @@protoc_insertion_point(class_scope:AttackHarborConfig.NPCRefresh)
 private:
  inline void set_has_enemy_kindom();
  inline void clear_has_enemy_kindom();
  inline void set_has_start_time();
  inline void clear_has_start_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cid_;
  ::google::protobuf::uint32 enemy_kindom_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformNPC > open_platform_npc_;
  friend void  protobuf_AddDesc_AttackHarborConfig_2eproto();
  friend void protobuf_AssignDesc_AttackHarborConfig_2eproto();
  friend void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

  void InitAsDefaultInstance();
  static NPCRefresh* default_instance_;
};
// -------------------------------------------------------------------

class OpenPlatformReward : public ::google::protobuf::Message {
 public:
  OpenPlatformReward();
  virtual ~OpenPlatformReward();

  OpenPlatformReward(const OpenPlatformReward& from);

  inline OpenPlatformReward& operator=(const OpenPlatformReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenPlatformReward& default_instance();

  void Swap(OpenPlatformReward* other);

  // implements Message ----------------------------------------------

  OpenPlatformReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenPlatformReward& from);
  void MergeFrom(const OpenPlatformReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 startday = 1;
  inline bool has_startday() const;
  inline void clear_startday();
  static const int kStartdayFieldNumber = 1;
  inline ::google::protobuf::uint32 startday() const;
  inline void set_startday(::google::protobuf::uint32 value);

  // repeated .RewardConfig.Reward reward = 2;
  inline int reward_size() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::RewardConfig::Reward& reward(int index) const;
  inline ::RewardConfig::Reward* mutable_reward(int index);
  inline ::RewardConfig::Reward* add_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::RewardConfig::Reward >&
      reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::RewardConfig::Reward >*
      mutable_reward();

  // @@protoc_insertion_point(class_scope:AttackHarborConfig.OpenPlatformReward)
 private:
  inline void set_has_startday();
  inline void clear_has_startday();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RewardConfig::Reward > reward_;
  ::google::protobuf::uint32 startday_;
  friend void  protobuf_AddDesc_AttackHarborConfig_2eproto();
  friend void protobuf_AssignDesc_AttackHarborConfig_2eproto();
  friend void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

  void InitAsDefaultInstance();
  static OpenPlatformReward* default_instance_;
};
// -------------------------------------------------------------------

class CountryRankReward : public ::google::protobuf::Message {
 public:
  CountryRankReward();
  virtual ~CountryRankReward();

  CountryRankReward(const CountryRankReward& from);

  inline CountryRankReward& operator=(const CountryRankReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CountryRankReward& default_instance();

  void Swap(CountryRankReward* other);

  // implements Message ----------------------------------------------

  CountryRankReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CountryRankReward& from);
  void MergeFrom(const CountryRankReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // repeated .AttackHarborConfig.OpenPlatformReward open_platform_reward = 2;
  inline int open_platform_reward_size() const;
  inline void clear_open_platform_reward();
  static const int kOpenPlatformRewardFieldNumber = 2;
  inline const ::AttackHarborConfig::OpenPlatformReward& open_platform_reward(int index) const;
  inline ::AttackHarborConfig::OpenPlatformReward* mutable_open_platform_reward(int index);
  inline ::AttackHarborConfig::OpenPlatformReward* add_open_platform_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformReward >&
      open_platform_reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformReward >*
      mutable_open_platform_reward();

  // @@protoc_insertion_point(class_scope:AttackHarborConfig.CountryRankReward)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformReward > open_platform_reward_;
  ::google::protobuf::uint32 rank_;
  friend void  protobuf_AddDesc_AttackHarborConfig_2eproto();
  friend void protobuf_AssignDesc_AttackHarborConfig_2eproto();
  friend void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

  void InitAsDefaultInstance();
  static CountryRankReward* default_instance_;
};
// -------------------------------------------------------------------

class AttackPearlHarbor : public ::google::protobuf::Message {
 public:
  AttackPearlHarbor();
  virtual ~AttackPearlHarbor();

  AttackPearlHarbor(const AttackPearlHarbor& from);

  inline AttackPearlHarbor& operator=(const AttackPearlHarbor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttackPearlHarbor& default_instance();

  void Swap(AttackPearlHarbor* other);

  // implements Message ----------------------------------------------

  AttackPearlHarbor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttackPearlHarbor& from);
  void MergeFrom(const AttackPearlHarbor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AttackHarborConfig.NPCRefresh npcrefresh = 1;
  inline int npcrefresh_size() const;
  inline void clear_npcrefresh();
  static const int kNpcrefreshFieldNumber = 1;
  inline const ::AttackHarborConfig::NPCRefresh& npcrefresh(int index) const;
  inline ::AttackHarborConfig::NPCRefresh* mutable_npcrefresh(int index);
  inline ::AttackHarborConfig::NPCRefresh* add_npcrefresh();
  inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCRefresh >&
      npcrefresh() const;
  inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCRefresh >*
      mutable_npcrefresh();

  // required uint32 refresh_frequency = 2;
  inline bool has_refresh_frequency() const;
  inline void clear_refresh_frequency();
  static const int kRefreshFrequencyFieldNumber = 2;
  inline ::google::protobuf::uint32 refresh_frequency() const;
  inline void set_refresh_frequency(::google::protobuf::uint32 value);

  // repeated uint32 individual_reward = 3;
  inline int individual_reward_size() const;
  inline void clear_individual_reward();
  static const int kIndividualRewardFieldNumber = 3;
  inline ::google::protobuf::uint32 individual_reward(int index) const;
  inline void set_individual_reward(int index, ::google::protobuf::uint32 value);
  inline void add_individual_reward(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      individual_reward() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_individual_reward();

  // repeated .AttackHarborConfig.CountryRankReward country_reward = 4;
  inline int country_reward_size() const;
  inline void clear_country_reward();
  static const int kCountryRewardFieldNumber = 4;
  inline const ::AttackHarborConfig::CountryRankReward& country_reward(int index) const;
  inline ::AttackHarborConfig::CountryRankReward* mutable_country_reward(int index);
  inline ::AttackHarborConfig::CountryRankReward* add_country_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::CountryRankReward >&
      country_reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::CountryRankReward >*
      mutable_country_reward();

  // @@protoc_insertion_point(class_scope:AttackHarborConfig.AttackPearlHarbor)
 private:
  inline void set_has_refresh_frequency();
  inline void clear_has_refresh_frequency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCRefresh > npcrefresh_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > individual_reward_;
  ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::CountryRankReward > country_reward_;
  ::google::protobuf::uint32 refresh_frequency_;
  friend void  protobuf_AddDesc_AttackHarborConfig_2eproto();
  friend void protobuf_AssignDesc_AttackHarborConfig_2eproto();
  friend void protobuf_ShutdownFile_AttackHarborConfig_2eproto();

  void InitAsDefaultInstance();
  static AttackPearlHarbor* default_instance_;
};
// ===================================================================


// ===================================================================

// NPCInfo

// required uint32 npcid = 1;
inline bool NPCInfo::has_npcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPCInfo::set_has_npcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPCInfo::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPCInfo::clear_npcid() {
  npcid_ = 0u;
  clear_has_npcid();
}
inline ::google::protobuf::uint32 NPCInfo::npcid() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.NPCInfo.npcid)
  return npcid_;
}
inline void NPCInfo::set_npcid(::google::protobuf::uint32 value) {
  set_has_npcid();
  npcid_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.NPCInfo.npcid)
}

// required uint32 count = 2;
inline bool NPCInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPCInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPCInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPCInfo::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 NPCInfo::count() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.NPCInfo.count)
  return count_;
}
inline void NPCInfo::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.NPCInfo.count)
}

// -------------------------------------------------------------------

// OpenPlatformNPC

// required uint32 startday = 1;
inline bool OpenPlatformNPC::has_startday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenPlatformNPC::set_has_startday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenPlatformNPC::clear_has_startday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenPlatformNPC::clear_startday() {
  startday_ = 0u;
  clear_has_startday();
}
inline ::google::protobuf::uint32 OpenPlatformNPC::startday() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.OpenPlatformNPC.startday)
  return startday_;
}
inline void OpenPlatformNPC::set_startday(::google::protobuf::uint32 value) {
  set_has_startday();
  startday_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.OpenPlatformNPC.startday)
}

// repeated .AttackHarborConfig.NPCInfo npcs = 2;
inline int OpenPlatformNPC::npcs_size() const {
  return npcs_.size();
}
inline void OpenPlatformNPC::clear_npcs() {
  npcs_.Clear();
}
inline const ::AttackHarborConfig::NPCInfo& OpenPlatformNPC::npcs(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.OpenPlatformNPC.npcs)
  return npcs_.Get(index);
}
inline ::AttackHarborConfig::NPCInfo* OpenPlatformNPC::mutable_npcs(int index) {
  // @@protoc_insertion_point(field_mutable:AttackHarborConfig.OpenPlatformNPC.npcs)
  return npcs_.Mutable(index);
}
inline ::AttackHarborConfig::NPCInfo* OpenPlatformNPC::add_npcs() {
  // @@protoc_insertion_point(field_add:AttackHarborConfig.OpenPlatformNPC.npcs)
  return npcs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCInfo >&
OpenPlatformNPC::npcs() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.OpenPlatformNPC.npcs)
  return npcs_;
}
inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCInfo >*
OpenPlatformNPC::mutable_npcs() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.OpenPlatformNPC.npcs)
  return &npcs_;
}

// -------------------------------------------------------------------

// NPCRefresh

// repeated uint32 cid = 1;
inline int NPCRefresh::cid_size() const {
  return cid_.size();
}
inline void NPCRefresh::clear_cid() {
  cid_.Clear();
}
inline ::google::protobuf::uint32 NPCRefresh::cid(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.NPCRefresh.cid)
  return cid_.Get(index);
}
inline void NPCRefresh::set_cid(int index, ::google::protobuf::uint32 value) {
  cid_.Set(index, value);
  // @@protoc_insertion_point(field_set:AttackHarborConfig.NPCRefresh.cid)
}
inline void NPCRefresh::add_cid(::google::protobuf::uint32 value) {
  cid_.Add(value);
  // @@protoc_insertion_point(field_add:AttackHarborConfig.NPCRefresh.cid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NPCRefresh::cid() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.NPCRefresh.cid)
  return cid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NPCRefresh::mutable_cid() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.NPCRefresh.cid)
  return &cid_;
}

// required uint32 enemy_kindom = 2;
inline bool NPCRefresh::has_enemy_kindom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPCRefresh::set_has_enemy_kindom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPCRefresh::clear_has_enemy_kindom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPCRefresh::clear_enemy_kindom() {
  enemy_kindom_ = 0u;
  clear_has_enemy_kindom();
}
inline ::google::protobuf::uint32 NPCRefresh::enemy_kindom() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.NPCRefresh.enemy_kindom)
  return enemy_kindom_;
}
inline void NPCRefresh::set_enemy_kindom(::google::protobuf::uint32 value) {
  set_has_enemy_kindom();
  enemy_kindom_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.NPCRefresh.enemy_kindom)
}

// required uint32 start_time = 3;
inline bool NPCRefresh::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NPCRefresh::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NPCRefresh::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NPCRefresh::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 NPCRefresh::start_time() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.NPCRefresh.start_time)
  return start_time_;
}
inline void NPCRefresh::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.NPCRefresh.start_time)
}

// repeated .AttackHarborConfig.OpenPlatformNPC open_platform_npc = 4;
inline int NPCRefresh::open_platform_npc_size() const {
  return open_platform_npc_.size();
}
inline void NPCRefresh::clear_open_platform_npc() {
  open_platform_npc_.Clear();
}
inline const ::AttackHarborConfig::OpenPlatformNPC& NPCRefresh::open_platform_npc(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.NPCRefresh.open_platform_npc)
  return open_platform_npc_.Get(index);
}
inline ::AttackHarborConfig::OpenPlatformNPC* NPCRefresh::mutable_open_platform_npc(int index) {
  // @@protoc_insertion_point(field_mutable:AttackHarborConfig.NPCRefresh.open_platform_npc)
  return open_platform_npc_.Mutable(index);
}
inline ::AttackHarborConfig::OpenPlatformNPC* NPCRefresh::add_open_platform_npc() {
  // @@protoc_insertion_point(field_add:AttackHarborConfig.NPCRefresh.open_platform_npc)
  return open_platform_npc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformNPC >&
NPCRefresh::open_platform_npc() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.NPCRefresh.open_platform_npc)
  return open_platform_npc_;
}
inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformNPC >*
NPCRefresh::mutable_open_platform_npc() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.NPCRefresh.open_platform_npc)
  return &open_platform_npc_;
}

// -------------------------------------------------------------------

// OpenPlatformReward

// required uint32 startday = 1;
inline bool OpenPlatformReward::has_startday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenPlatformReward::set_has_startday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenPlatformReward::clear_has_startday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenPlatformReward::clear_startday() {
  startday_ = 0u;
  clear_has_startday();
}
inline ::google::protobuf::uint32 OpenPlatformReward::startday() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.OpenPlatformReward.startday)
  return startday_;
}
inline void OpenPlatformReward::set_startday(::google::protobuf::uint32 value) {
  set_has_startday();
  startday_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.OpenPlatformReward.startday)
}

// repeated .RewardConfig.Reward reward = 2;
inline int OpenPlatformReward::reward_size() const {
  return reward_.size();
}
inline void OpenPlatformReward::clear_reward() {
  reward_.Clear();
}
inline const ::RewardConfig::Reward& OpenPlatformReward::reward(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.OpenPlatformReward.reward)
  return reward_.Get(index);
}
inline ::RewardConfig::Reward* OpenPlatformReward::mutable_reward(int index) {
  // @@protoc_insertion_point(field_mutable:AttackHarborConfig.OpenPlatformReward.reward)
  return reward_.Mutable(index);
}
inline ::RewardConfig::Reward* OpenPlatformReward::add_reward() {
  // @@protoc_insertion_point(field_add:AttackHarborConfig.OpenPlatformReward.reward)
  return reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RewardConfig::Reward >&
OpenPlatformReward::reward() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.OpenPlatformReward.reward)
  return reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::RewardConfig::Reward >*
OpenPlatformReward::mutable_reward() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.OpenPlatformReward.reward)
  return &reward_;
}

// -------------------------------------------------------------------

// CountryRankReward

// required uint32 rank = 1;
inline bool CountryRankReward::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CountryRankReward::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CountryRankReward::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CountryRankReward::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 CountryRankReward::rank() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.CountryRankReward.rank)
  return rank_;
}
inline void CountryRankReward::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.CountryRankReward.rank)
}

// repeated .AttackHarborConfig.OpenPlatformReward open_platform_reward = 2;
inline int CountryRankReward::open_platform_reward_size() const {
  return open_platform_reward_.size();
}
inline void CountryRankReward::clear_open_platform_reward() {
  open_platform_reward_.Clear();
}
inline const ::AttackHarborConfig::OpenPlatformReward& CountryRankReward::open_platform_reward(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.CountryRankReward.open_platform_reward)
  return open_platform_reward_.Get(index);
}
inline ::AttackHarborConfig::OpenPlatformReward* CountryRankReward::mutable_open_platform_reward(int index) {
  // @@protoc_insertion_point(field_mutable:AttackHarborConfig.CountryRankReward.open_platform_reward)
  return open_platform_reward_.Mutable(index);
}
inline ::AttackHarborConfig::OpenPlatformReward* CountryRankReward::add_open_platform_reward() {
  // @@protoc_insertion_point(field_add:AttackHarborConfig.CountryRankReward.open_platform_reward)
  return open_platform_reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformReward >&
CountryRankReward::open_platform_reward() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.CountryRankReward.open_platform_reward)
  return open_platform_reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::OpenPlatformReward >*
CountryRankReward::mutable_open_platform_reward() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.CountryRankReward.open_platform_reward)
  return &open_platform_reward_;
}

// -------------------------------------------------------------------

// AttackPearlHarbor

// repeated .AttackHarborConfig.NPCRefresh npcrefresh = 1;
inline int AttackPearlHarbor::npcrefresh_size() const {
  return npcrefresh_.size();
}
inline void AttackPearlHarbor::clear_npcrefresh() {
  npcrefresh_.Clear();
}
inline const ::AttackHarborConfig::NPCRefresh& AttackPearlHarbor::npcrefresh(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.AttackPearlHarbor.npcrefresh)
  return npcrefresh_.Get(index);
}
inline ::AttackHarborConfig::NPCRefresh* AttackPearlHarbor::mutable_npcrefresh(int index) {
  // @@protoc_insertion_point(field_mutable:AttackHarborConfig.AttackPearlHarbor.npcrefresh)
  return npcrefresh_.Mutable(index);
}
inline ::AttackHarborConfig::NPCRefresh* AttackPearlHarbor::add_npcrefresh() {
  // @@protoc_insertion_point(field_add:AttackHarborConfig.AttackPearlHarbor.npcrefresh)
  return npcrefresh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCRefresh >&
AttackPearlHarbor::npcrefresh() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.AttackPearlHarbor.npcrefresh)
  return npcrefresh_;
}
inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::NPCRefresh >*
AttackPearlHarbor::mutable_npcrefresh() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.AttackPearlHarbor.npcrefresh)
  return &npcrefresh_;
}

// required uint32 refresh_frequency = 2;
inline bool AttackPearlHarbor::has_refresh_frequency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttackPearlHarbor::set_has_refresh_frequency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttackPearlHarbor::clear_has_refresh_frequency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttackPearlHarbor::clear_refresh_frequency() {
  refresh_frequency_ = 0u;
  clear_has_refresh_frequency();
}
inline ::google::protobuf::uint32 AttackPearlHarbor::refresh_frequency() const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.AttackPearlHarbor.refresh_frequency)
  return refresh_frequency_;
}
inline void AttackPearlHarbor::set_refresh_frequency(::google::protobuf::uint32 value) {
  set_has_refresh_frequency();
  refresh_frequency_ = value;
  // @@protoc_insertion_point(field_set:AttackHarborConfig.AttackPearlHarbor.refresh_frequency)
}

// repeated uint32 individual_reward = 3;
inline int AttackPearlHarbor::individual_reward_size() const {
  return individual_reward_.size();
}
inline void AttackPearlHarbor::clear_individual_reward() {
  individual_reward_.Clear();
}
inline ::google::protobuf::uint32 AttackPearlHarbor::individual_reward(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.AttackPearlHarbor.individual_reward)
  return individual_reward_.Get(index);
}
inline void AttackPearlHarbor::set_individual_reward(int index, ::google::protobuf::uint32 value) {
  individual_reward_.Set(index, value);
  // @@protoc_insertion_point(field_set:AttackHarborConfig.AttackPearlHarbor.individual_reward)
}
inline void AttackPearlHarbor::add_individual_reward(::google::protobuf::uint32 value) {
  individual_reward_.Add(value);
  // @@protoc_insertion_point(field_add:AttackHarborConfig.AttackPearlHarbor.individual_reward)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AttackPearlHarbor::individual_reward() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.AttackPearlHarbor.individual_reward)
  return individual_reward_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AttackPearlHarbor::mutable_individual_reward() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.AttackPearlHarbor.individual_reward)
  return &individual_reward_;
}

// repeated .AttackHarborConfig.CountryRankReward country_reward = 4;
inline int AttackPearlHarbor::country_reward_size() const {
  return country_reward_.size();
}
inline void AttackPearlHarbor::clear_country_reward() {
  country_reward_.Clear();
}
inline const ::AttackHarborConfig::CountryRankReward& AttackPearlHarbor::country_reward(int index) const {
  // @@protoc_insertion_point(field_get:AttackHarborConfig.AttackPearlHarbor.country_reward)
  return country_reward_.Get(index);
}
inline ::AttackHarborConfig::CountryRankReward* AttackPearlHarbor::mutable_country_reward(int index) {
  // @@protoc_insertion_point(field_mutable:AttackHarborConfig.AttackPearlHarbor.country_reward)
  return country_reward_.Mutable(index);
}
inline ::AttackHarborConfig::CountryRankReward* AttackPearlHarbor::add_country_reward() {
  // @@protoc_insertion_point(field_add:AttackHarborConfig.AttackPearlHarbor.country_reward)
  return country_reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::CountryRankReward >&
AttackPearlHarbor::country_reward() const {
  // @@protoc_insertion_point(field_list:AttackHarborConfig.AttackPearlHarbor.country_reward)
  return country_reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::AttackHarborConfig::CountryRankReward >*
AttackPearlHarbor::mutable_country_reward() {
  // @@protoc_insertion_point(field_mutable_list:AttackHarborConfig.AttackPearlHarbor.country_reward)
  return &country_reward_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AttackHarborConfig

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AttackHarborConfig_2eproto__INCLUDED
